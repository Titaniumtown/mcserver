From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 31 Jan 2021 02:29:24 -0800
Subject: [PATCH] Optimise general POI access

TODO on merge doc this & delete villager steam patch and move
its diff here

diff --git a/src/main/java/com/tuinity/tuinity/util/PoiAccess.java b/src/main/java/com/tuinity/tuinity/util/PoiAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0ff0de912687004afe8c4c009c7aeeea5f358ac
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/util/PoiAccess.java
@@ -0,0 +1,792 @@
+package com.tuinity.tuinity.util;
+
+import it.unimi.dsi.fastutil.doubles.Double2ObjectMap;
+import it.unimi.dsi.fastutil.doubles.Double2ObjectRBTreeMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.SectionPosition;
+import net.minecraft.server.VillagePlace;
+import net.minecraft.server.VillagePlaceRecord;
+import net.minecraft.server.VillagePlaceSection;
+import net.minecraft.server.VillagePlaceType;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+
+/**
+ * Provides optimised access to POI data. All returned values will be identical to vanilla.
+ */
+public final class PoiAccess {
+
+    public static final class SortedChunkSectionPos {
+
+        public final int relativeX;
+        public final int relativeY;
+        public final int relativeZ;
+
+        public final double smallestDistanceToSection;
+
+        public SortedChunkSectionPos(int relativeX, int relativeY, int relativeZ, double smallestDistanceToSection) {
+            this.relativeX = relativeX;
+            this.relativeY = relativeY;
+            this.relativeZ = relativeZ;
+            this.smallestDistanceToSection = smallestDistanceToSection;
+        }
+
+        protected double smallestDistanceAhead;
+
+    }
+
+    protected static double clamp(final double val, final double min, final double max) {
+        return (val < min ? min : (val > max ? max : val));
+    }
+
+    protected static double getSmallestDistanceSquared(final double boxMinX, final double boxMinY, final double boxMinZ,
+                                                       final double boxMaxX, final double boxMaxY, final double boxMaxZ,
+
+                                                       final double circleX, final double circleY, final double circleZ) {
+        // is the circle center inside the box?
+        if (circleX >= boxMinX && circleX <= boxMaxX && circleY >= boxMinY && circleY <= boxMaxY && circleZ >= boxMinZ && circleZ <= boxMaxZ) {
+            return 0.0;
+        }
+
+        final double boxWidthX = (boxMaxX - boxMinX) / 2.0;
+        final double boxWidthY = (boxMaxY - boxMinY) / 2.0;
+        final double boxWidthZ = (boxMaxZ - boxMinZ) / 2.0;
+
+        final double boxCenterX = (boxMinX + boxMaxX) / 2.0;
+        final double boxCenterY = (boxMinY + boxMaxY) / 2.0;
+        final double boxCenterZ = (boxMinZ + boxMaxZ) / 2.0;
+
+        double centerDiffX = circleX - boxCenterX;
+        double centerDiffY = circleY - boxCenterY;
+        double centerDiffZ = circleZ - boxCenterZ;
+
+        centerDiffX = circleX - (clamp(centerDiffX, -boxWidthX, boxWidthX) + boxCenterX);
+        centerDiffY = circleY - (clamp(centerDiffY, -boxWidthY, boxWidthY) + boxCenterY);
+        centerDiffZ = circleZ - (clamp(centerDiffZ, -boxWidthZ, boxWidthZ) + boxCenterZ);
+
+        return (centerDiffX * centerDiffX) + (centerDiffY * centerDiffY) + (centerDiffZ * centerDiffZ);
+    }
+
+    protected static final Int2ObjectOpenHashMap<List<SortedChunkSectionPos>> cachedSortedPositionsAddHalf =
+            new Int2ObjectOpenHashMap<>();
+    protected static final Int2ObjectOpenHashMap<List<SortedChunkSectionPos>> cachedSortedPositionsNoHalf =
+            new Int2ObjectOpenHashMap<>();
+
+    public static List<SortedChunkSectionPos> getSortedPositions(final BlockPosition center, final int radius, final boolean addHalfToSection) {
+        final Int2ObjectOpenHashMap<List<SortedChunkSectionPos>> map = addHalfToSection ? cachedSortedPositionsAddHalf : cachedSortedPositionsNoHalf;
+        synchronized (map) {
+            List<SortedChunkSectionPos> existing = map.get(radius);
+            if (existing != null) {
+                return existing;
+            }
+        }
+
+        final List<SortedChunkSectionPos> calculated = calculateSortedPositions(radius, addHalfToSection);
+
+        synchronized (map) {
+            map.putIfAbsent(radius, calculated);
+        }
+
+        return calculated;
+    }
+
+    protected static List<SortedChunkSectionPos> calculateSortedPositions(final int radius, final boolean addHalfToSection) {
+        final List<SortedChunkSectionPos> ret = new ArrayList<>();
+
+        final double sourceX = 8.0;
+        final double sourceY = 8.0;
+        final double sourceZ = 8.0;
+        final double minSectionAdd = addHalfToSection ? 0.5 : 0.0;
+        final double maxSectionAdd = addHalfToSection ? 15.5 : 16.0;
+        for (int dy = -radius; dy <= radius; ++dy) {
+            for (int dz = -radius; dz <= radius; ++dz) {
+                for (int dx = -radius; dx <= radius; ++dx) {
+                    double distanceSquared = getSmallestDistanceSquared(
+                            (double)(dx << 4) + minSectionAdd,
+                            (double)(dy << 4) + minSectionAdd,
+                            (double)(dz << 4) + minSectionAdd,
+                            (double)(dx << 4) + maxSectionAdd,
+                            (double)(dy << 4) + maxSectionAdd,
+                            (double)(dz << 4) + maxSectionAdd,
+
+                            sourceX, sourceY, sourceZ
+                    );
+                    // max additional distance (due to varying center point)
+                    final double a = 2*(addHalfToSection ? 7.5 : 8.0);
+                    distanceSquared = Math.sqrt(distanceSquared) - a;
+                    distanceSquared *= distanceSquared;
+
+                    ret.add(new SortedChunkSectionPos(dx, dy, dz, distanceSquared - 1.0e-3)); // account for floating point errors
+                }
+            }
+        }
+
+        final BlockPosition relativeCenter = new BlockPosition(8, 8, 8);
+        ret.sort((s1, s2) -> {
+            return Double.compare(relativeCenter.distanceSquared((s1.relativeX << 4) + 8, (s1.relativeY << 4) + 8, (s1.relativeZ << 4) + 8, false),
+                    relativeCenter.distanceSquared((s2.relativeX << 4) + 8, (s2.relativeY << 4) + 8, (s2.relativeZ << 4) + 8, false));
+        });
+
+        double smallest = Double.MAX_VALUE;
+        for (int i = ret.size() - 1; i >= 0; --i) {
+            final SortedChunkSectionPos chunkPos = ret.get(i);
+            chunkPos.smallestDistanceAhead = smallest;
+            if (chunkPos.smallestDistanceToSection < smallest) {
+                smallest = chunkPos.smallestDistanceToSection;
+            }
+        }
+
+        // we set smallestDistanceAhead so that callers iterating over the list do not need to search any more sections
+        // than they need to (the intersects check for a sphere and a 3d box is seriously expensive, especially with
+        // how many sections there are).
+
+        return ret;
+    }
+
+    // only includes x/z axis
+    // finds the closest poi data by distance.
+    public static BlockPosition findClosestPoiDataPosition(final VillagePlace poiStorage,
+                                                           final Predicate<VillagePlaceType> villagePlaceType,
+                                                           // position predicate must not modify chunk POI
+                                                           final Predicate<BlockPosition> positionPredicate,
+                                                           final BlockPosition sourcePosition,
+                                                           final int range, // distance on x y z axis
+                                                           final double maxDistance,
+                                                           final VillagePlace.Occupancy occupancy,
+                                                           final boolean load) {
+        final VillagePlaceRecord ret = findClosestPoiDataRecord(
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistance, occupancy, load
+        );
+
+        return ret == null ? null : ret.getPosition();
+    }
+
+    // only includes x/z axis
+    // finds the closest poi data by distance. if multiple match the same distance, then they all are returned.
+    public static void findClosestPoiDataPositions(final VillagePlace poiStorage,
+                                                   final Predicate<VillagePlaceType> villagePlaceType,
+                                                   // position predicate must not modify chunk POI
+                                                   final Predicate<BlockPosition> positionPredicate,
+                                                   final BlockPosition sourcePosition,
+                                                   final int range, // distance on x y z axis
+                                                   final double maxDistance,
+                                                   final VillagePlace.Occupancy occupancy,
+                                                   final boolean load,
+                                                   final Set<BlockPosition> ret) {
+        final Set<BlockPosition> positions = new HashSet<>();
+        // pos predicate is last thing that runs before adding to ret.
+        final Predicate<BlockPosition> newPredicate = (final BlockPosition pos) -> {
+            if (positionPredicate != null && !positionPredicate.test(pos)) {
+                return false;
+            }
+            return positions.add(pos.immutableCopy());
+        };
+
+        final List<VillagePlaceRecord> toConvert = new ArrayList<>();
+        findClosestPoiDataRecords(
+                poiStorage, villagePlaceType, newPredicate, sourcePosition, range, maxDistance, occupancy, load, toConvert
+        );
+
+        for (final VillagePlaceRecord record : toConvert) {
+            ret.add(record.getPosition());
+        }
+    }
+
+    // only includes x/z axis
+    // finds the closest poi data by distance.
+    public static VillagePlaceRecord findClosestPoiDataRecord(final VillagePlace poiStorage,
+                                                              final Predicate<VillagePlaceType> villagePlaceType,
+                                                              // position predicate must not modify chunk POI
+                                                              final Predicate<BlockPosition> positionPredicate,
+                                                              final BlockPosition sourcePosition,
+                                                              final int range, // distance on x y z axis
+                                                              final double maxDistance,
+                                                              final VillagePlace.Occupancy occupancy,
+                                                              final boolean load) {
+        final List<VillagePlaceRecord> ret = new ArrayList<>();
+        findClosestPoiDataRecords(
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistance, occupancy, load, ret
+        );
+        return ret.isEmpty() ? null : ret.get(0);
+    }
+
+    // only includes x/z axis
+    // finds the closest poi data by distance. if multiple match the same distance, then they all are returned.
+    public static void findClosestPoiDataRecords(final VillagePlace poiStorage,
+                                                 final Predicate<VillagePlaceType> villagePlaceType,
+                                                 // position predicate must not modify chunk POI
+                                                 final Predicate<BlockPosition> positionPredicate,
+                                                 final BlockPosition sourcePosition,
+                                                 final int range, // distance on x y z axis
+                                                 final double maxDistance,
+                                                 final VillagePlace.Occupancy occupancy,
+                                                 final boolean load,
+                                                 final List<VillagePlaceRecord> ret) {
+        final Predicate<? super VillagePlaceRecord> occupancyFilter = occupancy.getPredicate();
+
+        final List<VillagePlaceRecord> closestRecords = new ArrayList<>();
+        double closestDistanceSquared = maxDistance * maxDistance;
+
+        final int lowerX = MathHelper.floor(sourcePosition.getX() - range) >> 4;
+        final int lowerZ = MathHelper.floor(sourcePosition.getZ() - range) >> 4;
+        final int upperX = MathHelper.floor(sourcePosition.getX() + range) >> 4;
+        final int upperZ = MathHelper.floor(sourcePosition.getZ() + range) >> 4;
+
+        final List<SortedChunkSectionPos> chunks = getSortedPositions(sourcePosition, (range + 15) >> 4, true);
+
+        final int centerX = sourcePosition.getX() >> 4;
+        final int centerY = sourcePosition.getY() >> 4;
+        final int centerZ = sourcePosition.getZ() >> 4;
+
+        for (final SortedChunkSectionPos relativeSection : chunks) {
+            if (relativeSection.smallestDistanceToSection > closestDistanceSquared) {
+                if (relativeSection.smallestDistanceAhead > closestDistanceSquared) {
+                    break;
+                }
+                continue;
+            }
+            final int sectionX = relativeSection.relativeX + centerX;
+            final int sectionY = relativeSection.relativeY + centerY;
+            final int sectionZ = relativeSection.relativeZ + centerZ;
+
+            if (sectionY < 0 || sectionY > 15 || sectionX < lowerX || sectionX > upperX || sectionZ < lowerZ || sectionZ > upperZ) {
+                // out of bound chunk
+                continue;
+            }
+
+            final double sectionDistanceSquared = getSmallestDistanceSquared(
+                    (sectionX << 4) + 0.5,
+                    (sectionY << 4) + 0.5,
+                    (sectionZ << 4) + 0.5,
+                    (sectionX << 4) + 15.5,
+                    (sectionY << 4) + 15.5,
+                    (sectionZ << 4) + 15.5,
+                    (double)sourcePosition.getX(), (double)sourcePosition.getY(), (double)sourcePosition.getZ()
+            );
+            if (sectionDistanceSquared > closestDistanceSquared) {
+                continue;
+            }
+
+            final Optional<VillagePlaceSection> poiSectionOptional = load ? poiStorage.getOrLoad(SectionPosition.asLong(sectionX, sectionY, sectionZ))
+                    : poiStorage.getIfLoaded(SectionPosition.asLong(sectionX, sectionY, sectionZ));
+
+            if (poiSectionOptional == null || !poiSectionOptional.isPresent()) {
+                continue;
+            }
+
+            final VillagePlaceSection poiSection = poiSectionOptional.orElse(null);
+
+            final Map<VillagePlaceType, Set<VillagePlaceRecord>> sectionData = poiSection.getData();
+            if (sectionData.isEmpty()) {
+                continue;
+            }
+
+            // now we search the section data
+            for (final Map.Entry<VillagePlaceType, Set<VillagePlaceRecord>> entry : sectionData.entrySet()) {
+                if (!villagePlaceType.test(entry.getKey())) {
+                    // filter out by poi type
+                    continue;
+                }
+
+                // now we can look at the poi data
+                for (final VillagePlaceRecord poiData : entry.getValue()) {
+                    if (!occupancyFilter.test(poiData)) {
+                        // filter by occupancy
+                        continue;
+                    }
+
+                    final BlockPosition poiPosition = poiData.getPosition();
+
+                    if (Math.abs(poiPosition.getX() - sourcePosition.getX()) > range
+                            || Math.abs(poiPosition.getZ() - sourcePosition.getZ()) > range) {
+                        // out of range for square radius
+                        continue;
+                    }
+
+                    // it's important that it's poiPosition.distanceSquared(source) : the value actually is different IF the values are swapped!
+                    final double dataRange = poiPosition.distanceSquared(sourcePosition);
+
+                    if (dataRange > closestDistanceSquared) {
+                        // out of range for distance check
+                        continue;
+                    }
+
+                    if (positionPredicate != null && !positionPredicate.test(poiPosition)) {
+                        // filter by position
+                        continue;
+                    }
+
+                    if (dataRange < closestDistanceSquared) {
+                        closestRecords.clear();
+                        closestDistanceSquared = dataRange;
+                    }
+                    closestRecords.add(poiData);
+                }
+            }
+        }
+
+        // uh oh! we might have multiple records that match the distance sorting!
+        // we need to re-order our results by the way vanilla would have iterated over them.
+        closestRecords.sort((record1, record2) -> {
+            // vanilla iterates the same way we do for data inside sections, so we know the ordering inside a section
+            // is fine and should be preserved (this sort is stable so we're good there)
+            // but they iterate sections by x then by z (like the following)
+            // for (int x = -dx; x <= dx; ++x)
+            //     for (int z = -dz; z <= dz; ++z)
+            //  ....
+            // so we need to reorder such that records with lower chunk z, then lower chunk x come first
+            final BlockPosition pos1 = record1.getPosition();
+            final BlockPosition pos2 = record2.getPosition();
+
+            final int cx1 = pos1.getX() >> 4;
+            final int cz1 = pos1.getZ() >> 4;
+
+            final int cx2 = pos2.getX() >> 4;
+            final int cz2 = pos2.getZ() >> 4;
+
+            if (cz2 != cz1) {
+                // want smaller z
+                return Integer.compare(cz1, cz2);
+            }
+
+            if (cx2 != cx1) {
+                // want smaller x
+                return Integer.compare(cx1, cx2);
+            }
+
+            // same chunk
+            // once vanilla has the chunk, it will iterate from all of the chunk sections starting from smaller y
+            // so now we just compare section y, wanting smaller y
+
+            return Integer.compare(pos1.getY() >> 4, pos2.getY() >> 4);
+        });
+
+        // now we match perfectly what vanilla would have outputted, without having to search the whole radius (hopefully).
+        ret.addAll(closestRecords);
+    }
+
+    // finds the closest poi entry pos.
+    public static BlockPosition findNearestPoiPosition(final VillagePlace poiStorage,
+                                                       final Predicate<VillagePlaceType> villagePlaceType,
+                                                       // position predicate must not modify chunk POI
+                                                       final Predicate<BlockPosition> positionPredicate,
+                                                       final BlockPosition sourcePosition,
+                                                       final int range, // distance on x y z axis
+                                                       final double maxDistance,
+                                                       final VillagePlace.Occupancy occupancy,
+                                                       final boolean load) {
+        final VillagePlaceRecord ret = findNearestPoiRecord(
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistance, occupancy, load
+        );
+        return ret == null ? null : ret.getPosition();
+    }
+
+    // finds the closest `max` poi entry positions.
+    public static void findNearestPoiPositions(final VillagePlace poiStorage,
+                                               final Predicate<VillagePlaceType> villagePlaceType,
+                                               // position predicate must not modify chunk POI
+                                               final Predicate<BlockPosition> positionPredicate,
+                                               final BlockPosition sourcePosition,
+                                               final int range, // distance on x y z axis
+                                               final double maxDistance,
+                                               final VillagePlace.Occupancy occupancy,
+                                               final boolean load,
+                                               final int max,
+                                               final List<BlockPosition> ret) {
+        final Set<BlockPosition> positions = new HashSet<>();
+        // pos predicate is last thing that runs before adding to ret.
+        final Predicate<BlockPosition> newPredicate = (final BlockPosition pos) -> {
+            if (positionPredicate != null && !positionPredicate.test(pos)) {
+                return false;
+            }
+            return positions.add(pos.immutableCopy());
+        };
+
+        final List<VillagePlaceRecord> toConvert = new ArrayList<>();
+        findNearestPoiRecords(
+                poiStorage, villagePlaceType, newPredicate, sourcePosition, range, maxDistance, occupancy, load, max, toConvert
+        );
+
+        for (final VillagePlaceRecord record : toConvert) {
+            ret.add(record.getPosition());
+        }
+    }
+
+    // finds the closest poi entry.
+    public static VillagePlaceRecord findNearestPoiRecord(final VillagePlace poiStorage,
+                                                          final Predicate<VillagePlaceType> villagePlaceType,
+                                                          // position predicate must not modify chunk POI
+                                                          final Predicate<BlockPosition> positionPredicate,
+                                                          final BlockPosition sourcePosition,
+                                                          final int range, // distance on x y z axis
+                                                          final double maxDistance,
+                                                          final VillagePlace.Occupancy occupancy,
+                                                          final boolean load) {
+        final List<VillagePlaceRecord> ret = new ArrayList<>();
+        findNearestPoiRecords(
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistance, occupancy, load,
+                1, ret
+        );
+        return ret.isEmpty() ? null : ret.get(0);
+    }
+
+    // finds the closest `max` poi entries.
+    public static void findNearestPoiRecords(final VillagePlace poiStorage,
+                                             final Predicate<VillagePlaceType> villagePlaceType,
+                                             // position predicate must not modify chunk POI
+                                             final Predicate<BlockPosition> positionPredicate,
+                                             final BlockPosition sourcePosition,
+                                             final int range, // distance on x y z axis
+                                             final double maxDistance,
+                                             final VillagePlace.Occupancy occupancy,
+                                             final boolean load,
+                                             final int max,
+                                             final List<VillagePlaceRecord> ret) {
+        final Predicate<? super VillagePlaceRecord> occupancyFilter = occupancy.getPredicate();
+
+        final double maxDistanceSquared = maxDistance * maxDistance;
+        final Double2ObjectRBTreeMap<List<VillagePlaceRecord>> closestRecords = new Double2ObjectRBTreeMap<>();
+        int totalRecords = 0;
+        double furthestDistanceSquared = maxDistanceSquared;
+
+        final int lowerX = MathHelper.floor(sourcePosition.getX() - range) >> 4;
+        final int lowerZ = MathHelper.floor(sourcePosition.getZ() - range) >> 4;
+        final int upperX = MathHelper.floor(sourcePosition.getX() + range) >> 4;
+        final int upperZ = MathHelper.floor(sourcePosition.getZ() + range) >> 4;
+
+        final List<SortedChunkSectionPos> chunks = getSortedPositions(sourcePosition, (range + 15) >> 4, true);
+
+        final int centerX = sourcePosition.getX() >> 4;
+        final int centerY = sourcePosition.getY() >> 4;
+        final int centerZ = sourcePosition.getZ() >> 4;
+
+        for (final SortedChunkSectionPos relativeSection : chunks) {
+            if (relativeSection.smallestDistanceToSection > (totalRecords >= max ? furthestDistanceSquared : maxDistanceSquared)) {
+                if (relativeSection.smallestDistanceAhead > (totalRecords >= max ? furthestDistanceSquared : maxDistanceSquared)) {
+                    break;
+                }
+                continue;
+            }
+            final int sectionX = relativeSection.relativeX + centerX;
+            final int sectionY = relativeSection.relativeY + centerY;
+            final int sectionZ = relativeSection.relativeZ + centerZ;
+
+            if (sectionY < 0 || sectionY > 15 || sectionX < lowerX || sectionX > upperX || sectionZ < lowerZ || sectionZ > upperZ) {
+                // out of bound chunk
+                continue;
+            }
+
+            final double sectionDistanceSquared = getSmallestDistanceSquared(
+                    (sectionX << 4) + 0.5,
+                    (sectionY << 4) + 0.5,
+                    (sectionZ << 4) + 0.5,
+                    (sectionX << 4) + 15.5,
+                    (sectionY << 4) + 15.5,
+                    (sectionZ << 4) + 15.5,
+                    (double) sourcePosition.getX(), (double) sourcePosition.getY(), (double) sourcePosition.getZ()
+            );
+
+            if (sectionDistanceSquared > (totalRecords >= max ? furthestDistanceSquared : maxDistanceSquared)) {
+                continue;
+            }
+
+            final Optional<VillagePlaceSection> poiSectionOptional = load ? poiStorage.getOrLoad(SectionPosition.asLong(sectionX, sectionY, sectionZ))
+                    : poiStorage.getIfLoaded(SectionPosition.asLong(sectionX, sectionY, sectionZ));
+
+            if (poiSectionOptional == null || !poiSectionOptional.isPresent()) {
+                continue;
+            }
+
+            final VillagePlaceSection poiSection = poiSectionOptional.orElse(null);
+
+            final Map<VillagePlaceType, Set<VillagePlaceRecord>> sectionData = poiSection.getData();
+            if (sectionData.isEmpty()) {
+                continue;
+            }
+
+            // now we search the section data
+            for (final Map.Entry<VillagePlaceType, Set<VillagePlaceRecord>> entry : sectionData.entrySet()) {
+                if (!villagePlaceType.test(entry.getKey())) {
+                    // filter out by poi type
+                    continue;
+                }
+
+                // now we can look at the poi data
+                for (final VillagePlaceRecord poiData : entry.getValue()) {
+                    if (!occupancyFilter.test(poiData)) {
+                        // filter by occupancy
+                        continue;
+                    }
+
+                    final BlockPosition poiPosition = poiData.getPosition();
+
+                    if (Math.abs(poiPosition.getX() - sourcePosition.getX()) > range
+                            || Math.abs(poiPosition.getZ() - sourcePosition.getZ()) > range) {
+                        // out of range for square radius
+                        continue;
+                    }
+
+                    // it's important that it's poiPosition.distanceSquared(source) : the value actually is different IF the values are swapped!
+                    final double dataRange = poiPosition.distanceSquared(sourcePosition);
+
+                    if (dataRange > maxDistanceSquared) {
+                        // out of range for distance check
+                        continue;
+                    }
+
+                    if (dataRange > furthestDistanceSquared) {
+                        if (totalRecords >= max) {
+                            // out of range for distance check
+                            continue;
+                        } else {
+                            furthestDistanceSquared = dataRange;
+                        }
+                    }
+
+                    if (positionPredicate != null && !positionPredicate.test(poiPosition)) {
+                        // filter by position
+                        continue;
+                    }
+
+                    closestRecords.computeIfAbsent(dataRange, (final double key) -> {
+                        return new ArrayList<>();
+                    }).add(poiData);
+
+                    if (++totalRecords >= max) {
+                        if (closestRecords.size() >= 2) {
+                            int entriesInClosest = 0;
+                            final Iterator<Double2ObjectMap.Entry<List<VillagePlaceRecord>>> iterator = closestRecords.double2ObjectEntrySet().iterator();
+                            double nextFurthestDistanceSquared = 0.0;
+
+                            for (int i = 0, len = closestRecords.size() - 1; i < len; ++i) {
+                                final Double2ObjectMap.Entry<List<VillagePlaceRecord>> recordEntry = iterator.next();
+                                entriesInClosest += recordEntry.getValue().size();
+                                nextFurthestDistanceSquared = recordEntry.getDoubleKey();
+                            }
+
+                            if (entriesInClosest >= max) {
+                                // the last set of entries at range wont even be considered for sure... nuke em
+                                final Double2ObjectMap.Entry<List<VillagePlaceRecord>> recordEntry = iterator.next();
+                                totalRecords -= recordEntry.getValue().size();
+                                iterator.remove();
+
+                                furthestDistanceSquared = nextFurthestDistanceSquared;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        final List<VillagePlaceRecord> closestRecordsUnsorted = new ArrayList<>();
+
+        // we're done here, so now just flatten the map and sort it.
+
+        for (final List<VillagePlaceRecord> records : closestRecords.values()) {
+            closestRecordsUnsorted.addAll(records);
+        }
+
+        // uh oh! we might have multiple records that match the distance sorting!
+        // we need to re-order our results by the way vanilla would have iterated over them.
+        closestRecordsUnsorted.sort((record1, record2) -> {
+            // vanilla iterates the same way we do for data inside sections, so we know the ordering inside a section
+            // is fine and should be preserved (this sort is stable so we're good there)
+            // but they iterate sections by x then by z (like the following)
+            // for (int x = -dx; x <= dx; ++x)
+            //     for (int z = -dz; z <= dz; ++z)
+            //  ....
+            // so we need to reorder such that records with lower chunk z, then lower chunk x come first
+            final BlockPosition pos1 = record1.getPosition();
+            final BlockPosition pos2 = record2.getPosition();
+
+            final int cx1 = pos1.getX() >> 4;
+            final int cz1 = pos1.getZ() >> 4;
+
+            final int cx2 = pos2.getX() >> 4;
+            final int cz2 = pos2.getZ() >> 4;
+
+            if (cz2 != cz1) {
+                // want smaller z
+                return Integer.compare(cz1, cz2);
+            }
+
+            if (cx2 != cx1) {
+                // want smaller x
+                return Integer.compare(cx1, cx2);
+            }
+
+            // same chunk
+            // once vanilla has the chunk, it will iterate from all of the chunk sections starting from smaller y
+            // so now we just compare section y, wanting smaller section y
+
+            return Integer.compare(pos1.getY() >> 4, pos2.getY() >> 4);
+        });
+
+        // trim out any entries exceeding our maximum
+        for (int i = closestRecordsUnsorted.size() - 1; i >= max; --i) {
+            closestRecordsUnsorted.remove(i);
+        }
+
+        // now we match perfectly what vanilla would have outputted, without having to search the whole radius (hopefully).
+        ret.addAll(closestRecordsUnsorted);
+    }
+
+    public static BlockPosition findAnyPoiPosition(final VillagePlace poiStorage,
+                                                   final Predicate<VillagePlaceType> villagePlaceType,
+                                                   final Predicate<BlockPosition> positionPredicate,
+                                                   final BlockPosition sourcePosition,
+                                                   final int range, // distance on x y z axis
+                                                   final VillagePlace.Occupancy occupancy,
+                                                   final boolean load) {
+        final VillagePlaceRecord ret = findAnyPoiRecord(
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, occupancy, load
+        );
+
+        return ret == null ? null : ret.getPosition();
+    }
+
+    public static void findAnyPoiPositions(final VillagePlace poiStorage,
+                                           final Predicate<VillagePlaceType> villagePlaceType,
+                                           final Predicate<BlockPosition> positionPredicate,
+                                           final BlockPosition sourcePosition,
+                                           final int range, // distance on x y z axis
+                                           final VillagePlace.Occupancy occupancy,
+                                           final boolean load,
+                                           final int max,
+                                           final List<BlockPosition> ret) {
+        final Set<BlockPosition> positions = new HashSet<>();
+        // pos predicate is last thing that runs before adding to ret.
+        final Predicate<BlockPosition> newPredicate = (final BlockPosition pos) -> {
+            if (positionPredicate != null && !positionPredicate.test(pos)) {
+                return false;
+            }
+            return positions.add(pos.immutableCopy());
+        };
+
+        final List<VillagePlaceRecord> toConvert = new ArrayList<>();
+        findAnyPoiRecords(
+                poiStorage, villagePlaceType, newPredicate, sourcePosition, range, occupancy, load, max, toConvert
+        );
+
+        for (final VillagePlaceRecord record : toConvert) {
+            ret.add(record.getPosition());
+        }
+    }
+
+    public static VillagePlaceRecord findAnyPoiRecord(final VillagePlace poiStorage,
+                                                      final Predicate<VillagePlaceType> villagePlaceType,
+                                                      final Predicate<BlockPosition> positionPredicate,
+                                                      final BlockPosition sourcePosition,
+                                                      final int range, // distance on x y z axis
+                                                      final VillagePlace.Occupancy occupancy,
+                                                      final boolean load) {
+        final List<VillagePlaceRecord> ret = new ArrayList<>();
+        findAnyPoiRecords(poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, occupancy, load, 1, ret);
+        return ret.isEmpty() ? null : ret.get(0);
+    }
+
+    public static void findAnyPoiRecords(final VillagePlace poiStorage,
+                                         final Predicate<VillagePlaceType> villagePlaceType,
+                                         final Predicate<BlockPosition> positionPredicate,
+                                         final BlockPosition sourcePosition,
+                                         final int range, // distance on x y z axis
+                                         final VillagePlace.Occupancy occupancy,
+                                         final boolean load,
+                                         final int max,
+                                         final List<VillagePlaceRecord> ret) {
+        // the biggest issue with the original mojang implementation is that they chain so many streams together
+        // the amount of streams chained just rolls performance, even if nothing is iterated over
+        final Predicate<? super VillagePlaceRecord> occupancyFilter = occupancy.getPredicate();
+        final double rangeSquared = range * range;
+
+        int added = 0;
+
+        // First up, we need to iterate the chunks
+        // all the values here are in chunk sections
+        final int lowerX = MathHelper.floor(sourcePosition.getX() - range) >> 4;
+        final int lowerY = Math.max(0, MathHelper.floor(sourcePosition.getY() - range) >> 4);
+        final int lowerZ = MathHelper.floor(sourcePosition.getZ() - range) >> 4;
+        final int upperX = MathHelper.floor(sourcePosition.getX() + range) >> 4;
+        final int upperY = Math.min(15, MathHelper.floor(sourcePosition.getY() + range) >> 4);
+        final int upperZ = MathHelper.floor(sourcePosition.getZ() + range) >> 4;
+
+        // Vanilla iterates by x until max is reached then increases z
+        // vanilla also searches by increasing Y section value
+        for (int currZ = lowerZ; currZ <= upperZ; ++currZ) {
+            for (int currX = lowerX; currX <= upperX; ++currX) {
+                for (int currY = lowerY; currY <= upperY; ++currY) { // vanilla searches the entire chunk because they're actually stupid. just search the sections we need
+                    final Optional<VillagePlaceSection> poiSectionOptional = load ? poiStorage.getOrLoad(SectionPosition.asLong(currX, currY, currZ)) :
+                            poiStorage.getIfLoaded(SectionPosition.asLong(currX, currY, currZ));
+                    final VillagePlaceSection poiSection = poiSectionOptional == null ? null : poiSectionOptional.orElse(null);
+                    if (poiSection == null) {
+                        continue;
+                    }
+
+                    final Map<VillagePlaceType, Set<VillagePlaceRecord>> sectionData = poiSection.getData();
+                    if (sectionData.isEmpty()) {
+                        continue;
+                    }
+
+                    // now we search the section data
+                    for (final Map.Entry<VillagePlaceType, Set<VillagePlaceRecord>> entry : sectionData.entrySet()) {
+                        if (!villagePlaceType.test(entry.getKey())) {
+                            // filter out by poi type
+                            continue;
+                        }
+
+                        // now we can look at the poi data
+                        for (final VillagePlaceRecord poiData : entry.getValue()) {
+                            if (!occupancyFilter.test(poiData)) {
+                                // filter by occupancy
+                                continue;
+                            }
+
+                            // vanilla code is pretty dumb about filtering by distance: first they filter out
+                            // so that only values in the square radius of range are returned but then they
+                            // filter out so that the distance is in range
+                            // but there's a catch! distanceSquared, by default, will ADD 0.5 to ONLY ONE OF the
+                            // block position parameters (itself, in this case the poi position)! So if we want to
+                            // maintain exact vanilla behaviour, well shit we need to play dumb as well.
+
+                            final BlockPosition poiPosition = poiData.getPosition();
+
+                            if (Math.abs(poiPosition.getX() - sourcePosition.getX()) > range
+                                    || Math.abs(poiPosition.getZ() - sourcePosition.getZ()) > range) {
+                                // out of range for square radius
+                                continue;
+                            }
+
+                            if (poiPosition.distanceSquared(sourcePosition) > rangeSquared) {
+                                // out of range for distance check
+                                continue;
+                            }
+
+                            if (positionPredicate != null && !positionPredicate.test(poiPosition)) {
+                                // filter by position
+                                continue;
+                            }
+
+                            // found one!
+                            ret.add(poiData);
+                            if (++added >= max) {
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private PoiAccess() {
+        throw new RuntimeException();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PortalTravelAgent.java b/src/main/java/net/minecraft/server/PortalTravelAgent.java
index e10995ec30dd9a10d781b3c1709fd2db5a9becdd..77aa805267497f91231d63067d62ad3f10508216 100644
--- a/src/main/java/net/minecraft/server/PortalTravelAgent.java
+++ b/src/main/java/net/minecraft/server/PortalTravelAgent.java
@@ -22,16 +22,34 @@ public class PortalTravelAgent {
         // int i = flag ? 16 : 128;
         // CraftBukkit end
 
-        villageplace.a(this.world, blockposition, i);
-        Optional<VillagePlaceRecord> optional = villageplace.b((villageplacetype) -> {
-            return villageplacetype == VillagePlaceType.v;
-        }, blockposition, i, VillagePlace.Occupancy.ANY).sorted(Comparator.comparingDouble((VillagePlaceRecord villageplacerecord) -> { // CraftBukkit - decompile error
-            return villageplacerecord.f().j(blockposition);
-        }).thenComparingInt((villageplacerecord) -> {
-            return villageplacerecord.f().getY();
-        })).filter((villageplacerecord) -> {
-            return this.world.getType(villageplacerecord.f()).b(BlockProperties.E);
-        }).findFirst();
+        // Tuinity start - optimise portals
+        //villageplace.a(this.world, blockposition, i);
+        Optional<VillagePlaceRecord> optional;
+        java.util.List<VillagePlaceRecord> records = new java.util.ArrayList<>();
+        com.tuinity.tuinity.util.PoiAccess.findClosestPoiDataRecords(villageplace,
+                (VillagePlaceType villageplacetype) -> {
+                    return villageplacetype == VillagePlaceType.v; // this should break this entire diff on update if it changes, so TODO check that on diff break
+                },
+                (BlockPosition pos) -> {
+                    IChunkAccess lowest = this.world.getChunkAt(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.EMPTY);
+                    if (!lowest.getChunkStatus().isAtLeastStatus(ChunkStatus.FULL)) {
+                        // why would we generate the chunk?
+                        return false;
+                    }
+                    return lowest.getType(pos).contains(BlockProperties.E); // this should break this entire diff on update if it changes, so TODO check that on diff break
+                }, blockposition, i, Double.MAX_VALUE, VillagePlace.Occupancy.ANY, true, records);
+        // this gets us most of the way there, but we bias towards lower y values.
+        VillagePlaceRecord lowestYRecord = null;
+        for (VillagePlaceRecord record : records) {
+            if (lowestYRecord == null) {
+                lowestYRecord = record;
+            } else if (lowestYRecord.getPosition().getY() > record.getPosition().getY()) {
+                lowestYRecord = record;
+            }
+        }
+        // now we're done
+        optional = Optional.ofNullable(lowestYRecord);
+        // Tuinity end - optimise portals
 
         return optional.map((villageplacerecord) -> {
             BlockPosition blockposition1 = villageplacerecord.f();
diff --git a/src/main/java/net/minecraft/server/RegionFileSection.java b/src/main/java/net/minecraft/server/RegionFileSection.java
index 79a11d17a2822b192dec5981d0344ae689c3d385..d1ea47654db190e7cb7fa4ec1ac002f64277cb47 100644
--- a/src/main/java/net/minecraft/server/RegionFileSection.java
+++ b/src/main/java/net/minecraft/server/RegionFileSection.java
@@ -84,11 +84,12 @@ public class RegionFileSection<R> extends RegionFileCache implements AutoCloseab
     }
     // Tuinity end - actually unload POI data
 
-    @Nullable protected Optional<R> getIfLoaded(long value) { return this.c(value); } // Tuinity - OBFHELPER
+    @Nullable public final Optional<R> getIfLoaded(long value) { return this.c(value); } // Tuinity - OBFHELPER // Tuinity - OBFHELPER
     @Nullable protected Optional<R> c(long i) { // Tuinity - OBFHELPER
         return (Optional) this.c.get(i);
     }
 
+    public final Optional<R> getOrLoad(long coordinate) { return this.d(coordinate); } // Tuinity - OBFHELPER
     protected Optional<R> d(long i) {
         SectionPosition sectionposition = SectionPosition.a(i);
 
