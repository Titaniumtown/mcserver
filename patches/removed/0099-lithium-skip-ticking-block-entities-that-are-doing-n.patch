From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Sun, 21 Feb 2021 21:34:18 -0500
Subject: [PATCH] lithium: skip ticking block entities that are doing nothing


diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/FilterableLinkedHashSetList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/FilterableLinkedHashSetList.java
new file mode 100644
index 0000000000000000000000000000000000000000..9bf926070a237a74bdc2c171fac85083910a937d
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/FilterableLinkedHashSetList.java
@@ -0,0 +1,211 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.longs.Long2ReferenceAVLTreeMap;
+import it.unimi.dsi.fastutil.objects.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+
+public class FilterableLinkedHashSetList<T> implements List<T> {
+    private final Reference2LongLinkedOpenHashMap<T> delegate;
+    private final Long2ReferenceAVLTreeMap<T> filtered;
+    private long index;
+
+    public FilterableLinkedHashSetList(List<T> list) {
+        this.index = -1;
+        this.delegate = new Reference2LongLinkedOpenHashMap<>();
+        this.delegate.defaultReturnValue(-1);
+        this.filtered = new Long2ReferenceAVLTreeMap<>();
+        for (T t : list) {
+            long l = this.nextIndex();
+            this.delegate.put(t, l);
+            this.filtered.put(l, t);
+        }
+    }
+
+    private long nextIndex() {
+        long l = ++this.index;
+        if (l < 0) {
+            this.reinitialize();
+            //this.index cannot go anywhere near overflow inside reinitialize, because it is long, while the elements are addressed with integers.
+            l = ++this.index;
+        }
+        return l;
+    }
+
+    private void reinitialize() {
+        Reference2BooleanArrayMap<T> tmp = new Reference2BooleanArrayMap<>();
+        for (Reference2LongMap.Entry<T> entry : this.delegate.reference2LongEntrySet()) {
+            tmp.put(entry.getKey(), this.filtered.containsKey(entry.getLongValue()));
+        }
+
+        this.index = -1;
+        this.filtered.clear();
+        this.delegate.clear();
+        for (ObjectIterator<Reference2BooleanMap.Entry<T>> iterator = tmp.reference2BooleanEntrySet().fastIterator(); iterator.hasNext(); ) {
+            Reference2BooleanMap.Entry<T> entry = iterator.next();
+            long l = ++this.index;
+            T key = entry.getKey();
+            this.delegate.put(key, l);
+            if (entry.getBooleanValue()) {
+                this.filtered.put(l, key);
+            }
+        }
+    }
+
+    public void setEntryVisible(T t, boolean value) {
+        long index = this.delegate.getLong(t);
+        if (index != -1) {
+            if (value) {
+                this.filtered.put(index, t);
+            } else {
+                this.filtered.remove(index);
+            }
+        }
+    }
+
+    public Iterator<T> filteredIterator() {
+        return this.filtered.values().iterator();
+    }
+
+    @Override
+    public int size() {
+        return this.delegate.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.delegate.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        //noinspection SuspiciousMethodCalls
+        return this.delegate.containsKey(o);
+    }
+
+    @Override
+    public @NotNull Iterator<T> iterator() {
+        return this.delegate.keySet().iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.delegate.keySet().toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T1> T1[] toArray(@NotNull T1[] t1s) {
+        //noinspection SuspiciousToArrayCall
+        return this.delegate.keySet().toArray(t1s);
+    }
+
+    @Override
+    public boolean add(T t) {
+        long l = this.nextIndex();
+        this.delegate.put(t, l);
+        this.filtered.put(l, t);
+        return true;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        long l = this.delegate.removeLong(o);
+        if (l != -1) {
+            this.filtered.remove(l);
+        }
+        return l != 0;
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> c) {
+        return this.delegate.keySet().containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends T> c) {
+        boolean b = false;
+        for (T t : c) {
+            long l = this.nextIndex();
+            this.delegate.put(t, l);
+            this.filtered.put(l, t);
+            b = true;
+        }
+        return b;
+    }
+
+    @Override
+    public boolean addAll(int index, @NotNull Collection<? extends T> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> c) {
+        boolean b = false;
+        for (Object t : c) {
+            long l = this.delegate.removeLong(t);
+            if (l != -1) {
+                this.filtered.remove(l);
+            }
+            b = true;
+        }
+        return b;
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        this.delegate.clear();
+        this.filtered.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public T set(int index, T element) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void add(int index, T element) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public T remove(int index) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull ListIterator<T> listIterator() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull ListIterator<T> listIterator(int index) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull List<T> subList(int fromIndex, int toIndex) {
+        throw new UnsupportedOperationException();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/ListeningList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/ListeningList.java
new file mode 100644
index 0000000000000000000000000000000000000000..edcc9ec27cc7d8dc5bf04e1f70362b505742570c
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/ListeningList.java
@@ -0,0 +1,255 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
+
+public class ListeningList<T> implements List<T> {
+    private final List<T> delegate;
+    private final Runnable changeCallback;
+
+    public ListeningList(List<T> delegate, Runnable changeCallback) {
+        this.delegate = delegate;
+        this.changeCallback = changeCallback;
+    }
+
+    private void onChange() {
+        this.changeCallback.run();
+    }
+
+
+    @Override
+    public int size() {
+        return this.delegate.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.delegate.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.delegate.contains(o);
+    }
+
+    @NotNull
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return this.delegate.toArray();
+    }
+
+    @Override
+    public void forEach(Consumer<? super T> consumer) {
+        this.delegate.forEach(consumer);
+    }
+
+    @NotNull
+    @Override
+    public <T1> T1[] toArray(@NotNull T1[] t1s) {
+        //noinspection SuspiciousToArrayCall
+        return this.delegate.toArray(t1s);
+    }
+
+    @Override
+    public boolean add(T t) {
+        boolean add = this.delegate.add(t);
+        this.onChange();
+        //noinspection ConstantConditions
+        return add;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        boolean remove = this.delegate.remove(o);
+        this.onChange();
+        return remove;
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        return this.delegate.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends T> collection) {
+        boolean addAll = this.delegate.addAll(collection);
+        this.onChange();
+        return addAll;
+    }
+
+    @Override
+    public boolean addAll(int i, @NotNull Collection<? extends T> collection) {
+        boolean addAll = this.delegate.addAll(i, collection);
+        this.onChange();
+        return addAll;
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        boolean b = this.delegate.removeAll(collection);
+        this.onChange();
+        return b;
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super T> predicate) {
+        boolean b = this.delegate.removeIf(predicate);
+        this.onChange();
+        return b;
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        boolean b = this.delegate.retainAll(collection);
+        this.onChange();
+        return b;
+    }
+
+    @Override
+    public void replaceAll(UnaryOperator<T> unaryOperator) {
+        this.delegate.replaceAll( unaryOperator);
+        this.onChange();
+    }
+
+    @Override
+    public void sort(Comparator<? super T> comparator) {
+        this.delegate.sort(comparator);
+        this.onChange();
+    }
+
+    @Override
+    public void clear() {
+        this.delegate.clear();
+        this.onChange();
+    }
+
+    @Override
+    public T get(int i) {
+        return this.delegate.get(i);
+    }
+
+    @Override
+    public T set(int i, T t) {
+        T set = this.delegate.set(i, t);
+        this.onChange();
+        return set;
+    }
+
+    @Override
+    public void add(int i, T t) {
+        this.delegate.add(i, t);
+        this.onChange();
+    }
+
+    @Override
+    public T remove(int i) {
+        T remove = this.delegate.remove(i);
+        this.onChange();
+        return remove;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.delegate.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.delegate.lastIndexOf(o);
+    }
+
+    @NotNull
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @NotNull
+    @Override
+    public ListIterator<T> listIterator(int i) {
+        return new ListIterator<T>() {
+            final ListIterator<T> itDelegate = ListeningList.this.delegate.listIterator(i);
+
+            @Override
+            public boolean hasNext() {
+                return this.itDelegate.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.itDelegate.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.itDelegate.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.itDelegate.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.itDelegate.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.itDelegate.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                this.itDelegate.remove();
+                ListeningList.this.onChange();
+            }
+
+            @Override
+            public void set(T t) {
+                this.itDelegate.set(t);
+                ListeningList.this.onChange();
+
+            }
+
+            @Override
+            public void add(T t) {
+                this.itDelegate.add(t);
+                ListeningList.this.onChange();
+            }
+        };
+    }
+
+    @NotNull
+    @Override
+    public List<T> subList(int i, int i1) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Spliterator<T> spliterator() {
+        return this.delegate.spliterator();
+    }
+
+    @Override
+    public Stream<T> stream() {
+        return this.delegate.stream();
+    }
+
+    @Override
+    public Stream<T> parallelStream() {
+        return this.delegate.parallelStream();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/world/blockentity/BlockEntitySleepTracker.java b/src/main/java/me/jellysquid/mods/lithium/common/world/blockentity/BlockEntitySleepTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..3dc6e8a5be8b8020b65cdc46fcc24bbf25271402
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/world/blockentity/BlockEntitySleepTracker.java
@@ -0,0 +1,7 @@
+package me.jellysquid.mods.lithium.common.world.blockentity;
+
+import net.minecraft.block.entity.BlockEntity;
+
+public interface BlockEntitySleepTracker {
+    void setAwake(BlockEntity blockEntity, boolean needsTicking);
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/TileEntityBeehive.java b/src/main/java/net/minecraft/server/TileEntityBeehive.java
index 69ef94e887fa9da1b3ddaf0a345fecc49d2866b5..982f20b6991405b1f6bf85251b6960c274f6262e 100644
--- a/src/main/java/net/minecraft/server/TileEntityBeehive.java
+++ b/src/main/java/net/minecraft/server/TileEntityBeehive.java
@@ -4,6 +4,8 @@ import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
+import me.jellysquid.mods.lithium.common.util.collections.ListeningList;
+import me.jellysquid.mods.lithium.common.world.blockentity.BlockEntitySleepTracker;
 
 public class TileEntityBeehive extends TileEntity implements ITickable {
 
@@ -11,11 +13,31 @@ public class TileEntityBeehive extends TileEntity implements ITickable {
     @Nullable
     public BlockPosition flowerPos = null;
     public int maxBees = 3; // CraftBukkit - allow setting max amount of bees a hive can hold
+    private boolean doInit;
+    private boolean isTicking;
+    private List<?> bees;
+
 
     public TileEntityBeehive() {
         super(TileEntityTypes.BEEHIVE);
     }
 
+    private void checkSleepState() {
+        if (this.world != null ) {
+            if (this.world.isClient()) {
+                // in the initializer we can't know whether we are in a client world
+                this.bees = new ArrayList<>(this.bees);
+                ((BlockEntitySleepTracker)this.world).setAwake(this, this.isTicking = false);
+                return;
+            }
+            if ((this.bees.size() == 0) == this.isTicking) {
+                this.isTicking = !this.isTicking;
+                ((BlockEntitySleepTracker)this.world).setAwake(this, this.isTicking);
+            }
+        }
+
+    }
+
     @Override
     public void update() {
         if (this.d()) {
@@ -23,6 +45,7 @@ public class TileEntityBeehive extends TileEntity implements ITickable {
         }
 
         super.update();
+        this.checkSleepState();
     }
 
     public boolean d() {
@@ -285,6 +308,10 @@ public class TileEntityBeehive extends TileEntity implements ITickable {
 
     @Override
     public void tick() {
+        if (this.doInit) {
+            this.doInit = false;
+            this.checkSleepState();
+        }
         if (this.bees.size() == 0) { return; } // Yatopia - TE optimizations
         if (!this.world.isClientSide) {
             this.y();
@@ -369,6 +396,9 @@ public class TileEntityBeehive extends TileEntity implements ITickable {
             this.entityData = nbttagcompound;
             this.ticksInHive = i;
             this.minOccupationTicks = j;
+            this.bees = new ListeningList<>(this.bees, this::checkSleepState);
+            this.doInit = true;
+            this.isTicking = true;
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/TileEntityBell.java b/src/main/java/net/minecraft/server/TileEntityBell.java
index 6963f3c8a0e257615084b558f5ce287aab9722ff..d605bec2c7c14a7d8217863f0be9b662c27adad8 100644
--- a/src/main/java/net/minecraft/server/TileEntityBell.java
+++ b/src/main/java/net/minecraft/server/TileEntityBell.java
@@ -13,6 +13,8 @@ public class TileEntityBell extends TileEntity implements ITickable {
     private List<EntityLiving> h; private List<EntityLiving> getEntitiesAtRing() { return this.h; } // Paper - OBFHELPER
     private boolean i; private boolean getShouldReveal() { return this.i; } // Paper - OBFHELPER
     private int j;
+    public boolean ringing;
+    private boolean resonating;
 
     public TileEntityBell() {
         super(TileEntityTypes.BELL);
@@ -20,6 +22,9 @@ public class TileEntityBell extends TileEntity implements ITickable {
 
     @Override
     public boolean setProperty(int i, int j) {
+       if (!this.ringing && type == 1 && this.world != null) {
+            ((BlockEntitySleepTracker)this.world).setAwake(this, true);
+        }
         if (i == 1) {
             this.f();
             this.j = 0;
@@ -64,6 +69,9 @@ public class TileEntityBell extends TileEntity implements ITickable {
             }
         }
 
+        if (!this.ringing && !this.resonating && this.world != null) {
+            ((BlockEntitySleepTracker)this.world).setAwake(this, false);
+        }
     }
 
     private void d() {
@@ -71,6 +79,9 @@ public class TileEntityBell extends TileEntity implements ITickable {
     }
 
     public void a(EnumDirection enumdirection) {
+        if (!this.ringing && this.world != null) {
+            ((BlockEntitySleepTracker)this.world).setAwake(this, true);
+        }
         BlockPosition blockposition = this.getPosition();
 
         this.c = enumdirection;
diff --git a/src/main/java/net/minecraft/server/TileEntityBrewingStand.java b/src/main/java/net/minecraft/server/TileEntityBrewingStand.java
index caee4f612238ee7112ed2f29e954cfe3b74a558e..23988149b4fa726fd84678e7ccb2252bb45a1e5b 100644
--- a/src/main/java/net/minecraft/server/TileEntityBrewingStand.java
+++ b/src/main/java/net/minecraft/server/TileEntityBrewingStand.java
@@ -29,6 +29,7 @@ public class TileEntityBrewingStand extends TileEntityContainer implements IWorl
     private int lastTick = MinecraftServer.currentTick;
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
     private int maxStack = 64;
+    private int brewTime;
 
     public void onOpen(CraftHumanEntity who) {
         transaction.add(who);
@@ -120,6 +121,10 @@ public class TileEntityBrewingStand extends TileEntityContainer implements IWorl
 
     @Override
     public void tick() {
+        if (this.brewTime == 0 && this.world != null) {
+            this.isTicking = false;
+            ((BlockEntitySleepTracker)this.world).setAwake(this, false);
+        }
         ItemStack itemstack = (ItemStack) this.items.get(4);
 
         if (this.fuelLevel <= 0 && itemstack.getItem() == Items.BLAZE_POWDER) {
diff --git a/src/main/java/net/minecraft/server/TileEntityFurnace.java b/src/main/java/net/minecraft/server/TileEntityFurnace.java
index c1d1ce582c94fd20f42b1979d6edbb6b377adff8..6ae733444371b8e23415c7cb3f11afa631b51ae0 100644
--- a/src/main/java/net/minecraft/server/TileEntityFurnace.java
+++ b/src/main/java/net/minecraft/server/TileEntityFurnace.java
@@ -21,9 +21,11 @@ import org.bukkit.event.inventory.FurnaceBurnEvent;
 import org.bukkit.event.inventory.FurnaceExtractEvent;
 import org.bukkit.event.inventory.FurnaceSmeltEvent;
 // CraftBukkit end
+import me.jellysquid.mods.lithium.common.world.blockentity.BlockEntitySleepTracker;
 
 public abstract class TileEntityFurnace extends TileEntityContainer implements IWorldInventory, RecipeHolder, AutoRecipeOutput, ITickable {
 
+    private boolean isTicking = true;
     private static final int[] g = new int[]{0};
     private static final int[] h = new int[]{2, 1};
     private static final int[] i = new int[]{1};
@@ -165,6 +167,15 @@ public abstract class TileEntityFurnace extends TileEntityContainer implements I
     private int maxStack = MAX_STACK;
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
 
+    @Override
+    public void markDirty() {
+        super.markDirty();
+        if (!this.isTicking && this.world != null) {
+            this.isTicking = true;
+            ((BlockEntitySleepTracker)this.world).setAwake(this, true);
+        }
+    }
+
     public List<ItemStack> getContents() {
         return this.items;
     }
@@ -247,6 +258,10 @@ public abstract class TileEntityFurnace extends TileEntityContainer implements I
             this.cookSpeedMultiplier = nbttagcompound.getDouble("Paper.CookSpeedMultiplier");
         }
         // Paper end
+        if (!this.isTicking && this.world != null) {
+            this.isTicking = true;
+            ((BlockEntitySleepTracker)this.world).setAwake(this, true);
+        }
     }
 
     @Override
@@ -357,7 +372,10 @@ public abstract class TileEntityFurnace extends TileEntityContainer implements I
         if (flag1) {
             this.update();
         }
-
+        if (!this.isTicking && this.world != null) {
+            this.isTicking = true;
+            ((BlockEntitySleepTracker)this.world).setAwake(this, true);
+        }
     }
 
     protected boolean canBurn(@Nullable IRecipe<?> irecipe) {
