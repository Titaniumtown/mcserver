From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Fri, 8 Jan 2021 00:46:36 -0500
Subject: [PATCH] tic-tacs


diff --git a/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java b/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..3419469e14da10ab6892de4824dee6408c8b7896
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java
@@ -0,0 +1,20 @@
+package net.gegy1000.tictacs;
+
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface AsyncChunkAccess {
+    Chunk getExistingChunk(int x, int z, ChunkStep step);
+
+    Chunk getAnyExistingChunk(int x, int z);
+
+    CompletableFuture<Chunk> getOrCreateChunkAsync(int x, int z, ChunkStep step);
+
+    boolean shouldChunkExist(int x, int z, ChunkStep step);
+
+    default boolean shouldChunkExist(int x, int z) {
+        return this.shouldChunkExist(x, z, ChunkStep.FULL);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java b/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java
new file mode 100644
index 0000000000000000000000000000000000000000..5fab1c1f9b59a0e9f3a709bd79a342814fae3183
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java
@@ -0,0 +1,10 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.util.math.ChunkPos;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface AsyncChunkIo {
+    CompletableFuture<CompoundTag> getNbtAsync(ChunkPos pos);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java b/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java
new file mode 100644
index 0000000000000000000000000000000000000000..43017f3272d941863f55e75a8dbd58798cbd94f8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java
@@ -0,0 +1,10 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.util.math.ChunkPos;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+
+public interface AsyncRegionStorageIo {
+    CompletableFuture<Void> loadDataAtAsync(ChunkPos pos, Executor mainThreadExecutor);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/AtomicPool.java b/src/main/java/net/gegy1000/tictacs/AtomicPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..17a0493ee0b2e1aa07e432e7c857757618b09a37
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AtomicPool.java
@@ -0,0 +1,57 @@
+package net.gegy1000.tictacs;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.Supplier;
+
+public final class AtomicPool<T> {
+    private final int capacity;
+
+    private final AtomicReferenceArray<T> array;
+    private final AtomicInteger pointer = new AtomicInteger(-1);
+
+    private final Supplier<T> supplier;
+
+    public AtomicPool(int capacity, Supplier<T> supplier) {
+        this.capacity = capacity;
+        this.array = new AtomicReferenceArray<>(capacity);
+        this.supplier = supplier;
+    }
+
+    public T acquire() {
+        while (true) {
+            int pointer = this.pointer.get();
+
+            // we've fallen outside the pool: allocate a new entry
+            if (pointer < 0) {
+                return this.supplier.get();
+            }
+
+            if (this.pointer.compareAndSet(pointer, pointer - 1)) {
+                T value = this.array.getAndSet(pointer, null);
+                if (value == null) {
+                    // this value hasn't been set yet: try again
+                    continue;
+                }
+                return value;
+            }
+        }
+    }
+
+    public void release(T object) {
+        while (true) {
+            int pointer = this.pointer.get();
+            int newPointer = pointer + 1;
+
+            // the pool is full, we don't need to return this object
+            if (newPointer >= this.capacity) {
+                return;
+            }
+
+            if (this.pointer.compareAndSet(pointer, newPointer)) {
+                this.array.set(newPointer, object);
+                return;
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java b/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..50e3d7f4ec3ef79651cab001fe87debc3964b7fc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.block.BlockState;
+import net.minecraft.block.Blocks;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.fluid.Fluids;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.WorldView;
+
+public interface NonBlockingWorldAccess extends WorldView {
+    default BlockState getBlockStateIfLoaded(BlockPos pos) {
+        if (this.isChunkLoaded(pos)) {
+            return this.getBlockState(pos);
+        }
+        return Blocks.AIR.getDefaultState();
+    }
+
+    default FluidState getFluidStateIfLoaded(BlockPos pos) {
+        if (this.isChunkLoaded(pos)) {
+            return this.getFluidState(pos);
+        }
+        return Fluids.EMPTY.getDefaultState();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java b/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e86c6c86afd2fd2d30c298fd23e15bc87109b4a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java
@@ -0,0 +1,104 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.util.thread.TaskExecutor;
+import net.minecraft.util.thread.TaskQueue;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class OwnThreadActor<T> extends TaskExecutor<T> {
+    private static final Logger LOGGER = LogManager.getLogger(OwnThreadActor.class);
+    private static final Map<String, OwnThreadActor<Runnable>> ACTORS = new HashMap<>();
+
+    private final Object lock = new Object();
+
+    private final AtomicInteger refCount = new AtomicInteger();
+    private volatile boolean active = true;
+
+    private OwnThreadActor(TaskQueue<? super T, ? extends Runnable> queue, String name) {
+        super(queue, task -> {}, name);
+    }
+
+    public static OwnThreadActor<Runnable> create(String name) {
+        OwnThreadActor<Runnable> actor;
+        synchronized (ACTORS) {
+            // merge actors by the same name
+            actor = ACTORS.computeIfAbsent(name, OwnThreadActor::startActor);
+        }
+
+        actor.acquireRef();
+
+        return actor;
+    }
+
+    private static OwnThreadActor<Runnable> startActor(String name) {
+        TaskQueue.Simple<Runnable> queue = new TaskQueue.Simple<>(new ArrayDeque<>());
+        OwnThreadActor<Runnable> actor = new OwnThreadActor<>(queue, name);
+
+        Thread thread = new Thread(actor);
+        thread.setName(name + "-actor");
+        thread.setDaemon(true);
+        thread.start();
+
+        return actor;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (this.active) {
+                Runnable task;
+                synchronized (this.lock) {
+                    while ((task = this.queue.poll()) == null) {
+                        if (!this.active) return;
+                        this.lock.wait();
+                    }
+                }
+
+                task.run();
+            }
+        } catch (InterruptedException e) {
+            LOGGER.error("Actor thread interrupted", e);
+        }
+    }
+
+    @Override
+    public void send(T message) {
+        synchronized (this.lock) {
+            this.queue.add(message);
+            this.lock.notify();
+        }
+    }
+
+    private void acquireRef() {
+        this.refCount.getAndIncrement();
+    }
+
+    private boolean releaseRef() {
+        return this.refCount.decrementAndGet() <= 0;
+    }
+
+    private void stop() {
+        synchronized (this.lock) {
+            this.active = false;
+            this.lock.notify();
+        }
+
+        synchronized (ACTORS) {
+            ACTORS.remove(this.getName());
+        }
+    }
+
+    @Override
+    public void close() {
+        super.close();
+
+        if (this.releaseRef()) {
+            this.stop();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java b/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..162b0f355e4317222bac25602f5c1bd97467503f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java
@@ -0,0 +1,8 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkSection;
+
+public interface PoiStorageAccess {
+    void initSectionWithPois(ChunkPos pos, ChunkSection section);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/QueuingConnection.java b/src/main/java/net/gegy1000/tictacs/QueuingConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..31e62a66f441e4702add483e20a360bcb14d95a1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/QueuingConnection.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.ServerPlayNetworkHandler;
+
+import org.jetbrains.annotations.Nullable;
+
+public interface QueuingConnection {
+    static void enqueueSend(ServerPlayNetworkHandler network, Packet<?> packet) {
+        ((QueuingConnection) network).enqueueSend(packet);
+    }
+
+    static void enqueueSend(ServerPlayNetworkHandler network, Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+        ((QueuingConnection) network).enqueueSend(packet, callback);
+    }
+
+    default void enqueueSend(Packet<?> packet) {
+        this.enqueueSend(packet, null);
+    }
+
+    void enqueueSend(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/TicTacs.java b/src/main/java/net/gegy1000/tictacs/TicTacs.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a1ca21191fb1cc204ce38bf50d93d36cc0ec40a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/TicTacs.java
@@ -0,0 +1,28 @@
+package net.gegy1000.tictacs;
+
+import com.google.common.reflect.Reflection;
+import net.fabricmc.api.ModInitializer;
+import net.fabricmc.loader.api.FabricLoader;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgradeFuture;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import net.minecraft.util.Identifier;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class TicTacs implements ModInitializer {
+    public static final String ID = "tic_tacs";
+    public static final Logger LOGGER = LogManager.getLogger(ID);
+
+    public static final Identifier DEBUG_CHUNK_TICKETS = new Identifier(ID, "debug_chunk_tickets");
+
+    public static final boolean DEBUG = FabricLoader.getInstance().isDevelopmentEnvironment();
+
+    @Override
+    public void onInitialize() {
+        TicTacsConfig.get();
+
+        // due to a classloader bug in multithreaded environments, we need to load the class before multiple threads
+        // try to load it concurrently
+        Reflection.initialize(ChunkUpgradeFuture.class);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/TicTacsClient.java b/src/main/java/net/gegy1000/tictacs/TicTacsClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f1a67140f754fd0422e10060ae161f87222d4c6
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/TicTacsClient.java
@@ -0,0 +1,22 @@
+package net.gegy1000.tictacs;
+
+import net.fabricmc.api.ClientModInitializer;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.api.Environment;
+import net.fabricmc.fabric.api.network.ClientSidePacketRegistry;
+import net.gegy1000.tictacs.client.TicTacsDebugLevelTracker;
+
+@Environment(EnvType.CLIENT)
+public class TicTacsClient implements ClientModInitializer {
+    @Override
+    public void onInitializeClient() {
+        ClientSidePacketRegistry.INSTANCE.register(TicTacs.DEBUG_CHUNK_TICKETS, (packetContext, data) -> {
+            long chunkPos = data.readLong();
+            int toLevel = data.readInt();
+
+            packetContext.getTaskQueue().execute(() -> {
+                TicTacsDebugLevelTracker.INSTANCE.setLevel(chunkPos, toLevel);
+            });
+        });
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/VoidActor.java b/src/main/java/net/gegy1000/tictacs/VoidActor.java
new file mode 100644
index 0000000000000000000000000000000000000000..921a6f6fa4e1eb7281e6c2973f24f9c12b86098c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/VoidActor.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs;
+
+import net.minecraft.util.thread.TaskExecutor;
+import net.minecraft.util.thread.TaskQueue;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class VoidActor extends TaskExecutor<Runnable> {
+    public VoidActor(String name) {
+        super(new VoidQueue(), runnable -> {}, name);
+    }
+
+    @Override
+    public void run() {
+    }
+
+    @Override
+    public void send(Runnable message) {
+    }
+
+    @Override
+    public void close() {
+    }
+
+    private static class VoidQueue implements TaskQueue<Runnable, Runnable> {
+        @Nullable
+        @Override
+        public Runnable poll() {
+            return null;
+        }
+
+        @Override
+        public boolean add(Runnable message) {
+            return false;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java b/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java
new file mode 100644
index 0000000000000000000000000000000000000000..51f135848afb01dbb39aea1c46b1187bb5631737
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java
@@ -0,0 +1,83 @@
+package net.gegy1000.tictacs.async;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+import org.jetbrains.annotations.Nullable;
+
+public class LinkedWaiter {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+
+    private static final long WAKER_OFFSET;
+    private static final long NEXT_OFFSET;
+
+    static {
+        try {
+            WAKER_OFFSET = UNSAFE.objectFieldOffset(LinkedWaiter.class.getDeclaredField("waker"));
+            NEXT_OFFSET = UNSAFE.objectFieldOffset(LinkedWaiter.class.getDeclaredField("next"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get waiter field offsets", e);
+        }
+    }
+
+    private volatile Waker waker;
+    private volatile LinkedWaiter next = this.closed();
+
+    final void setWaker(Waker waker) {
+        this.waker = waker;
+    }
+
+    final boolean tryLink(LinkedWaiter next) {
+        return UNSAFE.compareAndSwapObject(this, NEXT_OFFSET, this.open(), next);
+    }
+
+    final boolean tryOpenLink() {
+        return UNSAFE.compareAndSwapObject(this, NEXT_OFFSET, this.closed(), this.open());
+    }
+
+    final void setLink(LinkedWaiter next) {
+        this.next = next;
+    }
+
+    @Nullable
+    final LinkedWaiter unlinkAndClose() {
+        return (LinkedWaiter) UNSAFE.getAndSetObject(this, NEXT_OFFSET, this.closed());
+    }
+
+    void wake() {
+        LinkedWaiter waiter = this;
+        while (waiter != null) {
+            waiter = waiter.wakeSelf();
+        }
+    }
+
+    @Nullable
+    LinkedWaiter wakeSelf() {
+        LinkedWaiter next = this.unlinkAndClose();
+        Waker waker = (Waker) UNSAFE.getAndSetObject(this, WAKER_OFFSET, null);
+
+        if (waker != null) {
+            waker.wake();
+        }
+
+        return next;
+    }
+
+    public final void invalidateWaker() {
+        this.waker = null;
+    }
+
+    final boolean isClosed(LinkedWaiter waiter) {
+        return waiter == this.closed();
+    }
+
+    private LinkedWaiter open() {
+        return null;
+    }
+
+    private LinkedWaiter closed() {
+        return this;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java b/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d86758f83c01c4bda2a9ccb74ba228e43f5e9c9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java
@@ -0,0 +1,101 @@
+package net.gegy1000.tictacs.async;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class WaiterQueue extends LinkedWaiter {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+
+    private static final long TAIL_OFFSET;
+
+    static {
+        try {
+            TAIL_OFFSET = UNSAFE.objectFieldOffset(WaiterQueue.class.getDeclaredField("tail"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get waiter field offsets", e);
+        }
+    }
+
+    private volatile LinkedWaiter tail = this;
+
+    public WaiterQueue() {
+        this.tryOpenLink();
+    }
+
+    public void registerWaiter(LinkedWaiter waiter, Waker waker) {
+        // initialize the waker on the waiter object
+        waiter.setWaker(waker);
+
+        // try to open the link on this waiter object
+        // if this fails, we must be already linked into the queue
+        if (!waiter.tryOpenLink()) {
+            return;
+        }
+
+        while (true) {
+            LinkedWaiter tail = this.tail;
+
+            // by linking the tail, the tail is essentially locked until the tail reference is swapped
+            if (tail.tryLink(waiter)) {
+                // swap the tail reference: if we fail, we must've been woken up already. we can accept
+                // ignoring the error because we know this node is enqueued to be awoken
+                UNSAFE.compareAndSwapObject(this, TAIL_OFFSET, tail, waiter);
+
+                return;
+            }
+        }
+    }
+
+    public void wake(int count) {
+        // unlink the waiter chain from the head
+        LinkedWaiter waiter = this.unlinkAndClose();
+
+        // if the head is closed, we must be in the progress of being woken up. let's not interfere
+        if (this.isClosed(waiter)) {
+            return;
+        }
+
+        if (waiter == null) {
+            this.clearAndOpen();
+            return;
+        }
+
+        for (int i = 0; i < count; i++) {
+            LinkedWaiter nextWaiter = waiter.wakeSelf();
+            if (nextWaiter == null) {
+                // no waiters left: we removed the tail element
+                this.clearAndOpen();
+                return;
+            }
+
+            waiter = nextWaiter;
+        }
+
+        this.setLink(waiter);
+    }
+
+    @Override
+    public void wake() {
+        // unlink the waiter chain from the head
+        LinkedWaiter waiter = this.unlinkAndClose();
+
+        // if the head is closed, we must be in the progress of being woken up. let's not interfere
+        if (this.isClosed(waiter)) {
+            return;
+        }
+
+        this.clearAndOpen();
+
+        if (waiter != null) {
+            waiter.wake();
+        }
+    }
+
+    private void clearAndOpen() {
+        // update the tail reference before opening the link again
+        this.tail = this;
+        this.tryOpenLink();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..d38a1b6f01b557349e3b732a7900c66427542cb3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java
@@ -0,0 +1,79 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+
+public final class JoinLock implements Lock {
+    private final Lock[] locks;
+
+    public JoinLock(Lock... locks) {
+        this.locks = locks;
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        for (int i = 0; i < this.locks.length; i++) {
+            Lock lock = this.locks[i];
+            if (lock != null && !lock.tryAcquire()) {
+                this.releaseUpTo(i);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        for (int i = 0; i < this.locks.length; i++) {
+            Lock lock = this.locks[i];
+            if (lock == null) {
+                continue;
+            }
+
+            PollLock poll = lock.tryPollLock(waiter, waker);
+            if (poll != PollLock.ACQUIRED) {
+                this.releaseUpTo(i);
+                return poll;
+            }
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        for (Lock lock : this.locks) {
+            if (lock != null && !lock.canAcquire()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void release() {
+        for (Lock lock : this.locks) {
+            if (lock != null) {
+                lock.release();
+            }
+        }
+    }
+
+    private void releaseUpTo(int endIndex) {
+        for (int i = 0; i < endIndex; i++) {
+            Lock lock = this.locks[i];
+            if (lock != null) {
+                lock.release();
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        if (this.canAcquire()) {
+            return "JoinLock(FREE)";
+        } else {
+            return "JoinLock(ACQUIRED)";
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java b/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f2698c27aed2065757d731740383c493b170f0f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java
@@ -0,0 +1,53 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+
+import org.jetbrains.annotations.Nullable;
+
+public interface Lock {
+    Future<Unit> READY_FUTURE = Future.ready(Unit.INSTANCE);
+
+    boolean tryAcquire();
+
+    boolean canAcquire();
+
+    void release();
+
+    PollLock tryPollLock(LinkedWaiter waiter, Waker waker);
+
+    default Future<Unit> acquireAsync() {
+        // try acquire now to avoid the allocation: this is technically bad future behaviour, but we'll allow it
+        if (this.tryAcquire()) {
+            return READY_FUTURE;
+        }
+
+        return new AcquireFuture(this);
+    }
+
+    final class AcquireFuture extends LinkedWaiter implements Future<Unit> {
+        final Lock lock;
+
+        public AcquireFuture(Lock lock) {
+            this.lock = lock;
+        }
+
+        @Nullable
+        @Override
+        public Unit poll(Waker waker) {
+            while (true) {
+                // invalidate our waker if it is queued
+                this.invalidateWaker();
+
+                PollLock poll = this.lock.tryPollLock(this, waker);
+                if (poll == PollLock.ACQUIRED) {
+                    return Unit.INSTANCE;
+                } else if (poll == PollLock.PENDING) {
+                    return null;
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java b/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java
new file mode 100644
index 0000000000000000000000000000000000000000..800a5a431288765f9b16919d84b63535e04cf308
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java
@@ -0,0 +1,64 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class Mutex implements Lock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    private static final int FREE = 0;
+    private static final int ACQUIRED = 1;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(Mutex.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get state field offsets", e);
+        }
+    }
+
+    private volatile int state = FREE;
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    @Override
+    public boolean tryAcquire() {
+        return UNSAFE.compareAndSwapInt(this, STATE_OFFSET, FREE, ACQUIRED);
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        if (!this.tryAcquire()) {
+            this.waiters.registerWaiter(waiter, waker);
+            return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return this.state == FREE;
+    }
+
+    @Override
+    public void release() {
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, ACQUIRED, FREE)) {
+            throw new IllegalStateException("lock not acquired");
+        }
+        this.waiters.wake();
+    }
+
+    @Override
+    public String toString() {
+        if (this.canAcquire()) {
+            return "Mutex(FREE)";
+        } else {
+            return "Mutex(ACQUIRED)";
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..374aa5f32a99a576e03f034d641919480d67f03a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java
@@ -0,0 +1,30 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+
+public final class NullLock implements Lock {
+    public static final Lock INSTANCE = new NullLock();
+
+    private NullLock() {
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        return true;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return true;
+    }
+
+    @Override
+    public void release() {
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        return PollLock.ACQUIRED;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3581c5460b1d2cd564324bb539126c23046eeb3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java
@@ -0,0 +1,7 @@
+package net.gegy1000.tictacs.async.lock;
+
+public enum PollLock {
+    PENDING,
+    ACQUIRED,
+    RETRY
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6303872a1f052401210cc19602238192b74faa3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java
@@ -0,0 +1,167 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class RwLock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(RwLock.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get state field offsets", e);
+        }
+    }
+
+    private static final int FREE = 0;
+    private static final int WRITING = -1;
+
+    private final Read read = new Read();
+    private final Write write = new Write();
+
+    private volatile int state = FREE;
+
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    public Lock read() {
+        return this.read;
+    }
+
+    public Lock write() {
+        return this.write;
+    }
+
+    boolean tryAcquireRead() {
+        while (true) {
+            int state = this.state;
+            if (state == WRITING) {
+                return false;
+            }
+
+            if (UNSAFE.compareAndSwapInt(this, STATE_OFFSET, state, state + 1)) {
+                return true;
+            }
+        }
+    }
+
+    boolean canAcquireRead() {
+        return this.state != WRITING;
+    }
+
+    boolean tryAcquireWrite() {
+        return UNSAFE.compareAndSwapInt(this, STATE_OFFSET, FREE, WRITING);
+    }
+
+    boolean canAcquireWrite() {
+        return this.state == FREE;
+    }
+
+    void releaseWrite() {
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, WRITING, FREE)) {
+            throw new IllegalStateException("write lock not acquired");
+        }
+
+        this.waiters.wake();
+    }
+
+    void releaseRead() {
+        int readCount = UNSAFE.getAndAddInt(this, STATE_OFFSET, -1) - 1;
+        if (readCount < 0) {
+            throw new IllegalStateException("read lock not acquired");
+        }
+
+        if (readCount == FREE) {
+            this.waiters.wake();
+        }
+    }
+
+    @Override
+    public String toString() {
+        int state = this.state;
+        if (state == FREE) {
+            return "RwLock(FREE)";
+        } else if (state == WRITING) {
+            return "RwLock(WRITING)";
+        } else {
+            return "RwLock(READING=" + state + ")";
+        }
+    }
+
+    private final class Read implements Lock {
+        @Override
+        public boolean tryAcquire() {
+            return RwLock.this.tryAcquireRead();
+        }
+
+        @Override
+        public boolean canAcquire() {
+            return RwLock.this.canAcquireRead();
+        }
+
+        @Override
+        public void release() {
+            RwLock.this.releaseRead();
+        }
+
+        @Override
+        public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+            if (!this.tryAcquire()) {
+                RwLock.this.waiters.registerWaiter(waiter, waker);
+                return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+            }
+
+            return PollLock.ACQUIRED;
+        }
+
+        @Override
+        public String toString() {
+            if (this.canAcquire()) {
+                return "RwLock.Read(FREE)";
+            } else {
+                return "RwLock.Read(LOCKED)";
+            }
+        }
+    }
+
+    private final class Write implements Lock {
+        @Override
+        public boolean tryAcquire() {
+            return RwLock.this.tryAcquireWrite();
+        }
+
+        @Override
+        public boolean canAcquire() {
+            return RwLock.this.canAcquireWrite();
+        }
+
+        @Override
+        public void release() {
+            RwLock.this.releaseWrite();
+        }
+
+        @Override
+        public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+            if (!this.tryAcquire()) {
+                RwLock.this.waiters.registerWaiter(waiter, waker);
+                return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+            }
+
+            return PollLock.ACQUIRED;
+        }
+
+        @Override
+        public String toString() {
+            if (this.canAcquire()) {
+                return "RwLock.Write(FREE)";
+            } else {
+                return "RwLock.Write(LOCKED)";
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java b/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java
new file mode 100644
index 0000000000000000000000000000000000000000..3fcaa099b68b7363600c2d1d30d6be64237f88c9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java
@@ -0,0 +1,78 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class Semaphore implements Lock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long COUNT_OFFSET;
+
+    static {
+        try {
+            COUNT_OFFSET = UNSAFE.objectFieldOffset(Semaphore.class.getDeclaredField("count"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get count field offsets", e);
+        }
+    }
+
+    private final int maximum;
+    private volatile int count = 0;
+
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    public Semaphore(int maximum) {
+        this.maximum = maximum;
+    }
+
+    private boolean canAcquire(int count) {
+        return count < this.maximum;
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        while (true) {
+            int count = this.count;
+            if (!this.canAcquire(count)) {
+                return false;
+            }
+
+            if (UNSAFE.compareAndSwapInt(this, COUNT_OFFSET, count, count + 1)) {
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        if (!this.tryAcquire()) {
+            this.waiters.registerWaiter(waiter, waker);
+            return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return this.canAcquire(this.count);
+    }
+
+    @Override
+    public void release() {
+        int count = UNSAFE.getAndAddInt(this, COUNT_OFFSET, -1);
+        if (count <= 0) {
+            throw new IllegalStateException("semaphore not acquired");
+        }
+
+        int newCount = count - 1;
+
+        int available = this.maximum - newCount;
+        if (available > 0) {
+            this.waiters.wake(available);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..3875670dd941931ab2251304cdb98b82658dffe1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java
@@ -0,0 +1,53 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class ChunkExecutor implements TaskSpawner, TaskQueue, AutoCloseable {
+    public static final ChunkExecutor INSTANCE = new ChunkExecutor();
+
+    private static final Logger LOGGER = LogManager.getLogger("worldgen-worker");
+
+    private final LevelPrioritisedQueue<ChunkTask<?>> queue = new LevelPrioritisedQueue<>(ChunkLevelTracker.MAX_LEVEL);
+
+    private ChunkExecutor() {
+        for (int i = 0; i < TicTacsConfig.get().threadCount; i++) {
+            Thread thread = new Thread(this::run);
+            thread.setName("worldgen-worker-" + (i + 1));
+            thread.setDaemon(true);
+            thread.start();
+        }
+    }
+
+    @Override
+    public <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future) {
+        ChunkTask<T> task = new ChunkTask<>(entry, future, this);
+        this.queue.enqueue(task, entry.getLevel());
+        return task;
+    }
+
+    @Override
+    public <T> void enqueue(ChunkTask<T> task) {
+        this.queue.enqueue(task, task.getLevel());
+    }
+
+    public void run() {
+        try {
+            ChunkTask<?> task;
+            while ((task = this.queue.take()) != null) {
+                task.advance();
+            }
+        } catch (InterruptedException e) {
+            LOGGER.warn("worldgen worker interrupted", e);
+        }
+    }
+
+    @Override
+    public void close() {
+        this.queue.close();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..e260e9fbd953a436bb9e79e01b77b652e9709143
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java
@@ -0,0 +1,66 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.util.thread.ThreadExecutor;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class ChunkMainThreadExecutor implements TaskSpawner, TaskQueue, AutoCloseable, Runnable {
+    private static final int BUFFER_SIZE = 16;
+
+    private final ThreadExecutor<Runnable> executor;
+    private final AtomicInteger enqueued = new AtomicInteger(0);
+
+    private final LevelPrioritisedQueue<ChunkTask<?>> queue = new LevelPrioritisedQueue<>(ChunkLevelTracker.MAX_LEVEL);
+
+    public ChunkMainThreadExecutor(ThreadExecutor<Runnable> executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public <T> void enqueue(ChunkTask<T> task) {
+        this.queue.enqueue(task, task.getLevel());
+        this.tryEnqueue();
+    }
+
+    @Override
+    public <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future) {
+        ChunkTask<T> task = new ChunkTask<>(entry, future, this);
+        this.enqueue(task);
+        return task;
+    }
+
+    @Override
+    public void run() {
+        this.enqueued.getAndDecrement();
+
+        ChunkTask<?> task = this.queue.remove();
+        if (task != null) {
+            task.advance();
+
+            // we still have more tasks to process: re-enqueue ourselves to the executor
+            this.tryEnqueue();
+        }
+    }
+
+    private void tryEnqueue() {
+        while (true) {
+            int enqueued = this.enqueued.get();
+            if (enqueued >= BUFFER_SIZE) {
+                return;
+            }
+
+            if (this.enqueued.compareAndSet(enqueued, enqueued + 1)) {
+                this.executor.submit(this);
+                return;
+            }
+        }
+    }
+
+    @Override
+    public void close() {
+        this.queue.close();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3453db29ceace8751677437d5efb6470f7d125d1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java
@@ -0,0 +1,60 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.TicTacs;
+import net.minecraft.server.world.ChunkHolder;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class ChunkTask<T> {
+    public final ChunkHolder holder;
+
+    public final Future<T> future;
+    public final ChunkWaker waker = new ChunkWaker(this);
+
+    private volatile TaskQueue queue;
+
+    private volatile boolean complete;
+
+    ChunkTask(@Nullable ChunkHolder holder, Future<T> future, TaskQueue queue) {
+        this.holder = holder;
+        this.future = future;
+        this.queue = queue;
+    }
+
+    public void moveTo(TaskQueue queue) {
+        this.queue = queue;
+    }
+
+    void advance() {
+        if (this.complete) return;
+
+        try {
+            this.waker.polling();
+            if (this.future.poll(this.waker) != null) {
+                this.complete = true;
+            } else {
+                this.waker.ready();
+            }
+        } catch (RuntimeException e) {
+            this.complete = true;
+
+            TicTacs.LOGGER.error("Worker thread exited with unhandled exception", e);
+            throw new Error(e);
+        }
+    }
+
+    void enqueue() {
+        if (this.complete) return;
+
+        this.queue.enqueue(this);
+    }
+
+    public boolean isComplete() {
+        return this.complete;
+    }
+
+    public int getLevel() {
+        return this.holder != null ? this.holder.getLevel() : 0;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java
new file mode 100644
index 0000000000000000000000000000000000000000..c097383e92b779f7029246b05634bbc453b5e96f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java
@@ -0,0 +1,54 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class ChunkWaker implements Waker {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(ChunkWaker.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("failed to get state offset", e);
+        }
+    }
+
+    private static final int WAITING = 0;
+    private static final int POLLING = 1;
+    private static final int AWOKEN = 2;
+
+    private final ChunkTask<?> task;
+
+    private volatile int state = AWOKEN;
+
+    ChunkWaker(ChunkTask<?> task) {
+        this.task = task;
+    }
+
+    @Override
+    public void wake() {
+        int prevState = UNSAFE.getAndSetInt(this, STATE_OFFSET, AWOKEN);
+
+        // only enqueue the task if we're still waiting for a signal
+        if (prevState == WAITING) {
+            this.task.enqueue();
+        }
+    }
+
+    void polling() {
+        this.state = POLLING;
+    }
+
+    void ready() {
+        // we didn't get a result: set state to waiting. we expect state to still be polling, so if that's *not*
+        // the case, we must've been awoken during polling. now that we know this task needs to continue
+        // execution, we can re-enqueue it.
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, POLLING, WAITING)) {
+            this.task.enqueue();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java b/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..d7ec42511c0dca17cfe8be2c8a288b7ae777c594
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java
@@ -0,0 +1,115 @@
+package net.gegy1000.tictacs.async.worker;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.LinkedList;
+
+public final class LevelPrioritisedQueue<T> implements AutoCloseable {
+    private final int levelCount;
+    private final Level<T>[] levels;
+    private volatile int minLevel;
+
+    private volatile boolean open = true;
+
+    private final Object lock = new Object();
+
+    @SuppressWarnings("unchecked")
+    public LevelPrioritisedQueue(int levelCount) {
+        this.levelCount = levelCount;
+
+        this.levels = new Level[levelCount];
+        for (int i = 0; i < levelCount; i++) {
+            this.levels[i] = new Level<>();
+        }
+
+        this.minLevel = levelCount;
+    }
+
+    public void enqueue(T task, int level) {
+        if (level >= this.levelCount) {
+            level = this.levelCount - 1;
+        }
+
+        synchronized (this.lock) {
+            this.levels[level].enqueue(task);
+
+            if (level <= this.minLevel) {
+                this.minLevel = level;
+                this.lock.notify();
+            }
+        }
+    }
+
+    @Nullable
+    public T take() throws InterruptedException {
+        while (this.open) {
+            synchronized (this.lock) {
+                if (this.minLevel < this.levelCount) {
+                    T task = this.tryTakeTask(this.minLevel);
+                    if (task != null) {
+                        return task;
+                    }
+                }
+
+                this.lock.wait();
+            }
+        }
+
+        return null;
+    }
+
+    @Nullable
+    public T remove() {
+        synchronized (this.lock) {
+            int minLevel = this.minLevel;
+            if (minLevel < this.levelCount) {
+                T task = this.tryTakeTask(minLevel);
+                if (task != null) {
+                    return task;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    @Nullable
+    private T tryTakeTask(int level) {
+        T task = this.levels[level].take();
+        if (task != null) {
+            this.minLevel = this.findMinLevel(level);
+            return task;
+        }
+        return null;
+    }
+
+    private int findMinLevel(int level) {
+        while (level < this.levelCount && this.levels[level].isEmpty()) {
+            level++;
+        }
+        return level;
+    }
+
+    @Override
+    public void close() {
+        synchronized (this.lock) {
+            this.open = false;
+            this.lock.notifyAll();
+        }
+    }
+
+    static class Level<T> {
+        private final LinkedList<T> queue = new LinkedList<>();
+
+        void enqueue(T task) {
+            this.queue.add(task);
+        }
+
+        T take() {
+            return this.queue.remove();
+        }
+
+        boolean isEmpty() {
+            return this.queue.isEmpty();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java b/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e6afe5cf122713829e6fb05424b35c54cb9fedc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.async.worker;
+
+public interface TaskQueue {
+    <T> void enqueue(ChunkTask<T> task);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java b/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java
new file mode 100644
index 0000000000000000000000000000000000000000..71f5d66606dd4efb3bd0c662adba0145656897d3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java
@@ -0,0 +1,12 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+
+public interface TaskSpawner {
+    <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future);
+
+    default <T> ChunkTask<T> spawn(Future<T> future) {
+        return this.spawn(null, future);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..76c08bc1e6eed24ab5c941410ff40d8354fdb2f4
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java
@@ -0,0 +1,37 @@
+package net.gegy1000.tictacs.chunk;
+
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.util.math.ChunkPos;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public interface ChunkAccess {
+    void putEntry(ChunkEntry entry);
+
+    ChunkEntry removeEntry(long pos);
+
+    @Nullable
+    ChunkEntry getEntry(long pos);
+
+    @Nullable
+    default ChunkEntry getEntry(int chunkX, int chunkZ) {
+        return this.getEntry(ChunkPos.toLong(chunkX, chunkZ));
+    }
+
+    @Nullable
+    default ChunkEntry getEntry(ChunkPos pos) {
+        return this.getEntry(pos.toLong());
+    }
+
+    @NotNull
+    default ChunkEntry expectEntry(int chunkX, int chunkZ) {
+        ChunkEntry entry = this.getEntry(chunkX, chunkZ);
+        if (entry == null) {
+            throw new IllegalStateException("expected entry at [" + chunkX + ", " + chunkZ + "]");
+        }
+        return entry;
+    }
+
+    ObjectCollection<ChunkEntry> getEntries();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6f6f94156d3db83681e997eb2712fe0b68b85fc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java
@@ -0,0 +1,44 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.tracker.ChunkTracker;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+
+public interface ChunkController {
+    default ThreadedAnvilChunkStorage asTacs() {
+        return (ThreadedAnvilChunkStorage) this;
+    }
+
+    ChunkMap getMap();
+
+    ChunkUpgrader getUpgrader();
+
+    ChunkTicketManager getTicketManager();
+
+    ChunkTracker getTracker();
+
+    ChunkListener getChunkAs(ChunkEntry entry, ChunkStep step);
+
+    Future<Unit> getRadiusAs(ChunkPos pos, int radius, ChunkStep step);
+
+    Future<Chunk> spawnLoadChunk(ChunkEntry entry);
+
+    void notifyStatus(ChunkPos pos, ChunkStatus status);
+
+    <T> void spawnOnMainThread(ChunkEntry entry, Future<T> future);
+
+    default <T> void spawnOnMainThread(Future<T> future) {
+        this.spawnOnMainThread(null, future);
+    }
+
+    void spawnOnMainThread(ChunkEntry entry, Runnable runnable);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9a5d007bb78007549dc810f7bad0715ef12671c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java
@@ -0,0 +1,112 @@
+package net.gegy1000.tictacs.chunk;
+
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.fabricmc.fabric.api.network.ServerSidePacketRegistry;
+import net.fabricmc.fabric.api.server.PlayerStream;
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import net.gegy1000.tictacs.mixin.TacsAccessor;
+import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.network.PacketByteBuf;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.Pair;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.ArrayDeque;
+import java.util.List;
+import java.util.Queue;
+import java.util.stream.Collectors;
+
+public final class ChunkLevelTracker {
+    public static final int FULL_LEVEL = TicTacsConfig.get().maxViewDistance + 1;
+    public static final int MAX_LEVEL = FULL_LEVEL + ChunkStep.getMaxDistance() + 1;
+
+    public static final int LIGHT_TICKET_LEVEL = FULL_LEVEL + ChunkStep.getDistanceFromFull(ChunkStep.GENERATION);
+
+    private final ServerWorld world;
+    private final ChunkController controller;
+
+    // Debug only!
+    private final Queue<Pair<Long, Integer>> ticketCache = new ArrayDeque<>();
+
+    public ChunkLevelTracker(ServerWorld world, ChunkController controller) {
+        this.world = world;
+        this.controller = controller;
+    }
+
+    @Nullable
+    public ChunkEntry setLevel(long pos, int toLevel, @Nullable ChunkEntry entry, int fromLevel) {
+        if (isUnloaded(fromLevel) && isUnloaded(toLevel)) {
+            return entry;
+        }
+
+        if (TicTacsConfig.get().debug.chunkLevels) {
+            this.sendDebugLevel(pos, toLevel);
+        }
+
+        if (entry != null) {
+            return this.updateLevel(pos, toLevel, entry);
+        } else {
+            return this.createAtLevel(pos, toLevel);
+        }
+    }
+
+    private ChunkEntry updateLevel(long pos, int toLevel, ChunkEntry entry) {
+        entry.setLevel(toLevel);
+
+        TacsAccessor accessor = (TacsAccessor) this.controller;
+        LongSet unloadedChunks = accessor.getQueuedUnloads();
+
+        if (isUnloaded(toLevel)) {
+            unloadedChunks.add(pos);
+        } else {
+            unloadedChunks.remove(pos);
+        }
+
+        return entry;
+    }
+
+    @Nullable
+    private ChunkEntry createAtLevel(long pos, int toLevel) {
+        if (isUnloaded(toLevel)) {
+            return null;
+        }
+
+        return this.controller.getMap().loadEntry(pos, toLevel);
+    }
+
+    public static boolean isLoaded(int level) {
+        return level <= MAX_LEVEL;
+    }
+
+    public static boolean isUnloaded(int level) {
+        return level > MAX_LEVEL;
+    }
+
+    private void sendDebugLevel(long pos, int toLevel) {
+        List<PlayerEntity> players = PlayerStream.world(this.world).collect(Collectors.toList());
+
+        if (players.size() > 0) {
+            players.forEach(player -> this.sendDebugChunkTicketData(player, pos, toLevel));
+
+            while (this.ticketCache.size() > 0) {
+                Pair<Long, Integer> val = this.ticketCache.poll();
+                players.forEach(player -> this.sendDebugChunkTicketData(player, val.getLeft(), val.getRight()));
+            }
+        } else {
+            this.ticketCache.add(new Pair<>(pos, toLevel));
+        }
+    }
+
+    private void sendDebugChunkTicketData(PlayerEntity player, long pos, int toLevel) {
+        PacketByteBuf data = new PacketByteBuf(Unpooled.buffer());
+
+        data.writeLong(pos);
+        data.writeInt(toLevel);
+
+        ServerSidePacketRegistry.INSTANCE.sendToPlayer(player, TicTacs.DEBUG_CHUNK_TICKETS, data);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c81e901ae8cdeff202785ad5d9445cb3e5566d9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java
@@ -0,0 +1,7 @@
+package net.gegy1000.tictacs.chunk;
+
+public enum ChunkLockType {
+    EARLY_GENERATION,
+    LATE_GENERATION,
+    FINALIZATION
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e35edda592903cee9ba3cd5cae663b24eaff06e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java
@@ -0,0 +1,245 @@
+package net.gegy1000.tictacs.chunk;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.mixin.TacsAccessor;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.math.ChunkPos;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class ChunkMap {
+    private final ServerWorld world;
+    private final ChunkController controller;
+
+    private final Long2ObjectMap<ChunkEntry> primaryEntries = new Long2ObjectOpenHashMap<>();
+    private volatile Long2ObjectMap<ChunkEntry> visibleEntries = new Long2ObjectOpenHashMap<>();
+    private Long2ObjectMap<ChunkEntry> swapEntries = new Long2ObjectOpenHashMap<>();
+
+    private Long2ObjectMap<ChunkEntry> pendingUpdates = new Long2ObjectOpenHashMap<>();
+
+    private final AtomicInteger flushCount = new AtomicInteger();
+
+    private final ChunkAccess primary = new Primary();
+    private final ChunkAccess visible = new Visible();
+
+    private final ChunkTickingMaps tickingMaps = new ChunkTickingMaps();
+
+    private final WaiterQueue flushWaiters = new WaiterQueue();
+
+    private ChunkMapListener[] listeners = new ChunkMapListener[0];
+
+    public ChunkMap(ServerWorld world, ChunkController controller) {
+        this.world = world;
+        this.controller = controller;
+
+        this.addListener(this.tickingMaps);
+    }
+
+    public void addListener(ChunkMapListener listener) {
+        this.listeners = Arrays.copyOf(this.listeners, this.listeners.length + 1);
+        this.listeners[this.listeners.length - 1]  = listener;
+    }
+
+    public ChunkEntry getOrCreateEntry(long pos, int level) {
+        ChunkEntry entry = this.primary.getEntry(pos);
+        if (entry != null) {
+            return entry;
+        } else {
+            return this.loadEntry(pos, level);
+        }
+    }
+
+    public ChunkEntry loadEntry(long pos, int level) {
+        ChunkEntry entry = this.createEntry(pos, level);
+        this.primary.putEntry(entry);
+        return entry;
+    }
+
+    private ChunkEntry createEntry(long pos, int level) {
+        ThreadedAnvilChunkStorage tacs = this.controller.asTacs();
+        TacsAccessor accessor = (TacsAccessor) this.controller;
+
+        ChunkEntry unloadingEntry = (ChunkEntry) accessor.getUnloadingChunks().remove(pos);
+        if (unloadingEntry != null) {
+            unloadingEntry.setLevel(level);
+            return unloadingEntry;
+        }
+
+        return new ChunkEntry(new ChunkPos(pos), level, this.world.getLightingProvider(), accessor.getChunkTaskPrioritySystem(), tacs);
+    }
+
+    public FlushListener awaitFlush() {
+        return new FlushListener(this.flushCount.get());
+    }
+
+    public ChunkAccess primary() {
+        return this.primary;
+    }
+
+    public ChunkAccess visible() {
+        return this.visible;
+    }
+
+    public boolean flushToVisible() {
+        if (!this.pendingUpdates.isEmpty()) {
+            Long2ObjectMap<ChunkEntry> pendingUpdates = this.takePendingUpdates();
+
+            // prepare the new entry map before swapping
+            Long2ObjectMap<ChunkEntry> swapEntries = this.swapEntries;
+            this.applyPendingUpdatesTo(pendingUpdates, swapEntries);
+
+            // swap the entry maps
+            this.swapEntries = this.visibleEntries;
+            this.visibleEntries = swapEntries;
+
+            // now we can safely apply the pending updates to the swap map
+            this.applyPendingUpdatesTo(pendingUpdates, this.swapEntries);
+
+            this.notifyFlush();
+
+            return true;
+        }
+
+        return false;
+    }
+
+    private void applyPendingUpdatesTo(Long2ObjectMap<ChunkEntry> pending, Long2ObjectMap<ChunkEntry> entries) {
+        for (Long2ObjectMap.Entry<ChunkEntry> update : Long2ObjectMaps.fastIterable(pending)) {
+            long pos = update.getLongKey();
+            ChunkEntry entry = update.getValue();
+
+            if (entry != null) {
+                entries.put(pos, entry);
+            } else {
+                entries.remove(pos);
+            }
+        }
+    }
+
+    private Long2ObjectMap<ChunkEntry> takePendingUpdates() {
+        Long2ObjectMap<ChunkEntry> pendingUpdates = this.pendingUpdates;
+        this.pendingUpdates = new Long2ObjectOpenHashMap<>();
+        return pendingUpdates;
+    }
+
+    private void notifyFlush() {
+        this.flushCount.getAndIncrement();
+        this.flushWaiters.wake();
+    }
+
+    public int getEntryCount() {
+        return this.primaryEntries.size();
+    }
+
+    public ChunkTickingMaps getTickingMaps() {
+        return this.tickingMaps;
+    }
+
+    private void onAddChunk(ChunkEntry entry) {
+        for (ChunkMapListener listener : this.listeners) {
+            listener.onAddChunk(entry);
+        }
+    }
+
+    private void onRemoveChunk(ChunkEntry entry) {
+        for (ChunkMapListener listener : this.listeners) {
+            listener.onRemoveChunk(entry);
+        }
+    }
+
+    final class Primary implements ChunkAccess {
+        @Override
+        public void putEntry(ChunkEntry entry) {
+            long pos = entry.getPos().toLong();
+            ChunkMap.this.primaryEntries.put(pos, entry);
+            ChunkMap.this.pendingUpdates.put(pos, entry);
+            ChunkMap.this.onAddChunk(entry);
+        }
+
+        @Override
+        public ChunkEntry removeEntry(long pos) {
+            ChunkEntry entry = ChunkMap.this.primaryEntries.remove(pos);
+            if (entry != null) {
+                ChunkMap.this.onRemoveChunk(entry);
+                ChunkMap.this.pendingUpdates.put(pos, null);
+            }
+            return entry;
+        }
+
+        @Nullable
+        @Override
+        public ChunkEntry getEntry(long pos) {
+            return ChunkMap.this.primaryEntries.get(pos);
+        }
+
+        @Override
+        public ObjectCollection<ChunkEntry> getEntries() {
+            return ChunkMap.this.primaryEntries.values();
+        }
+    }
+
+    final class Visible implements ChunkAccess {
+        @Override
+        public void putEntry(ChunkEntry entry) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public ChunkEntry removeEntry(long pos) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Nullable
+        @Override
+        public ChunkEntry getEntry(long pos) {
+            return ChunkMap.this.visibleEntries.get(pos);
+        }
+
+        @Override
+        public ObjectCollection<ChunkEntry> getEntries() {
+            return new ObjectArrayList<>(ChunkMap.this.visibleEntries.values());
+        }
+    }
+
+    public class FlushListener extends LinkedWaiter implements Future<Unit> {
+        private final int flushCount;
+
+        FlushListener(int flushCount) {
+            this.flushCount = flushCount;
+        }
+
+        @Nullable
+        @Override
+        public Unit poll(Waker waker) {
+            if (this.isReady()) {
+                return Unit.INSTANCE;
+            }
+
+            ChunkMap.this.flushWaiters.registerWaiter(this, waker);
+
+            if (this.isReady()) {
+                this.invalidateWaker();
+                return Unit.INSTANCE;
+            }
+
+            return null;
+        }
+
+        private boolean isReady() {
+            return ChunkMap.this.flushCount.get() > this.flushCount;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8f582a320379f460dd8d727ca971cdce6bd1c24
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java
@@ -0,0 +1,11 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+
+public interface ChunkMapListener {
+    default void onAddChunk(ChunkEntry entry) {
+    }
+
+    default void onRemoveChunk(ChunkEntry entry) {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java
new file mode 100644
index 0000000000000000000000000000000000000000..88dcedcaecd32519916aca272cc7397da2ac619c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java
@@ -0,0 +1,8 @@
+package net.gegy1000.tictacs.chunk;
+
+public final class ChunkNotLoadedException extends RuntimeException {
+    public static final ChunkNotLoadedException INSTANCE = new ChunkNotLoadedException();
+
+    private ChunkNotLoadedException() {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b1861a2e1a6c1e54bd4997c82d722f3188d01ec
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs.chunk;
+
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceSet;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+
+import java.util.Collection;
+
+public final class ChunkTickingMaps implements ChunkMapListener {
+    private final ReferenceSet<ChunkEntry> trackableEntries = new ReferenceOpenHashSet<>();
+    private final ReferenceSet<ChunkEntry> tickableEntries = new ReferenceOpenHashSet<>();
+
+    public void addTrackableChunk(ChunkEntry entry) {
+        this.trackableEntries.add(entry);
+    }
+
+    public void removeTrackableChunk(ChunkEntry entry) {
+        this.trackableEntries.remove(entry);
+    }
+
+    public void addTickableChunk(ChunkEntry entry) {
+        this.tickableEntries.add(entry);
+    }
+
+    public void removeTickableChunk(ChunkEntry entry) {
+        this.tickableEntries.remove(entry);
+    }
+
+    public Collection<ChunkEntry> getTrackableEntries() {
+        return this.trackableEntries;
+    }
+
+    public Collection<ChunkEntry> getTickableEntries() {
+        return this.tickableEntries;
+    }
+
+    @Override
+    public void onRemoveChunk(ChunkEntry entry) {
+        this.tickableEntries.remove(entry);
+        this.trackableEntries.remove(entry);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java b/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d09770bf25c28c6937c2f4318085633152bebad
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java
@@ -0,0 +1,68 @@
+package net.gegy1000.tictacs.chunk;
+
+import it.unimi.dsi.fastutil.HashCommon;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+
+public final class LossyChunkCache {
+    private static final int COORD_BITS = 30;
+    private static final int COORD_MASK = (1 << COORD_BITS) - 1;
+    private static final int STEP_BITS = 4;
+    private static final int STEP_MASK = (1 << STEP_BITS) - 1;
+
+    private final int mask;
+
+    private final long[] keys;
+    private final Chunk[] values;
+
+    public LossyChunkCache(int capacity) {
+        capacity = MathHelper.smallestEncompassingPowerOfTwo(capacity);
+        this.mask = capacity - 1;
+
+        this.keys = new long[capacity];
+        this.values = new Chunk[capacity];
+    }
+
+    public void clear() {
+        Arrays.fill(this.keys, Long.MIN_VALUE);
+        Arrays.fill(this.values, null);
+    }
+
+    public void put(int x, int z, ChunkStep step, Chunk chunk) {
+        if (chunk == null) {
+            return;
+        }
+
+        long key = key(x, z, step);
+        int index = this.index(key);
+
+        this.keys[index] = key;
+        this.values[index] = chunk;
+    }
+
+    @Nullable
+    public Chunk get(int x, int z, ChunkStep step) {
+        long key = key(x, z, step);
+        int index = this.index(key);
+
+        if (this.keys[index] == key) {
+            return this.values[index];
+        }
+
+        return null;
+    }
+
+    private static long key(int x, int z, ChunkStep step) {
+        return (long) (x & COORD_MASK) << 34
+                | (long) (z & COORD_MASK) << 4
+                | (step.getIndex() & STEP_MASK);
+    }
+
+    private int index(long key) {
+        return (int) HashCommon.mix(key) & this.mask;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..558523fc48a61cc822811a87ad77b2dc200dd15d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java
@@ -0,0 +1,50 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.async.lock.Mutex;
+import net.gegy1000.tictacs.async.lock.NullLock;
+import net.gegy1000.tictacs.async.lock.RwLock;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+
+public final class ChunkAccessLock {
+    private static final ChunkLockType[] RESOURCES = ChunkLockType.values();
+
+    private final Lock[] readLocks;
+    private final Lock[] writeLocks;
+
+    private final Lock upgradeLock;
+
+    public ChunkAccessLock() {
+        this.readLocks = new Lock[RESOURCES.length];
+        this.writeLocks = new Lock[RESOURCES.length];
+
+        if (TicTacsConfig.get().isSingleThreaded()) {
+            for (int i = 0; i < RESOURCES.length; i++) {
+                this.readLocks[i] = NullLock.INSTANCE;
+                this.writeLocks[i] = NullLock.INSTANCE;
+            }
+        } else {
+            for (int i = 0; i < RESOURCES.length; i++) {
+                RwLock resourceLock = new RwLock();
+
+                this.readLocks[i] = resourceLock.read();
+                this.writeLocks[i] = resourceLock.write();
+            }
+        }
+
+        this.upgradeLock = new Mutex();
+    }
+
+    public Lock upgrade() {
+        return this.upgradeLock;
+    }
+
+    public Lock read(ChunkLockType resource) {
+        return this.readLocks[resource.ordinal()];
+    }
+
+    public Lock write(ChunkLockType resource) {
+        return this.writeLocks[resource.ordinal()];
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d1cff7ffc5cafc22bf6daff72e56681f5fff1d8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java
@@ -0,0 +1,437 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.player.PlayerEntity;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.collection.TypeFilterableList;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.chunk.ReadOnlyChunk;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.chunk.light.LightingProvider;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.LongPredicate;
+import java.util.stream.Stream;
+
+public final class ChunkEntry extends ChunkHolder {
+    private final AtomicReferenceArray<ChunkListener> listeners = new AtomicReferenceArray<>(ChunkStep.STEPS.size());
+
+    private volatile ProtoChunk chunk;
+    private volatile WorldChunk worldChunk;
+
+    private volatile ChunkStep currentStep;
+    private final AtomicReference<ChunkStep> spawnedStep = new AtomicReference<>();
+    private final AtomicBoolean loading = new AtomicBoolean();
+
+    private final ChunkEntryTrackers trackers = new ChunkEntryTrackers();
+    private final ChunkAccessLock lock = new ChunkAccessLock();
+
+    public ChunkEntry(
+            ChunkPos pos, int level,
+            LightingProvider lighting,
+            LevelUpdateListener levelUpdateListener,
+            PlayersWatchingChunkProvider watchers
+    ) {
+        super(pos, level, lighting, levelUpdateListener, watchers);
+    }
+
+    public ChunkAccessLock getLock() {
+        return this.lock;
+    }
+
+    public ChunkListener getListenerFor(ChunkStep step) {
+        while (true) {
+            ChunkListener listener = this.listeners.get(step.getIndex());
+            if (listener != null) {
+                return listener;
+            }
+
+            ChunkListener newListener = new ChunkListener(this, step);
+            if (this.listeners.compareAndSet(step.getIndex(), null, newListener)) {
+                for (ChunkStatus status : step.getStatuses()) {
+                    this.futuresByStatus.set(status.getIndex(), newListener.asVanilla());
+                }
+
+                return newListener;
+            }
+        }
+    }
+
+    @Nullable
+    public ChunkListener getValidListenerFor(ChunkStep step) {
+        return this.isValidAs(step) ? this.getListenerFor(step) : null;
+    }
+
+    @Nullable
+    public ChunkStep getCurrentStep() {
+        return this.currentStep;
+    }
+
+    public boolean canUpgradeTo(ChunkStep toStep) {
+        return this.isValidAs(toStep) && !this.isAt(toStep);
+    }
+
+    public boolean isValidAs(ChunkStep toStep) {
+        int requiredLevel = ChunkLevelTracker.FULL_LEVEL + ChunkStep.getDistanceFromFull(toStep);
+        return this.level <= requiredLevel;
+    }
+
+    public ChunkStep getTargetStep() {
+        return getTargetStep(this.level);
+    }
+
+    public static ChunkStep getTargetStep(int level) {
+        int distanceFromFull = level - ChunkLevelTracker.FULL_LEVEL;
+        return ChunkStep.byDistanceFromFull(distanceFromFull);
+    }
+
+    public boolean trySpawnUpgradeTo(ChunkStep toStep) {
+        if (!this.isValidAs(toStep)) {
+            return false;
+        }
+
+        while (true) {
+            ChunkStep fromStep = this.spawnedStep.get();
+            if (fromStep != null && fromStep.greaterOrEqual(toStep)) {
+                return false;
+            }
+
+            if (this.spawnedStep.compareAndSet(fromStep, toStep)) {
+                this.combineSavingFuture(toStep);
+                return true;
+            }
+        }
+    }
+
+    public boolean trySpawnLoad() {
+        return this.loading.compareAndSet(false, true);
+    }
+
+    public boolean isTicking() {
+        Either<WorldChunk, Unloaded> ticking = this.getTickingFuture().getNow(null);
+        if (ticking == null) {
+            return false;
+        }
+
+        return !ticking.right().isPresent();
+    }
+
+    public boolean isTickingEntities() {
+        Either<WorldChunk, Unloaded> entityTicking = this.getEntityTickingFuture().getNow(null);
+        if (entityTicking == null) {
+            return false;
+        }
+
+        return !entityTicking.right().isPresent();
+    }
+
+    public void onUpdateLevel(ThreadedAnvilChunkStorage tacs) {
+        if (this.level > this.lastTickLevel) {
+            this.reduceLevel(this.lastTickLevel, this.level);
+
+            ChunkHolder.LevelType level = getLevelType(this.level);
+            ChunkHolder.LevelType lastLevel = getLevelType(this.lastTickLevel);
+
+            // TODO: better unify logic that adds & removes from the trackable chunk list
+            if (!level.isAfter(LevelType.TICKING) && lastLevel.isAfter(LevelType.TICKING)) {
+                ChunkMap map = ((ChunkController) tacs).getMap();
+                map.getTickingMaps().removeTrackableChunk(this);
+            }
+        }
+
+        super.tick(tacs);
+    }
+
+    private void reduceLevel(int lastLevel, int level) {
+        boolean wasLoaded = ChunkLevelTracker.isLoaded(lastLevel);
+        if (!wasLoaded) {
+            return;
+        }
+
+        boolean isLoaded = ChunkLevelTracker.isLoaded(level);
+
+        ChunkStep lastStep = getTargetStep(lastLevel);
+        ChunkStep targetStep = getTargetStep(level);
+
+        int startIdx = isLoaded ? targetStep.getIndex() + 1 : 0;
+        int endIdx = lastStep.getIndex();
+
+        if (startIdx > endIdx) {
+            return;
+        }
+
+        for (int i = startIdx; i <= endIdx; i++) {
+            ChunkListener listener = this.listeners.getAndSet(i, null);
+            if (listener != null) {
+                listener.completeErr();
+            }
+        }
+
+        this.downgradeSpawnedStep(targetStep);
+    }
+
+    private void downgradeSpawnedStep(ChunkStep targetStep) {
+        while (true) {
+            ChunkStep spawnedStep = this.spawnedStep.get();
+            if (targetStep != null && !targetStep.lessThan(spawnedStep)) {
+                break;
+            }
+
+            if (this.spawnedStep.compareAndSet(spawnedStep, targetStep)) {
+                break;
+            }
+        }
+    }
+
+    @Nullable
+    public ProtoChunk getProtoChunk() {
+        return this.chunk;
+    }
+
+    @Nullable
+    @Override
+    public WorldChunk getWorldChunk() {
+        return this.worldChunk;
+    }
+
+    @Nullable
+    public Chunk getChunk() {
+        WorldChunk worldChunk = this.worldChunk;
+        if (worldChunk != null) {
+            return worldChunk;
+        }
+        return this.chunk;
+    }
+
+    @Nullable
+    public Chunk getChunkAtLeast(ChunkStep step) {
+        if (this.isAt(step)) {
+            return this.getChunk();
+        } else {
+            return null;
+        }
+    }
+
+    @Nullable
+    public Chunk getChunkForStep(ChunkStep step) {
+        if (!this.isAt(step)) {
+            return null;
+        }
+
+        if (step == ChunkStep.FULL) {
+            return this.worldChunk;
+        } else {
+            return this.chunk;
+        }
+    }
+
+    public boolean isAt(ChunkStep step) {
+        return step.lessOrEqual(this.currentStep);
+    }
+
+    public void completeUpgradeOk(ChunkStep step, Chunk chunk) {
+        ChunkStep lastStep = this.includeStep(step);
+
+        if (chunk instanceof ProtoChunk) {
+            this.chunk = (ProtoChunk) chunk;
+        }
+
+        int startIdx = lastStep != null ? lastStep.getIndex() : 0;
+        int endIdx = step.getIndex();
+
+        for (int idx = startIdx; idx <= endIdx; idx++) {
+            ChunkListener listener = this.listeners.get(idx);
+            if (listener != null) {
+                listener.completeOk();
+            }
+        }
+    }
+
+    public void notifyUpgradeUnloaded(ChunkStep step) {
+        for (int i = step.getIndex(); i < this.listeners.length(); i++) {
+            ChunkListener listener = this.listeners.getAndSet(i, null);
+            if (listener != null) {
+                listener.completeErr();
+            }
+        }
+
+        this.notifyUpgradeCanceled(step);
+    }
+
+    public void notifyUpgradeCanceled(ChunkStep step) {
+        this.downgradeSpawnedStep(step.getPrevious());
+    }
+
+    @Nullable
+    ChunkStep includeStep(ChunkStep step) {
+        ChunkStep currentStep = this.currentStep;
+        if (step.greaterOrEqual(currentStep)) {
+            this.currentStep = step;
+        }
+        return currentStep;
+    }
+
+    void combineSavingFuture(ChunkStep step) {
+        this.combineSavingFuture(this.getListenerFor(step).asVanilla());
+    }
+
+    void combineSavingFuture(Chunk chunk) {
+        this.combineSavingFuture(CompletableFuture.completedFuture(Either.left(chunk)));
+    }
+
+    public WorldChunk finalizeChunk(ServerWorld world, LongPredicate loadToWorld) {
+        if (this.worldChunk != null) {
+            throw new IllegalStateException("chunk already finalized!");
+        }
+
+        WorldChunk worldChunk = unwrapWorldChunk(this.chunk);
+        if (worldChunk == null) {
+            worldChunk = this.upgradeToWorldChunk(world, this.chunk);
+        }
+
+        this.worldChunk = worldChunk;
+        this.combineSavingFuture(this.worldChunk);
+
+        worldChunk.setLevelTypeProvider(() -> ChunkHolder.getLevelType(this.level));
+        worldChunk.loadToWorld();
+
+        if (loadToWorld.test(this.pos.toLong())) {
+            worldChunk.setLoadedToWorld(true);
+            world.addBlockEntities(worldChunk.getBlockEntities().values());
+
+            Collection<Entity> invalidEntities = this.tryAddEntitiesToWorld(world, worldChunk);
+            invalidEntities.forEach(worldChunk::remove);
+        }
+
+        worldChunk.disableTickSchedulers();
+
+        return worldChunk;
+    }
+
+    private WorldChunk upgradeToWorldChunk(ServerWorld world, ProtoChunk protoChunk) {
+        WorldChunk worldChunk = new WorldChunk(world, protoChunk);
+        this.chunk = new ReadOnlyChunk(worldChunk);
+
+        return worldChunk;
+    }
+
+    private Collection<Entity> tryAddEntitiesToWorld(ServerWorld world, WorldChunk chunk) {
+        Collection<Entity> invalidEntities = new ArrayList<>();
+
+        for (TypeFilterableList<Entity> entitySection : chunk.getEntitySectionArray()) {
+            for (Entity entity : entitySection) {
+                if (entity instanceof PlayerEntity) continue;
+
+                if (!world.loadEntity(entity)) {
+                    invalidEntities.add(entity);
+                }
+            }
+        }
+
+        return invalidEntities;
+    }
+
+    @Nullable
+    private static WorldChunk unwrapWorldChunk(Chunk chunk) {
+        if (chunk instanceof ReadOnlyChunk) {
+            return ((ReadOnlyChunk) chunk).getWrappedChunk();
+        }
+        return null;
+    }
+
+    public ChunkEntryTrackers getTrackers() {
+        return this.trackers;
+    }
+
+    @Override
+    protected void sendPacketToPlayersWatching(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        Set<ServerPlayerEntity> trackingPlayers = this.trackers.getTrackingPlayers();
+        if (trackingPlayers.isEmpty()) {
+            return;
+        }
+
+        if (!onlyOnWatchDistanceEdge) {
+            for (ServerPlayerEntity player : trackingPlayers) {
+                QueuingConnection.enqueueSend(player.networkHandler, packet);
+            }
+        } else {
+            // pass through TACS to filter the edge
+            Stream<ServerPlayerEntity> players = this.playersWatchingChunkProvider.getPlayersWatchingChunk(this.pos, true);
+            players.forEach(player -> QueuingConnection.enqueueSend(player.networkHandler, packet));
+        }
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<Chunk, Unloaded>> getChunkAt(ChunkStatus status, ThreadedAnvilChunkStorage tacs) {
+        return tacs.getChunk(this, status);
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<Chunk, Unloaded>> getFutureFor(ChunkStatus status) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        return this.getListenerFor(step).asVanilla();
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<Chunk, Unloaded>> getValidFutureFor(ChunkStatus status) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        return this.isValidAs(step) ? this.getFutureFor(status) : ChunkHolder.UNLOADED_CHUNK_FUTURE;
+    }
+
+    @Override
+    @Deprecated
+    protected void tick(ThreadedAnvilChunkStorage tacs) {
+        this.onUpdateLevel(tacs);
+    }
+
+    @Override
+    @Nullable
+    @Deprecated
+    public Chunk getCurrentChunk() {
+        return this.getProtoChunk();
+    }
+
+    @Override
+    @Deprecated
+    public void setCompletedChunk(ReadOnlyChunk chunk) {
+    }
+
+    // TODO: Ideally we can avoid running this logic here, and instead have it be run when we're trying to start/stop chunk tracking
+    public boolean isChunkTickable() {
+        Set<ServerPlayerEntity> players = this.trackers.getTickableTrackingPlayers();
+        if (players.isEmpty()) {
+            return false;
+        }
+
+        for (ServerPlayerEntity player : players) {
+            if (!player.isSpectator()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java
new file mode 100644
index 0000000000000000000000000000000000000000..b01358d3479bb5a6f3e0d5a5c3851339541fd8cc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java
@@ -0,0 +1,139 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.gegy1000.tictacs.chunk.tracker.ChunkEntityTracker;
+import net.minecraft.server.network.ServerPlayerEntity;
+
+import java.util.Collections;
+import java.util.Set;
+
+public final class ChunkEntryTrackers {
+    private Set<ServerPlayerEntity> trackingPlayers;
+    private Set<ServerPlayerEntity> tickableTrackingPlayers;
+    private Set<ChunkEntityTracker> entities;
+
+    public void addEntity(ChunkEntityTracker tracker) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities == null) {
+            this.entities = entities = new ReferenceOpenHashSet<>();
+        }
+        entities.add(tracker);
+    }
+
+    public boolean removeEntity(ChunkEntityTracker tracker) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null && entities.remove(tracker)) {
+            if (entities.isEmpty()) {
+                this.entities = null;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public boolean addTrackingPlayer(ServerPlayerEntity player) {
+        Set<ServerPlayerEntity> trackingPlayers = this.trackingPlayers;
+        if (trackingPlayers == null) {
+            this.trackingPlayers = trackingPlayers = new ReferenceOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        if (trackingPlayers.add(player)) {
+            this.startTrackingEntities(player);
+            return true;
+        }
+
+        return false;
+    }
+
+    public boolean removeTrackingPlayer(ServerPlayerEntity player) {
+        Set<ServerPlayerEntity> trackingPlayers = this.trackingPlayers;
+        if (trackingPlayers == null) {
+            return false;
+        }
+
+        if (trackingPlayers.remove(player)) {
+            if (trackingPlayers.isEmpty()) {
+                this.trackingPlayers = null;
+            }
+
+            this.stopTrackingEntities(player);
+            return true;
+        }
+
+        return false;
+    }
+
+    public void updateTrackingPlayer(ServerPlayerEntity player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            Set<ServerPlayerEntity> trackingPlayers = this.trackingPlayers;
+            if (trackingPlayers == null || !trackingPlayers.contains(player)) {
+                return;
+            }
+
+            for (ChunkEntityTracker entity : entities) {
+                entity.updateTracker(player);
+            }
+        }
+    }
+
+    private void startTrackingEntities(ServerPlayerEntity player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            for (ChunkEntityTracker tracker : entities) {
+                tracker.updateTrackerWatched(player);
+            }
+        }
+    }
+
+    private void stopTrackingEntities(ServerPlayerEntity player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            for (ChunkEntityTracker tracker : entities) {
+                tracker.updateTrackerUnwatched(player);
+            }
+        }
+    }
+
+    public boolean addTickableTrackingPlayer(ServerPlayerEntity player) {
+        Set<ServerPlayerEntity> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        if (tickableTrackingPlayers == null) {
+            this.tickableTrackingPlayers = tickableTrackingPlayers = new ReferenceOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        return tickableTrackingPlayers.add(player);
+    }
+
+    public boolean removeTickableTrackingPlayer(ServerPlayerEntity player) {
+        Set<ServerPlayerEntity> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        if (tickableTrackingPlayers != null && tickableTrackingPlayers.remove(player)) {
+            if (tickableTrackingPlayers.isEmpty()) {
+                this.tickableTrackingPlayers = null;
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    public Set<ServerPlayerEntity> getTrackingPlayers() {
+        Set<ServerPlayerEntity> trackingPlayers = this.trackingPlayers;
+        return trackingPlayers != null ? trackingPlayers : Collections.emptySet();
+    }
+
+    public Set<ServerPlayerEntity> getTickableTrackingPlayers() {
+        Set<ServerPlayerEntity> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        return tickableTrackingPlayers != null ? tickableTrackingPlayers : Collections.emptySet();
+    }
+
+    public boolean isTrackedBy(ServerPlayerEntity player) {
+        Set<ServerPlayerEntity> trackingPlayers = this.trackingPlayers;
+        return trackingPlayers != null && trackingPlayers.contains(player);
+    }
+
+    public Set<ChunkEntityTracker> getEntities() {
+        Set<ChunkEntityTracker> entities = this.entities;
+        return entities != null ? entities : Collections.emptySet();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..251f92a8aea266d0d1cbb40a6fb083ad3bded5c2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java
@@ -0,0 +1,70 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.chunk.future.SharedListener;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.concurrent.CompletableFuture;
+
+public final class ChunkListener extends SharedListener<Chunk> {
+    final ChunkEntry entry;
+    final ChunkStep step;
+
+    volatile boolean err;
+
+    final CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> vanilla;
+
+    ChunkListener(ChunkEntry entry, ChunkStep step) {
+        this.entry = entry;
+        this.step = step;
+
+        Chunk chunk = this.getChunkForStep();
+        if (chunk != null) {
+            this.vanilla = CompletableFuture.completedFuture(Either.left(chunk));
+        } else {
+            this.vanilla = new CompletableFuture<>();
+        }
+    }
+
+    @Nullable
+    @Override
+    protected Chunk get() {
+        if (this.err) {
+            throw ChunkNotLoadedException.INSTANCE;
+        }
+
+        return this.getChunkForStep();
+    }
+
+    public void completeOk() {
+        this.err = false;
+
+        Chunk chunk = this.getChunkForStep();
+        if (chunk == null) {
+            throw new IllegalStateException("cannot complete chunk with null chunk");
+        }
+
+        this.vanilla.complete(Either.left(chunk));
+
+        this.wake();
+    }
+
+    public void completeErr() {
+        this.err = true;
+        this.vanilla.complete(ChunkHolder.UNLOADED_CHUNK);
+
+        this.wake();
+    }
+
+    private Chunk getChunkForStep() {
+        return this.entry.getChunkForStep(this.step);
+    }
+
+    public CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> asVanilla() {
+        return this.vanilla;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java b/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf9653f401a8014855c19c64483cc7dc86ccbffa
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java
@@ -0,0 +1,43 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class AwaitAll<T> implements Future<Unit> {
+    private final Future<T>[] futures;
+
+    private AwaitAll(Future<T>[] futures) {
+        this.futures = futures;
+    }
+
+    public static <T> AwaitAll<T> of(Future<T>[] futures) {
+        return new AwaitAll<>(futures);
+    }
+
+    @Nullable
+    @Override
+    public Unit poll(Waker waker) {
+        return AwaitAll.poll(waker, this.futures) ? Unit.INSTANCE : null;
+    }
+
+    public static <T> boolean poll(Waker waker, Future<T>[] futures) {
+        boolean ready = true;
+
+        for (int i = 0; i < futures.length; i++) {
+            Future<T> future = futures[i];
+            if (future == null) continue;
+
+            T result = future.poll(waker);
+            if (result != null) {
+                futures[i] = null;
+            } else {
+                ready = false;
+            }
+        }
+
+        return ready;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d63400c2423ac5dd1b5217bb5841dd1e11a1b2b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java
@@ -0,0 +1,25 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class ChunkNotLoadedFuture<T> implements Future<T> {
+    private static final ChunkNotLoadedFuture<?> INSTANCE = new ChunkNotLoadedFuture<>();
+
+    private ChunkNotLoadedFuture() {
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> ChunkNotLoadedFuture<T> get() {
+        return (ChunkNotLoadedFuture<T>) INSTANCE;
+    }
+
+    @Nullable
+    @Override
+    public T poll(Waker waker) {
+        throw ChunkNotLoadedException.INSTANCE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java b/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea730817250a03a2b5164441eb4d4cc4a0b55b58
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java
@@ -0,0 +1,27 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class FutureHandle<T> implements Future<T> {
+    private volatile T value;
+    private volatile Waker waker;
+
+    @Nullable
+    @Override
+    public T poll(Waker waker) {
+        this.waker = waker;
+        return this.value;
+    }
+
+    public void complete(T value) {
+        this.value = value;
+
+        Waker waker = this.waker;
+        if (waker != null) {
+            waker.wake();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java b/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java
new file mode 100644
index 0000000000000000000000000000000000000000..2561afc5652b611eebd7a8715f7130d8ad14e6b1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java
@@ -0,0 +1,41 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class JoinAllArray<T> implements Future<T[]> {
+    private final Future<T>[] futures;
+    private final T[] results;
+
+    public JoinAllArray(Future<T>[] futures, T[] results) {
+        this.futures = futures;
+        this.results = results;
+    }
+
+    @Nullable
+    @Override
+    public T[] poll(Waker waker) {
+        return JoinAllArray.poll(waker, this.futures, this.results);
+    }
+
+    public static <T> T[] poll(Waker waker, Future<T>[] futures, T[] results) {
+        boolean pending = false;
+
+        for (int i = 0; i < futures.length; i++) {
+            Future<T> future = futures[i];
+            if (future == null) continue;
+
+            T result = future.poll(waker);
+            if (result != null) {
+                futures[i] = null;
+                results[i] = result;
+            } else {
+                pending = true;
+            }
+        }
+
+        return pending ? null : results;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dad8d3173495ba8e457ddc39e8cdd051b5fb91f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java
@@ -0,0 +1,19 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+
+public final class LazyRunnableFuture implements Future<Unit> {
+    private final Runnable runnable;
+
+    public LazyRunnableFuture(Runnable runnable) {
+        this.runnable = runnable;
+    }
+
+    @Override
+    public Unit poll(Waker waker) {
+        this.runnable.run();
+        return Unit.INSTANCE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java b/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd8e013fe376ca241aefc2d7016cac58be9f490e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java
@@ -0,0 +1,37 @@
+package net.gegy1000.tictacs.chunk.future;
+
+public final class Result<T> {
+    private static final Object ERROR_VALUE = new Object();
+    private static final Result<?> ERROR = new Result<>(ERROR_VALUE);
+
+    private final Object value;
+
+    private Result(Object value) {
+        this.value = value;
+    }
+
+    public static <T> Result<T> ok(T result) {
+        return new Result<>(result);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> Result<T> error() {
+        return (Result<T>) ERROR;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T get() {
+        if (this.value == ERROR_VALUE) {
+            throw new RuntimeException("result is error");
+        }
+        return (T) this.value;
+    }
+
+    public boolean isOk() {
+        return this.value != ERROR_VALUE;
+    }
+
+    public boolean isError() {
+        return this.value == ERROR_VALUE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java b/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..0879e7892a49363381b678274a3d12b94e6537ee
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java
@@ -0,0 +1,41 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+
+import org.jetbrains.annotations.Nullable;
+
+public abstract class SharedListener<T> implements Future<T> {
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    @Nullable
+    protected abstract T get();
+
+    protected final void wake() {
+        this.waiters.wake();
+    }
+
+    @Nullable
+    @Override
+    public final T poll(Waker waker) {
+        T value = this.get();
+        if (value != null) {
+            return value;
+        }
+
+        LinkedWaiter waiter = new LinkedWaiter();
+        this.waiters.registerWaiter(waiter, waker);
+
+        // try get the value again in case one was set before we registered our waker
+        value = this.get();
+        if (value != null) {
+            // if a value was set while we were registering, we can invalidate that waker now
+            waiter.invalidateWaker();
+            return value;
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba3c447c0c4082006298460773308afffc61e6c6
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java
@@ -0,0 +1,64 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.AtomicPool;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+public final class VanillaChunkFuture implements Future<Chunk> {
+    private static final AtomicPool<VanillaChunkFuture> POOL = new AtomicPool<>(512, VanillaChunkFuture::new);
+
+    private volatile CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> inner;
+    private volatile boolean listening;
+
+    private VanillaChunkFuture() {
+    }
+
+    public static VanillaChunkFuture of(CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> completable) {
+        VanillaChunkFuture future = POOL.acquire();
+        future.init(completable);
+        return future;
+    }
+
+    void init(CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> future) {
+        this.inner = future;
+        this.listening = false;
+    }
+
+    @Nullable
+    @Override
+    public Chunk poll(Waker waker) {
+        Either<Chunk, ChunkHolder.Unloaded> result = this.inner.getNow(null);
+        if (result != null) {
+            Optional<ChunkHolder.Unloaded> err = result.right();
+            if (err.isPresent()) {
+                throw ChunkNotLoadedException.INSTANCE;
+            }
+
+            Chunk chunk = result.left().get();
+            this.release();
+
+            return chunk;
+        } else if (!this.listening) {
+            this.listening = true;
+            this.inner.handle((r, t) -> {
+                waker.wake();
+                return null;
+            });
+        }
+
+        return null;
+    }
+
+    private void release() {
+        this.inner = null;
+        POOL.release(this);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java
new file mode 100644
index 0000000000000000000000000000000000000000..637d2365b2f570f12a6d74e7d64aef76f31cf85a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java
@@ -0,0 +1,516 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import com.google.common.base.Preconditions;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import net.fabricmc.fabric.api.util.NbtType;
+import net.gegy1000.tictacs.PoiStorageAccess;
+import net.gegy1000.tictacs.compatibility.TicTacsCompatibility;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockState;
+import net.minecraft.block.entity.BlockEntity;
+import net.minecraft.entity.EntityType;
+import net.minecraft.fluid.Fluid;
+import net.minecraft.fluid.Fluids;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.SimpleTickScheduler;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.structure.StructureStart;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.registry.DynamicRegistryManager;
+import net.minecraft.util.registry.MutableRegistry;
+import net.minecraft.util.registry.Registry;
+import net.minecraft.world.ChunkTickScheduler;
+import net.minecraft.world.Heightmap;
+import net.minecraft.world.TickScheduler;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.Biome;
+import net.minecraft.world.biome.source.BiomeArray;
+import net.minecraft.world.biome.source.BiomeSource;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkSection;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.chunk.ReadOnlyChunk;
+import net.minecraft.world.chunk.UpgradeData;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.chunk.light.LightingProvider;
+import net.minecraft.world.gen.GenerationStep;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+import net.minecraft.world.gen.feature.StructureFeature;
+import net.minecraft.world.poi.PointOfInterestStorage;
+import net.minecraft.world.poi.PointOfInterestType;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.function.Consumer;
+import java.util.stream.LongStream;
+
+public final class ChunkData {
+    private static final Logger LOGGER = LogManager.getLogger(ChunkData.class);
+
+    private static final int STARLIGHT_LIGHT_VERSION = 1;
+
+    private final ChunkPos pos;
+    private final ChunkStatus status;
+    private final long inhabitedTime;
+    private final UpgradeData upgradeData;
+
+    @Nullable
+    private final int[] biomeIds;
+
+    private final ChunkSection[] sections;
+    private final boolean[] sectionHasPois;
+
+    private final ChunkLightData lightData;
+    private final boolean lightOn;
+
+    private final Map<Heightmap.Type, long[]> heightmaps;
+
+    private final TickScheduler<Block> blockTickScheduler;
+    private final TickScheduler<Fluid> fluidTickScheduler;
+    private final List<BlockPos> blocksForPostProcessing;
+
+    private final List<CompoundTag> entityTags;
+    private final List<CompoundTag> blockEntityTags;
+
+    private final Map<StructureFeature<?>, CompoundTag> structureStarts;
+    private final Map<StructureFeature<?>, LongSet> structureReferences;
+
+    private final boolean shouldSave;
+
+    @Nullable
+    private final ProtoData protoData;
+
+    private ChunkData(
+            ChunkPos pos, ChunkStatus status,
+            long inhabitedTime, UpgradeData upgradeData,
+            @Nullable int[] biomeIds, ChunkSection[] sections,
+            boolean[] sectionHasPois,
+            ChunkLightData lightData, boolean lightOn,
+            Map<Heightmap.Type, long[]> heightmaps,
+            TickScheduler<Block> blockTickScheduler, TickScheduler<Fluid> fluidTickScheduler,
+            List<BlockPos> blocksForPostProcessing,
+            List<CompoundTag> entityTags, List<CompoundTag> blockEntityTags,
+            Map<StructureFeature<?>, CompoundTag> structureStarts,
+            Map<StructureFeature<?>, LongSet> structureReferences,
+            boolean shouldSave,
+            @Nullable ProtoData protoData
+    ) {
+        this.pos = pos;
+        this.status = status;
+        this.inhabitedTime = inhabitedTime;
+        this.upgradeData = upgradeData;
+        this.biomeIds = biomeIds;
+        this.sections = sections;
+        this.sectionHasPois = sectionHasPois;
+        this.lightData = lightData;
+        this.lightOn = lightOn;
+        this.heightmaps = heightmaps;
+        this.blockTickScheduler = blockTickScheduler;
+        this.fluidTickScheduler = fluidTickScheduler;
+        this.blocksForPostProcessing = blocksForPostProcessing;
+        this.entityTags = entityTags;
+        this.blockEntityTags = blockEntityTags;
+        this.structureStarts = structureStarts;
+        this.structureReferences = structureReferences;
+        this.shouldSave = shouldSave;
+        this.protoData = protoData;
+    }
+
+    public static ChunkData deserialize(ChunkPos chunkPos, CompoundTag tag) {
+        CompoundTag levelTag = tag.getCompound("Level");
+
+        ChunkStatus status = ChunkStatus.byId(levelTag.getString("Status"));
+
+        ChunkPos serializedPos = new ChunkPos(levelTag.getInt("xPos"), levelTag.getInt("zPos"));
+        if (!serializedPos.equals(chunkPos)) {
+            LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", chunkPos, chunkPos, serializedPos);
+        }
+
+        int[] biomeIds = levelTag.contains("Biomes", NbtType.INT_ARRAY) ? levelTag.getIntArray("Biomes") : null;
+        UpgradeData upgradeData = levelTag.contains("UpgradeData", NbtType.COMPOUND) ? new UpgradeData(levelTag.getCompound("UpgradeData")) : UpgradeData.NO_UPGRADE_DATA;
+
+        TickScheduler<Block> blockScheduler = new ChunkTickScheduler<>(block -> {
+            return block == null || block.getDefaultState().isAir();
+        }, chunkPos, levelTag.getList("ToBeTicked", NbtType.LIST));
+
+        TickScheduler<Fluid> fluidScheduler = new ChunkTickScheduler<>(fluid -> {
+            return fluid == null || fluid == Fluids.EMPTY;
+        }, chunkPos, levelTag.getList("LiquidsToBeTicked", NbtType.LIST));
+
+        ChunkSection[] sections = new ChunkSection[16];
+        boolean[] sectionHasPois = new boolean[16];
+
+        boolean lightOn = levelTag.getBoolean("isLightOn");
+
+        ChunkLightData lightData;
+
+        if (TicTacsCompatibility.STARLIGHT_LOADED) {
+            lightData = new StarlightChunkLightData();
+            lightOn = levelTag.getInt("starlight.light_versiom") == STARLIGHT_LIGHT_VERSION;
+        } else {
+            lightData = new VanillaChunkLightData();
+        }
+
+        ListTag sectionsList = levelTag.getList("Sections", NbtType.COMPOUND);
+
+        for (int i = 0; i < sectionsList.size(); i++) {
+            CompoundTag sectionTag = sectionsList.getCompound(i);
+            int sectionY = sectionTag.getByte("Y");
+
+            if (sectionTag.contains("Palette", NbtType.LIST) && sectionTag.contains("BlockStates", NbtType.LONG_ARRAY)) {
+                ChunkSection section = new ChunkSection(sectionY << 4);
+
+                ListTag palette = sectionTag.getList("Palette", NbtType.COMPOUND);
+                long[] data = sectionTag.getLongArray("BlockStates");
+                section.getContainer().read(palette, data);
+
+                section.calculateCounts();
+
+                if (!section.isEmpty()) {
+                    sections[sectionY] = section;
+                    sectionHasPois[sectionY] = section.hasAny(PointOfInterestType.REGISTERED_STATES::contains);
+                }
+            }
+
+            if (lightOn) {
+                lightData.acceptSection(sectionY, sectionTag, status);
+            }
+        }
+
+        ChunkStatus.ChunkType chunkType = status.getChunkType();
+
+        List<CompoundTag> entityTags = new ArrayList<>();
+        List<CompoundTag> blockEntityTags = new ArrayList<>();
+
+        ListTag entitiesList = levelTag.getList("Entities", NbtType.COMPOUND);
+        for (int i = 0; i < entitiesList.size(); i++) {
+            entityTags.add(entitiesList.getCompound(i));
+        }
+
+        ListTag blockEntitiesList = levelTag.getList("TileEntities", NbtType.COMPOUND);
+        for (int i = 0; i < blockEntitiesList.size(); i++) {
+            blockEntityTags.add(blockEntitiesList.getCompound(i));
+        }
+
+        if (chunkType == ChunkStatus.ChunkType.field_12807) {
+            if (levelTag.contains("TileTicks", NbtType.LIST)) {
+                blockScheduler = SimpleTickScheduler.fromNbt(levelTag.getList("TileTicks", NbtType.COMPOUND), Registry.BLOCK::getId, Registry.BLOCK::get);
+            }
+
+            if (levelTag.contains("LiquidTicks", NbtType.LIST)) {
+                fluidScheduler = SimpleTickScheduler.fromNbt(levelTag.getList("LiquidTicks", NbtType.COMPOUND), Registry.FLUID::getId, Registry.FLUID::get);
+            }
+        }
+
+        CompoundTag heightmapsTag = levelTag.getCompound("Heightmaps");
+
+        Map<Heightmap.Type, long[]> heightmaps = new EnumMap<>(Heightmap.Type.class);
+        for (Heightmap.Type type : status.getHeightmapTypes()) {
+            String name = type.getName();
+            if (heightmapsTag.contains(name, NbtType.LONG_ARRAY)) {
+                heightmaps.put(type, heightmapsTag.getLongArray(name));
+            }
+        }
+
+        CompoundTag structuresTag = levelTag.getCompound("Structures");
+        Map<StructureFeature<?>, CompoundTag> structureStarts = deserializeStructureStarts(structuresTag);
+        Map<StructureFeature<?>, LongSet> structureReferences = deserializeStructureReferences(chunkPos, structuresTag);
+
+        List<BlockPos> blocksForPostProcessing = new ArrayList<>();
+
+        ListTag postProcessingList = levelTag.getList("PostProcessing", NbtType.LIST);
+        for (int sectionY = 0; sectionY < postProcessingList.size(); sectionY++) {
+            ListTag queueList = postProcessingList.getList(sectionY);
+            for (int i = 0; i < queueList.size(); i++) {
+                BlockPos pos = ProtoChunk.joinBlockPos(queueList.getShort(sectionY), sectionY, chunkPos);
+                blocksForPostProcessing.add(pos);
+            }
+        }
+
+        ProtoData protoData = null;
+        if (chunkType == ChunkStatus.ChunkType.field_12808) {
+            protoData = deserializeProtoData(chunkPos, levelTag, status, sections, lightOn);
+        }
+
+        long inhabitedTime = levelTag.getLong("InhabitedTime");
+        boolean shouldSave = levelTag.getBoolean("shouldSave");
+
+        return new ChunkData(
+                chunkPos, status,
+                inhabitedTime, upgradeData,
+                biomeIds, sections, sectionHasPois,
+                lightData, lightOn,
+                heightmaps, blockScheduler, fluidScheduler,
+                blocksForPostProcessing, entityTags, blockEntityTags,
+                structureStarts, structureReferences,
+                shouldSave,
+                protoData
+        );
+    }
+
+    private static Map<StructureFeature<?>, CompoundTag> deserializeStructureStarts(CompoundTag tag) {
+        Map<StructureFeature<?>, CompoundTag> starts = new Object2ObjectOpenHashMap<>();
+
+        CompoundTag startsTag = tag.getCompound("Starts");
+
+        for (String key : startsTag.getKeys()) {
+            StructureFeature<?> feature = StructureFeature.STRUCTURES.get(key.toLowerCase(Locale.ROOT));
+            if (feature == null) {
+                LOGGER.error("Unknown structure start: {}", key);
+                continue;
+            }
+
+            starts.put(feature, startsTag.getCompound(key));
+        }
+
+        return starts;
+    }
+
+    private static Map<StructureFeature<?>, LongSet> deserializeStructureReferences(ChunkPos pos, CompoundTag tag) {
+        Map<StructureFeature<?>, LongSet> references = new Object2ObjectOpenHashMap<>();
+        CompoundTag referencesTag = tag.getCompound("References");
+
+        for (String key : referencesTag.getKeys()) {
+            StructureFeature<?> feature = StructureFeature.STRUCTURES.get(key.toLowerCase(Locale.ROOT));
+
+            LongStream referenceStream = Arrays.stream(referencesTag.getLongArray(key)).filter(reference -> {
+                ChunkPos chunkPos = new ChunkPos(reference);
+                if (chunkPos.method_24022(pos) > 8) {
+                    LOGGER.warn("Found invalid structure reference [{} @ {}] for chunk {}", key, chunkPos, pos);
+                    return false;
+                }
+                return true;
+            });
+
+            references.put(feature, new LongOpenHashSet(referenceStream.toArray()));
+        }
+
+        return references;
+    }
+
+    private static ProtoData deserializeProtoData(ChunkPos chunkPos, CompoundTag levelTag, ChunkStatus status, ChunkSection[] sections, boolean lightOn) {
+        List<BlockPos> lightSources = new ArrayList<>();
+
+        ListTag lightSectionList = levelTag.getList("Lights", NbtType.LIST);
+        for (int sectionY = 0; sectionY < lightSectionList.size(); sectionY++) {
+            ListTag lightList = lightSectionList.getList(sectionY);
+            for (int i = 0; i < lightList.size(); i++) {
+                lightSources.add(ProtoChunk.joinBlockPos(lightList.getShort(i), sectionY, chunkPos));
+            }
+        }
+
+        Map<GenerationStep.Carver, BitSet> carvingMasks = new EnumMap<>(GenerationStep.Carver.class);
+
+        CompoundTag carvingMasksTag = levelTag.getCompound("CarvingMasks");
+        for (String key : carvingMasksTag.getKeys()) {
+            GenerationStep.Carver carver = GenerationStep.Carver.valueOf(key);
+            carvingMasks.put(carver, BitSet.valueOf(carvingMasksTag.getByteArray(key)));
+        }
+
+        if (!lightOn && status.isAtLeast(ChunkStatus.LIGHT)) {
+            for (BlockPos pos : BlockPos.iterate(0, 0, 0, 15, 255, 15)) {
+                ChunkSection section = sections[pos.getY() >> 4];
+                if (section == null) {
+                    continue;
+                }
+
+                BlockState state = section.getBlockState(pos.getX(), pos.getY() & 15, pos.getZ());
+                if (state.getLuminance() != 0) {
+                    lightSources.add(new BlockPos(
+                            chunkPos.getStartX() + pos.getX(),
+                            pos.getY(),
+                            chunkPos.getStartZ() + pos.getZ()
+                    ));
+                }
+            }
+        }
+
+        return new ProtoData(lightSources, carvingMasks);
+    }
+
+    public Chunk createChunk(ServerWorld world, StructureManager structures, PointOfInterestStorage poi) {
+        DynamicRegistryManager registryManager = world.getRegistryManager();
+        ServerChunkManager chunkManager = world.getChunkManager();
+        ChunkGenerator chunkGenerator = chunkManager.getChunkGenerator();
+        LightingProvider lightingProvider = chunkManager.getLightingProvider();
+        BiomeSource biomeSource = chunkGenerator.getBiomeSource();
+
+        BiomeArray biomes = null;
+        if (this.biomeIds != null || this.status.isAtLeast(ChunkStatus.BIOMES)) {
+            MutableRegistry<Biome> biomeRegistry = registryManager.get(Registry.BIOME_KEY);
+            biomes = new BiomeArray(biomeRegistry, this.pos, biomeSource, this.biomeIds);
+        }
+
+        this.lightData.applyToWorld(this.pos, world);
+
+        ChunkStatus.ChunkType chunkType = this.status.getChunkType();
+
+        Chunk chunk;
+        ProtoChunk protoChunk;
+
+        if (chunkType == ChunkStatus.ChunkType.field_12807) {
+            WorldChunk worldChunk = this.createWorldChunk(world, biomes);
+            chunk = worldChunk;
+            protoChunk = new ReadOnlyChunk(worldChunk);
+        } else {
+            protoChunk = this.createProtoChunk(lightingProvider, biomes);
+            chunk = protoChunk;
+        }
+
+        for (int sectionY = 0; sectionY < this.sectionHasPois.length; sectionY++) {
+            if (this.sectionHasPois[sectionY]) {
+                ((PoiStorageAccess) poi).initSectionWithPois(this.pos, this.sections[sectionY]);
+            }
+        }
+
+        this.populateStructures(chunk, structures, world.getSeed());
+        this.populateHeightmaps(chunk);
+
+        if (this.shouldSave) {
+            chunk.setShouldSave(true);
+        }
+
+        for (BlockPos pos : this.blocksForPostProcessing) {
+            chunk.markBlockForPostProcessing(ProtoChunk.getPackedSectionRelative(pos), pos.getY() >> 4);
+        }
+
+        protoChunk.setLightOn(this.lightOn);
+
+        this.lightData.applyToChunk(protoChunk);
+
+        return protoChunk;
+    }
+
+    private void populateHeightmaps(Chunk chunk) {
+        if (!this.status.isAtLeast(ChunkStatus.NOISE)) {
+            return;
+        }
+
+        EnumSet<Heightmap.Type> missingHeightmaps = EnumSet.noneOf(Heightmap.Type.class);
+        for (Heightmap.Type type : this.status.getHeightmapTypes()) {
+            long[] heightmap = this.heightmaps.get(type);
+            if (heightmap != null) {
+                chunk.setHeightmap(type, heightmap);
+            } else {
+                missingHeightmaps.add(type);
+            }
+        }
+
+        if (!missingHeightmaps.isEmpty()) {
+            Heightmap.populateHeightmaps(chunk, missingHeightmaps);
+        }
+    }
+
+    private void populateStructures(Chunk chunk, StructureManager structures, long worldSeed) {
+        Map<StructureFeature<?>, StructureStart<?>> structureStarts = new Object2ObjectOpenHashMap<>();
+        for (Map.Entry<StructureFeature<?>, CompoundTag> entry : this.structureStarts.entrySet()) {
+            StructureStart<?> start = StructureFeature.readStructureStart(structures, entry.getValue(), worldSeed);
+            if (start != null) {
+                structureStarts.put(entry.getKey(), start);
+            }
+        }
+
+        chunk.setStructureStarts(structureStarts);
+        chunk.setStructureReferences(this.structureReferences);
+    }
+
+    private WorldChunk createWorldChunk(ServerWorld world, BiomeArray biomes) {
+        List<CompoundTag> entityTags = this.entityTags;
+        List<CompoundTag> blockEntityTags = this.blockEntityTags;
+        Consumer<WorldChunk> loadToWorld = worldChunk -> addEntitiesToWorldChunk(worldChunk, entityTags, blockEntityTags);
+
+        return new WorldChunk(
+                world, this.pos, biomes, this.upgradeData,
+                this.blockTickScheduler, this.fluidTickScheduler,
+                this.inhabitedTime,
+                this.sections,
+                loadToWorld
+        );
+    }
+
+    private ProtoChunk createProtoChunk(LightingProvider lightingProvider, BiomeArray biomes) {
+        ProtoChunk chunk = new ProtoChunk(
+                this.pos, this.upgradeData,
+                this.sections,
+                (ChunkTickScheduler<Block>) this.blockTickScheduler,
+                (ChunkTickScheduler<Fluid>) this.fluidTickScheduler
+        );
+
+        chunk.setBiomes(biomes);
+        chunk.setInhabitedTime(this.inhabitedTime);
+        chunk.setStatus(this.status);
+
+        if (this.status.isAtLeast(ChunkStatus.FEATURES)) {
+            chunk.setLightingProvider(lightingProvider);
+        }
+
+        for (CompoundTag tag : this.entityTags) {
+            chunk.addEntity(tag);
+        }
+
+        for (CompoundTag tag : this.blockEntityTags) {
+            chunk.addPendingBlockEntityTag(tag);
+        }
+
+        Preconditions.checkNotNull(this.protoData, "loaded no proto data for ProtoChunk");
+
+        for (BlockPos pos : this.protoData.lightSources) {
+            chunk.addLightSource(pos);
+        }
+
+        for (Map.Entry<GenerationStep.Carver, BitSet> entry : this.protoData.carvingMasks.entrySet()) {
+            chunk.setCarvingMask(entry.getKey(), entry.getValue());
+        }
+
+        return chunk;
+    }
+
+    private static void addEntitiesToWorldChunk(WorldChunk chunk, List<CompoundTag> entityTags, List<CompoundTag> blockEntityTags) {
+        World world = chunk.getWorld();
+        for (CompoundTag tag : entityTags) {
+            EntityType.loadEntityWithPassengers(tag, world, entity -> {
+                chunk.addEntity(entity);
+                return entity;
+            });
+            chunk.setUnsaved(true);
+        }
+
+        for (CompoundTag tag : blockEntityTags) {
+            if (!tag.getBoolean("keepPacked")) {
+                BlockPos pos = new BlockPos(tag.getInt("x"), tag.getInt("y"), tag.getInt("z"));
+                BlockEntity entity = BlockEntity.createFromTag(chunk.getBlockState(pos), tag);
+                if (entity != null) {
+                    chunk.addBlockEntity(entity);
+                }
+            } else {
+                chunk.addPendingBlockEntityTag(tag);
+            }
+        }
+    }
+
+    private static class ProtoData {
+        final List<BlockPos> lightSources;
+        final Map<GenerationStep.Carver, BitSet> carvingMasks;
+
+        ProtoData(List<BlockPos> lightSources, Map<GenerationStep.Carver, BitSet> carvingMasks) {
+            this.lightSources = lightSources;
+            this.carvingMasks = carvingMasks;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c7a91fe79bce9093488ed9897e88fff505814ca
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java
@@ -0,0 +1,15 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+
+public interface ChunkLightData {
+    void acceptSection(int sectionY, CompoundTag sectionTag, ChunkStatus status);
+
+    void applyToWorld(ChunkPos chunkPos, ServerWorld world);
+
+    void applyToChunk(ProtoChunk chunk);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8e9a96145d88a7ab78e29c7151dc4148eb5f0f8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java
@@ -0,0 +1,44 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import ca.spottedleaf.starlight.common.chunk.ExtendedChunk;
+import ca.spottedleaf.starlight.common.light.SWMRNibbleArray;
+import ca.spottedleaf.starlight.common.light.StarLightEngine;
+import net.fabricmc.fabric.api.util.NbtType;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+
+public final class StarlightChunkLightData implements ChunkLightData {
+    private final SWMRNibbleArray[] blockLightSections = StarLightEngine.getFilledEmptyLight();
+    private final SWMRNibbleArray[] skyLightSections = StarLightEngine.getFilledEmptyLight();
+
+    @Override
+    public void acceptSection(int y, CompoundTag sectionTag, ChunkStatus status) {
+        if (!status.isAtLeast(ChunkStatus.LIGHT)) {
+            return;
+        }
+
+        if (sectionTag.contains("BlockLight", NbtType.BYTE_ARRAY)) {
+            this.blockLightSections[y + 1] = new SWMRNibbleArray(sectionTag.getByteArray("BlockLight").clone());
+        }
+
+        if (sectionTag.contains("SkyLight", NbtType.BYTE_ARRAY)) {
+            this.skyLightSections[y + 1] = new SWMRNibbleArray(sectionTag.getByteArray("SkyLight").clone());
+        } else if (sectionTag.getBoolean("starlight.skylight_uninit")) {
+            this.skyLightSections[y + 1] = new SWMRNibbleArray();
+        }
+    }
+
+    @Override
+    public void applyToWorld(ChunkPos chunkPos, ServerWorld world) {
+    }
+
+    @Override
+    public void applyToChunk(ProtoChunk chunk) {
+        ExtendedChunk nibbledChunk = (ExtendedChunk) chunk;
+        nibbledChunk.setBlockNibbles(this.blockLightSections);
+        nibbledChunk.setSkyNibbles(this.skyLightSections);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/VanillaChunkLightData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/VanillaChunkLightData.java
new file mode 100644
index 0000000000000000000000000000000000000000..a338bd01d8b7f62de4c2ffe677cf0ebc46857567
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/VanillaChunkLightData.java
@@ -0,0 +1,77 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import net.fabricmc.fabric.api.util.NbtType;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.ChunkSectionPos;
+import net.minecraft.world.LightType;
+import net.minecraft.world.chunk.ChunkNibbleArray;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.chunk.light.LightingProvider;
+
+public final class VanillaChunkLightData implements ChunkLightData {
+    private ChunkNibbleArray[] blockLightSections;
+    private ChunkNibbleArray[] skyLightSections;
+
+    @Override
+    public void acceptSection(int sectionY, CompoundTag sectionTag, ChunkStatus status) {
+        if (sectionTag.contains("BlockLight", NbtType.BYTE_ARRAY)) {
+            this.putBlockSection(sectionY, sectionTag.getByteArray("BlockLight"));
+        }
+
+        if (sectionTag.contains("SkyLight", NbtType.BYTE_ARRAY)) {
+            this.putSkySection(sectionY, sectionTag.getByteArray("SkyLight"));
+        }
+    }
+
+    private void putBlockSection(int y, byte[] data) {
+        ChunkNibbleArray[] blockLightSections = this.blockLightSections;
+        if (blockLightSections == null) {
+            this.blockLightSections = blockLightSections = new ChunkNibbleArray[18];
+        }
+
+        blockLightSections[y + 1] = new ChunkNibbleArray(data);
+    }
+
+    private void putSkySection(int y, byte[] data) {
+        ChunkNibbleArray[] skyLightSections = this.skyLightSections;
+        if (skyLightSections == null) {
+            this.skyLightSections = skyLightSections = new ChunkNibbleArray[18];
+        }
+
+        skyLightSections[y + 1] = new ChunkNibbleArray(data);
+    }
+
+    @Override
+    public void applyToWorld(ChunkPos chunkPos, ServerWorld world) {
+        ChunkNibbleArray[] blockLightSections = this.blockLightSections;
+        ChunkNibbleArray[] skyLightSections = this.skyLightSections;
+        if (blockLightSections == null && skyLightSections == null) {
+            return;
+        }
+
+        LightingProvider lightingProvider = world.getChunkManager().getLightingProvider();
+        lightingProvider.setRetainData(chunkPos, true);
+
+        boolean hasSkylight = world.getDimension().hasSkyLight();
+        for (int sectionY = -1; sectionY < 17; sectionY++) {
+            ChunkSectionPos sectionPos = ChunkSectionPos.from(chunkPos, sectionY);
+
+            ChunkNibbleArray blockLight = blockLightSections != null ? blockLightSections[sectionY + 1] : null;
+            if (blockLight != null) {
+                lightingProvider.enqueueSectionData(LightType.BLOCK, sectionPos, blockLight, true);
+            }
+
+            ChunkNibbleArray skyLight = skyLightSections != null ? skyLightSections[sectionY + 1] : null;
+            if (hasSkylight && skyLight != null) {
+                lightingProvider.enqueueSectionData(LightType.SKY, sectionPos, skyLight, true);
+            }
+        }
+    }
+
+    @Override
+    public void applyToChunk(ProtoChunk chunk) {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b9392beff5ed1dadda994e65ad2ca7318eafeb9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java
@@ -0,0 +1,47 @@
+package net.gegy1000.tictacs.chunk.step;
+
+public final class ChunkRequirement {
+    public final ChunkStep step;
+    public final boolean read;
+    public final boolean write;
+
+    ChunkRequirement(ChunkStep step, boolean read, boolean write) {
+        this.step = step;
+        this.read = read;
+        this.write = write;
+    }
+
+    public static ChunkRequirement write(ChunkStep step) {
+        return new ChunkRequirement(step, true, true);
+    }
+
+    public static ChunkRequirement read(ChunkStep step) {
+        return new ChunkRequirement(step, true, false);
+    }
+
+    public static ChunkRequirement require(ChunkStep step) {
+        return new ChunkRequirement(step, false, false);
+    }
+
+    public static ChunkRequirement merge(ChunkRequirement a, ChunkRequirement b) {
+        if (a == null) return b;
+        if (b == null) return a;
+
+        ChunkStep step = ChunkStep.max(a.step, b.step);
+        boolean read = a.read || b.read;
+        boolean write = a.write || b.write;
+
+        return new ChunkRequirement(step, read, write);
+    }
+
+    @Override
+    public String toString() {
+        if (this.write) {
+            return "ChunkRequirement{write@" + this.step + "}";
+        } else if (this.read) {
+            return "ChunkRequirement{read@" + this.step + "}";
+        } else {
+            return "ChunkRequirement@" + this.step;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java
new file mode 100644
index 0000000000000000000000000000000000000000..94ee39217e8dab00c3ac007f65434df7bb302fa7
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java
@@ -0,0 +1,65 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+
+public final class ChunkRequirements {
+    private ChunkRequirement[] byDistance = new ChunkRequirement[0];
+    private int radius;
+
+    private ChunkRequirements() {
+    }
+
+    public static ChunkRequirements none() {
+        return new ChunkRequirements();
+    }
+
+    public static ChunkRequirements from(ChunkStep step) {
+        return new ChunkRequirements().write(step, 0);
+    }
+
+    public ChunkRequirements read(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.read(step), radius);
+    }
+
+    public ChunkRequirements write(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.write(step), radius);
+    }
+
+    public ChunkRequirements require(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.require(step), radius);
+    }
+
+    public ChunkRequirements add(ChunkRequirement requirement, int radius) {
+        this.ensureRadius(radius);
+
+        for (int i = 0; i <= radius; i++) {
+            ChunkRequirement existing = this.byDistance[i];
+            this.byDistance[i] = ChunkRequirement.merge(existing, requirement);
+        }
+
+        return this;
+    }
+
+    private void ensureRadius(int radius) {
+        if (this.byDistance.length <= radius) {
+            this.byDistance = Arrays.copyOf(this.byDistance, radius + 1);
+            this.radius = Math.max(this.byDistance.length - 1, 0);
+        }
+    }
+
+    @Nullable
+    public ChunkRequirement byDistance(int distance) {
+        distance = Math.max(distance, 0);
+
+        if (distance >= this.byDistance.length) {
+            return null;
+        }
+
+        return this.byDistance[distance];
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java
new file mode 100644
index 0000000000000000000000000000000000000000..159dac342eaff715f7c58935858c615b3ec8fd6b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java
@@ -0,0 +1,449 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+import net.gegy1000.tictacs.chunk.future.FutureHandle;
+import net.gegy1000.tictacs.compatibility.TicTacsCompatibility;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import net.gegy1000.tictacs.mixin.TacsAccessor;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.registry.Registry;
+import net.minecraft.world.ChunkRegion;
+import net.minecraft.world.Heightmap;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.gen.GenerationStep;
+import net.minecraft.world.gen.GeneratorOptions;
+import net.minecraft.world.gen.StructureAccessor;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+
+// TODO: separate loading chunk steps and generation chunk steps
+//       allow arbitrary tasks to be attached to steps
+public final class ChunkStep {
+    private static final EnumSet<Heightmap.Type> REQUIRED_FEATURE_HEIGHTMAPS = EnumSet.of(
+            Heightmap.Type.MOTION_BLOCKING,
+            Heightmap.Type.MOTION_BLOCKING_NO_LEAVES,
+            Heightmap.Type.OCEAN_FLOOR,
+            Heightmap.Type.WORLD_SURFACE
+    );
+
+    public static final List<ChunkStep> STEPS = new ArrayList<>();
+
+    public static final ChunkStep EMPTY = new ChunkStep("empty")
+            .includes(ChunkStatus.EMPTY)
+            .locks(ChunkLockType.EARLY_GENERATION)
+            .requires(ChunkRequirements.none());
+
+    public static final ChunkStep STRUCTURE_STARTS = new ChunkStep("structure_starts")
+            .includes(ChunkStatus.STRUCTURE_STARTS)
+            .locks(ChunkLockType.EARLY_GENERATION)
+            .requires(ChunkRequirements.from(ChunkStep.EMPTY))
+            .upgradeSync(ChunkStep::addStructureStarts);
+
+    public static final ChunkStep SURFACE = new ChunkStep("surface")
+            .includes(
+                    ChunkStatus.STRUCTURE_REFERENCES, ChunkStatus.BIOMES,
+                    ChunkStatus.NOISE, ChunkStatus.SURFACE,
+                    ChunkStatus.CARVERS, ChunkStatus.LIQUID_CARVERS
+            )
+            .locks(ChunkLockType.LATE_GENERATION)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.STRUCTURE_STARTS)
+                            .read(ChunkStep.STRUCTURE_STARTS, 8)
+            )
+            .upgradeSync(ChunkStep::generateSurface);
+
+    public static final ChunkStep FEATURES = new ChunkStep("features")
+            .includes(ChunkStatus.FEATURES)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.SURFACE)
+                            // Feature gen radius is controlled by the config, it's usually 2 but can be higher.
+                            .write(ChunkStep.SURFACE, TicTacsConfig.get().featureGenerationRadius)
+                            .read(ChunkStep.STRUCTURE_STARTS, 8)
+            )
+            .locks(ChunkLockType.LATE_GENERATION)
+            .upgradeAsync(ChunkStep::addFeatures)
+            .loadAsync(ChunkStep::loadFeatures);
+
+    public static final ChunkStep LIGHTING = new ChunkStep("lighting")
+            .includes(ChunkStatus.LIGHT)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.FEATURES)
+                            .read(ChunkStep.FEATURES, 1)
+                            .require(ChunkStep.FEATURES, 1 + TicTacsConfig.get().featureGenerationRadius)
+            )
+            .locks(ChunkLockType.FINALIZATION)
+            .acquire(ChunkStep::acquireLight)
+            .release(ChunkStep::releaseLight)
+            .upgradeAsync(ctx -> ChunkStep.lightChunk(ctx, false))
+            .loadAsync(ctx -> ChunkStep.lightChunk(ctx, true));
+
+    public static final ChunkStep FULL = new ChunkStep("full")
+            .includes(ChunkStatus.SPAWN, ChunkStatus.HEIGHTMAPS, ChunkStatus.FULL)
+            .requires(ChunkRequirements.from(ChunkStep.LIGHTING))
+            .locks(ChunkLockType.FINALIZATION)
+            .upgradeAsync(ctx -> {
+                ChunkStep.addEntities(ctx);
+                return ChunkStep.makeFull(ctx);
+            })
+            .loadAsync(ChunkStep::makeFull);
+
+    public static final ChunkStep GENERATION = ChunkStep.LIGHTING.getPrevious();
+    public static final ChunkStep MIN_WITH_LOAD_TASK = TicTacsCompatibility.PHOSPHOR_LOADED ? ChunkStep.FEATURES : ChunkStep.LIGHTING;
+
+    private static final ChunkStep[] STATUS_TO_STEP;
+
+    private static final int[] STEP_TO_RADIUS;
+
+    private static final int MAX_DISTANCE;
+    private static final int[] STEP_TO_DISTANCE;
+    private static final ChunkStep[] DISTANCE_TO_STEP;
+
+    private final int index;
+    private final String name;
+    private ChunkStatus[] statuses = new ChunkStatus[0];
+    private ChunkLockType lock;
+    private ChunkRequirements requirements = ChunkRequirements.none();
+
+    private AsyncTask upgradeTask = AsyncTask.noop();
+    private AsyncTask loadTask = AsyncTask.noop();
+    private Acquire acquireTask;
+    private Release releaseTask;
+
+    ChunkStep(String name) {
+        int index = STEPS.size();
+        STEPS.add(this);
+
+        this.index = index;
+        this.name = name;
+    }
+
+    ChunkStep includes(ChunkStatus... statuses) {
+        this.statuses = statuses;
+        return this;
+    }
+
+    ChunkStep locks(ChunkLockType lock) {
+        this.lock = lock;
+        return this;
+    }
+
+    ChunkStep requires(ChunkRequirements requirements) {
+        this.requirements = requirements;
+        return this;
+    }
+
+    ChunkStep upgradeAsync(AsyncTask task) {
+        this.upgradeTask = task;
+        return this;
+    }
+
+    ChunkStep upgradeSync(SyncTask task) {
+        this.upgradeTask = AsyncTask.from(task);
+        return this;
+    }
+
+    ChunkStep loadAsync(AsyncTask task) {
+        this.loadTask = task;
+        return this;
+    }
+
+    ChunkStep acquire(Acquire acquire) {
+        this.acquireTask = acquire;
+        return this;
+    }
+
+    ChunkStep release(Release task) {
+        this.releaseTask = task;
+        return this;
+    }
+
+    public Future<Chunk> runUpgrade(ChunkStepContext ctx) {
+        return this.upgradeTask.run(ctx);
+    }
+
+    public Future<Chunk> runLoad(ChunkStepContext ctx) {
+        return this.loadTask.run(ctx);
+    }
+
+    public ChunkRequirements getRequirements() {
+        return this.requirements;
+    }
+
+    public ChunkLockType getLock() {
+        return this.lock;
+    }
+
+    @Nullable
+    public Acquire getAcquireTask() {
+        return this.acquireTask;
+    }
+
+    @Nullable
+    public Release getReleaseTask() {
+        return this.releaseTask;
+    }
+
+    public ChunkStatus[] getStatuses() {
+        return this.statuses;
+    }
+
+    public ChunkStatus getMaximumStatus() {
+        return this.statuses[this.statuses.length - 1];
+    }
+
+    public int getIndex() {
+        return this.index;
+    }
+
+    public boolean greaterOrEqual(ChunkStep step) {
+        return step == null || this.index >= step.index;
+    }
+
+    public boolean lessOrEqual(ChunkStep step) {
+        return step != null && this.index <= step.index;
+    }
+
+    public boolean greaterThan(ChunkStep step) {
+        return step == null || this.index > step.index;
+    }
+
+    public boolean lessThan(ChunkStep step) {
+        return step != null && this.index < step.index;
+    }
+
+    @Override
+    public String toString() {
+        return this.name;
+    }
+
+    @Nullable
+    public ChunkStep getPrevious() {
+        return byIndex(this.index - 1);
+    }
+
+    @Nullable
+    public ChunkStep getNext() {
+        return byIndex(this.index + 1);
+    }
+
+    public static ChunkStep min(ChunkStep a, ChunkStep b) {
+        if (a == null || b == null) return null;
+
+        return a.index < b.index ? a : b;
+    }
+
+    public static ChunkStep max(ChunkStep a, ChunkStep b) {
+        if (a == null) return b;
+        if (b == null) return a;
+
+        return a.index > b.index ? a : b;
+    }
+
+    @Nullable
+    public static ChunkStep byIndex(int index) {
+        if (index < 0 || index >= STEPS.size()) {
+            return null;
+        }
+        return STEPS.get(index);
+    }
+
+    public static ChunkStep byStatus(ChunkStatus status) {
+        return STATUS_TO_STEP[status.getIndex()];
+    }
+
+    public static ChunkStep byFullStatus(ChunkStatus status) {
+        ChunkStep step = byStatus(status);
+        if (status == step.getMaximumStatus()) {
+            return step;
+        } else {
+            return step.getPrevious();
+        }
+    }
+
+    public static int getRequiredRadius(ChunkStep step) {
+        return STEP_TO_RADIUS[step.getIndex()];
+    }
+
+    public static int getDistanceFromFull(ChunkStep step) {
+        return STEP_TO_DISTANCE[step.getIndex()];
+    }
+
+    public static ChunkStep byDistanceFromFull(int distance) {
+        if (distance < 0) return FULL;
+        if (distance >= DISTANCE_TO_STEP.length) return EMPTY;
+
+        return DISTANCE_TO_STEP[distance];
+    }
+
+    public static int getMaxDistance() {
+        return MAX_DISTANCE;
+    }
+
+    static {
+        // initialize status -> step mapping
+        List<ChunkStatus> statuses = ChunkStatus.createOrderedList();
+        STATUS_TO_STEP = new ChunkStep[statuses.size()];
+
+        for (ChunkStep step : STEPS) {
+            for (ChunkStatus status : step.statuses) {
+                STATUS_TO_STEP[status.getIndex()] = step;
+            }
+        }
+
+        StepKernelResolver.Results results = new StepKernelResolver(STEPS).resolve();
+
+        MAX_DISTANCE = results.maxDistance;
+        STEP_TO_RADIUS = results.stepToRadius;
+        DISTANCE_TO_STEP = results.distanceToStep;
+        STEP_TO_DISTANCE = results.stepToDistance;
+    }
+
+    private static Chunk addStructureStarts(ChunkStepContext ctx) {
+        ServerWorld world = ctx.world;
+        GeneratorOptions options = world.getServer().getSaveProperties().getGeneratorOptions();
+        if (options.shouldGenerateStructures()) {
+            ctx.generator.setStructureStarts(world.getRegistryManager(), world.getStructureAccessor(), ctx.chunk, ctx.structures, world.getSeed());
+        }
+        return ctx.chunk;
+    }
+
+    private static Chunk generateSurface(ChunkStepContext ctx) {
+        ChunkGenerator generator = ctx.generator;
+        ServerWorld world = ctx.world;
+        Chunk chunk = ctx.chunk;
+
+        ChunkRegion region = ctx.asRegion();
+        StructureAccessor structureAccessor = ctx.asStructureAccessor();
+
+        generator.addStructureReferences(region, structureAccessor, chunk);
+        trySetStatus(chunk, ChunkStatus.STRUCTURE_REFERENCES);
+
+        generator.populateBiomes(world.getRegistryManager().get(Registry.BIOME_KEY), chunk);
+        trySetStatus(chunk, ChunkStatus.BIOMES);
+
+        generator.populateNoise(region, structureAccessor, chunk);
+        trySetStatus(chunk, ChunkStatus.NOISE);
+
+        generator.buildSurface(region, chunk);
+        trySetStatus(chunk, ChunkStatus.SURFACE);
+
+        generator.carve(world.getSeed(), world.getBiomeAccess(), chunk, GenerationStep.Carver.AIR);
+        trySetStatus(chunk, ChunkStatus.CARVERS);
+
+        generator.carve(world.getSeed(), world.getBiomeAccess(), chunk, GenerationStep.Carver.LIQUID);
+        trySetStatus(chunk, ChunkStatus.LIQUID_CARVERS);
+
+        return chunk;
+    }
+
+    private static Future<Chunk> addFeatures(ChunkStepContext ctx) {
+        ProtoChunk proto = (ProtoChunk) ctx.chunk;
+        proto.setLightingProvider(ctx.lighting);
+
+        Heightmap.populateHeightmaps(ctx.chunk, REQUIRED_FEATURE_HEIGHTMAPS);
+
+        ChunkRegion region = ctx.asRegion();
+        ctx.generator.generateFeatures(region, ctx.world.getStructureAccessor().forRegion(region));
+
+        return TicTacsCompatibility.afterFeaturesStep(ctx);
+    }
+
+    private static Future<Chunk> loadFeatures(ChunkStepContext ctx) {
+        return TicTacsCompatibility.afterFeaturesStep(ctx);
+    }
+
+    private static Future<Chunk> lightChunk(ChunkStepContext ctx, boolean load) {
+        trySetStatus(ctx.chunk, ChunkStatus.LIGHT);
+
+        ChunkTicketManager ticketManager = ctx.controller.getTicketManager();
+
+        FutureHandle<Chunk> handle = new FutureHandle<>();
+
+        ChunkPos pos = ctx.entry.getPos();
+        ctx.controller.spawnOnMainThread(ctx.entry, () -> {
+            ticketManager.addTicketWithLevel(ChunkTicketType.LIGHT, pos, ChunkLevelTracker.LIGHT_TICKET_LEVEL, pos);
+
+            ctx.lighting.light(ctx.chunk, load && ctx.chunk.isLightOn()).thenAccept(handle::complete);
+        });
+
+        return handle;
+    }
+
+    private static Future<Unit> acquireLight(ChunkController controller) {
+        return controller.getUpgrader().lightingThrottler.acquireAsync();
+    }
+
+    private static void releaseLight(ChunkController controller) {
+        controller.getUpgrader().lightingThrottler.release();
+    }
+
+    private static void addEntities(ChunkStepContext ctx) {
+        ChunkRegion region = ctx.asRegion();
+        ctx.generator.populateEntities(region);
+    }
+
+    private static Future<Chunk> makeFull(ChunkStepContext ctx) {
+        FutureHandle<Chunk> handle = new FutureHandle<>();
+
+        ctx.controller.spawnOnMainThread(ctx.entry, () -> {
+            LongSet loadedChunks = ((TacsAccessor) ctx.controller).getLoadedChunks();
+
+            WorldChunk worldChunk = ctx.entry.finalizeChunk(ctx.world, loadedChunks::add);
+            handle.complete(worldChunk);
+        });
+
+        return handle;
+    }
+
+    public static void trySetStatus(Chunk chunk, ChunkStatus status) {
+        if (chunk instanceof ProtoChunk) {
+            ProtoChunk protoChunk = (ProtoChunk) chunk;
+            if (!protoChunk.getStatus().isAtLeast(status)) {
+                protoChunk.setStatus(status);
+            }
+        }
+    }
+
+    public interface AsyncTask {
+        static AsyncTask noop() {
+            return ctx -> Future.ready(ctx.chunk);
+        }
+
+        static AsyncTask from(SyncTask task) {
+            return ctx -> Future.ready(task.run(ctx));
+        }
+
+        Future<Chunk> run(ChunkStepContext ctx);
+    }
+
+    public interface SyncTask {
+        static SyncTask noop() {
+            return ctx -> ctx.chunk;
+        }
+
+        Chunk run(ChunkStepContext ctx);
+    }
+
+    public interface Acquire {
+        Future<Unit> acquire(ChunkController controller);
+    }
+
+    public interface Release {
+        void release(ChunkController controller);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2f378d260f05b0b0a68aa064e341a1a5e42414f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java
@@ -0,0 +1,53 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.world.ChunkRegion;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.gen.StructureAccessor;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+
+import java.util.List;
+
+public final class ChunkStepContext {
+    public final ChunkController controller;
+    public final ChunkEntry entry;
+    public final ServerWorld world;
+    public final ChunkGenerator generator;
+    public final StructureManager structures;
+    public final ServerLightingProvider lighting;
+    public final Chunk chunk;
+    public final List<Chunk> chunks;
+
+    private ChunkRegion region;
+    private StructureAccessor structureAccessor;
+
+    public ChunkStepContext(ChunkController controller, ChunkEntry entry, ServerWorld world, ChunkGenerator generator, StructureManager structures, ServerLightingProvider lighting, Chunk chunk, List<Chunk> chunks) {
+        this.controller = controller;
+        this.entry = entry;
+        this.world = world;
+        this.generator = generator;
+        this.structures = structures;
+        this.lighting = lighting;
+        this.chunk = chunk;
+        this.chunks = chunks;
+    }
+
+    public ChunkRegion asRegion() {
+        if (this.region == null) {
+            this.region = new ChunkRegion(this.world, this.chunks);
+        }
+        return this.region;
+    }
+
+    public StructureAccessor asStructureAccessor() {
+        if (this.structureAccessor == null) {
+            ChunkRegion region = this.asRegion();
+            this.structureAccessor = this.world.getStructureAccessor().forRegion(region);
+        }
+        return this.structureAccessor;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java b/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..40dcb56a07bb2923251b06dc1f0aba357d052511
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java
@@ -0,0 +1,95 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import java.util.List;
+
+public final class StepKernelResolver {
+    private final List<ChunkStep> steps;
+
+    StepKernelResolver(List<ChunkStep> steps) {
+        this.steps = steps;
+    }
+
+    public static int effectiveRadiusFor(ChunkStep step, ChunkStep minimum) {
+        ChunkRequirements requirements = step.getRequirements();
+
+        int radius = requirements.getRadius();
+
+        int effectiveRadius = radius;
+
+        for (int distance = 0; distance <= radius; distance++) {
+            ChunkRequirement requirement = requirements.byDistance(distance);
+            if (requirement != null && (minimum == null || requirement.step.greaterThan(minimum))) {
+                int childRadius = effectiveRadiusFor(requirement.step, minimum);
+                if (childRadius >= 0) {
+                    effectiveRadius = Math.max(effectiveRadius, distance + childRadius);
+                }
+            }
+        }
+
+        return effectiveRadius;
+    }
+
+    private void resolveRadii(Results results) {
+        results.stepToRadius = new int[this.steps.size()];
+
+        for (ChunkStep step : this.steps) {
+            int radius = effectiveRadiusFor(step, null);
+            results.stepToRadius[step.getIndex()] = radius;
+
+            results.maxDistance = Math.max(radius, results.maxDistance);
+        }
+    }
+
+    private void tryAddStepAt(ChunkStep step, int distance, Results results) {
+        ChunkRequirements requirements = step.getRequirements();
+
+        ChunkStep existingStep = results.distanceToStep[distance];
+        if (existingStep == null || step.greaterThan(existingStep)) {
+            results.distanceToStep[distance] = step;
+        }
+
+        int radius = requirements.getRadius();
+        for (int offset = 0; offset <= radius; offset++) {
+            ChunkRequirement requirement = requirements.byDistance(offset);
+            if (requirement != null) {
+                this.tryAddStepAt(requirement.step, distance + offset, results);
+            }
+        }
+    }
+
+    private void resolveDistances(Results results) {
+        results.distanceToStep = new ChunkStep[results.maxDistance + 1];
+
+        ChunkStep lastStep = this.steps.get(this.steps.size() - 1);
+        this.tryAddStepAt(lastStep, 0, results);
+
+        results.stepToDistance = new int[this.steps.size()];
+
+        int distance = 0;
+        for (int i = this.steps.size() - 1; i >= 0; i--) {
+            ChunkStep step = this.steps.get(i);
+
+            while (distance + 1 <= results.maxDistance && step.lessOrEqual(results.distanceToStep[distance + 1])) {
+                distance++;
+            }
+
+            results.stepToDistance[i] = distance;
+        }
+    }
+
+    public Results resolve() {
+        Results results = new Results();
+
+        this.resolveRadii(results);
+        this.resolveDistances(results);
+
+        return results;
+    }
+
+    static final class Results {
+        public int maxDistance;
+        public int[] stepToRadius;
+        public ChunkStep[] distanceToStep;
+        public int[] stepToDistance;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java b/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..7dbdddd3e51ed4bf951bf3b996fbaa7809341210
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java
@@ -0,0 +1,200 @@
+package net.gegy1000.tictacs.chunk.ticket;
+
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongLists;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.future.AwaitAll;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.util.math.ChunkPos;
+
+// TODO: ideally we overwrite generation tickets with player tickets
+public final class PlayerTicketManager implements TicketTracker {
+    private final ChunkController controller;
+    private final ChunkStep step;
+    private final ChunkTicketType<ChunkPos> ticketType;
+    private final int ticketLevel;
+    private final int levelStep;
+
+    private final int levelCount;
+    private final LongSet[] queues;
+    private final int[] waitingCounts;
+
+    private int currentLevel;
+
+    private final LongList addedChunks = new LongArrayList();
+
+    public PlayerTicketManager(ChunkController controller, ChunkStep step, int radius, ChunkTicketType<ChunkPos> ticketType, int levelStep) {
+        this.controller = controller;
+        this.step = step;
+        this.ticketType = ticketType;
+        this.levelStep = levelStep;
+
+        this.ticketLevel = ChunkLevelTracker.FULL_LEVEL + ChunkStep.getDistanceFromFull(step) - radius;
+
+        this.levelCount = (ChunkLevelTracker.FULL_LEVEL + levelStep - 1) / levelStep;
+        this.queues = new LongSet[this.levelCount];
+        this.waitingCounts = new int[this.levelCount];
+
+        for (int i = 0; i < this.levelCount; i++) {
+            this.queues[i] = new LongOpenHashSet();
+        }
+    }
+
+    public LongList collectTickets() {
+        ChunkTicketManager ticketManager = this.controller.getTicketManager();
+
+        while (true) {
+            int currentLevel = this.currentLevel;
+            if (currentLevel >= this.levelCount) {
+                return LongLists.EMPTY_LIST;
+            }
+
+            LongSet queue = this.queues[currentLevel];
+
+            // once this level is totally completed, we can advance to the next level
+            if (queue.isEmpty() && this.waitingCounts[currentLevel] <= 0) {
+                this.currentLevel = this.getNextLevel(currentLevel);
+                continue;
+            }
+
+            if (!queue.isEmpty()) {
+                LongList addedChunks = this.addedChunks;
+                addedChunks.clear();
+
+                addedChunks.addAll(queue);
+                queue.clear();
+
+                LongIterator iterator = addedChunks.iterator();
+                while (iterator.hasNext()) {
+                    ChunkPos pos = new ChunkPos(iterator.nextLong());
+                    ticketManager.addTicketWithLevel(this.ticketType, pos, this.ticketLevel, pos);
+                }
+
+                return addedChunks;
+            }
+
+            return LongLists.EMPTY_LIST;
+        }
+    }
+
+    public void waitForChunks(LongList chunks) {
+        if (chunks.isEmpty()) {
+            return;
+        }
+
+        int count = chunks.size();
+
+        int currentLevel = this.currentLevel;
+        this.waitingCounts[currentLevel] += count;
+
+        Future<Unit> future = this.awaitAllChunks(chunks);
+        this.controller.spawnOnMainThread(future.map(unit -> {
+            int waitingCount = this.waitingCounts[currentLevel];
+            this.waitingCounts[currentLevel] = Math.max(waitingCount - count, 0);
+            return unit;
+        }));
+
+        chunks.clear();
+    }
+
+    private Future<Unit> awaitAllChunks(LongList entries) {
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+        ChunkAccess chunks = this.controller.getMap().visible();
+
+        ChunkListener[] listeners = new ChunkListener[entries.size()];
+
+        for (int i = 0; i < entries.size(); i++) {
+            long pos = entries.getLong(i);
+            ChunkEntry entry = chunks.getEntry(pos);
+            if (entry == null) {
+                throw new IllegalStateException("missing entry added by player ticket");
+            }
+
+            upgrader.spawnUpgradeTo(entry, this.step);
+            listeners[i] = entry.getListenerFor(this.step);
+        }
+
+        return AwaitAll.of(listeners);
+    }
+
+    @Override
+    public void enqueueTicket(long pos, int distance) {
+        int level = distance / this.levelStep;
+        if (level >= this.levelCount) {
+            return;
+        }
+
+        this.queues[level].add(pos);
+        if (level < this.currentLevel) {
+            this.currentLevel = level;
+        }
+    }
+
+    @Override
+    public void removeTicket(long pos) {
+        this.removeChunkTicket(pos);
+
+        for (int i = this.currentLevel; i < this.levelCount; i++) {
+            LongSet queue = this.queues[i];
+            if (queue.remove(pos)) {
+                if (queue.isEmpty()) {
+                    this.removeLevel(i);
+                }
+                return;
+            }
+        }
+    }
+
+    private void removeChunkTicket(long posKey) {
+        ChunkPos pos = new ChunkPos(posKey);
+        this.controller.getTicketManager().removeTicketWithLevel(this.ticketType, pos, this.ticketLevel, pos);
+    }
+
+    @Override
+    public void moveTicket(long pos, int fromDistance, int toDistance) {
+        int fromLevel = fromDistance / this.levelStep;
+        if (fromLevel >= this.levelCount) {
+            return;
+        }
+
+        LongSet fromQueue = this.queues[fromLevel];
+        if (!fromQueue.remove(pos)) {
+            return;
+        }
+
+        this.enqueueTicket(pos, toDistance);
+
+        if (fromQueue.isEmpty()) {
+            this.removeLevel(fromLevel);
+        }
+    }
+
+    private void removeLevel(int level) {
+        this.waitingCounts[level] = 0;
+        if (level == this.currentLevel) {
+            this.currentLevel = this.getNextLevel(this.currentLevel);
+        }
+    }
+
+    private int getNextLevel(int fromLevel) {
+        for (int i = fromLevel; i < this.levelCount; i++) {
+            if (!this.queues[i].isEmpty()) {
+                return i;
+            }
+        }
+        return this.levelCount;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..015d6e964251735ac97c985792dadef0cbba665f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java
@@ -0,0 +1,9 @@
+package net.gegy1000.tictacs.chunk.ticket;
+
+public interface TicketTracker {
+    void enqueueTicket(long pos, int distance);
+
+    void removeTicket(long pos);
+
+    void moveTicket(long pos, int fromDistance, int toDistance);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..100e9cd371045d7d87a6693ef9d408337aa4aaa7
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java
@@ -0,0 +1,230 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntryTrackers;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityType;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.EntityTrackerEntry;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.MathHelper;
+
+import java.util.Set;
+
+public final class ChunkEntityTracker {
+    private final EntityTrackerEntry entry;
+    private final int maxTrackDistance;
+
+    private Set<ServerPlayerEntity> trackingPlayers;
+
+    private ChunkEntry chunkEntry;
+    private long chunkPos;
+
+    public ChunkEntityTracker(Entity entity) {
+        EntityType<?> type = entity.getType();
+        int tickInterval = type.getTrackTickInterval();
+        boolean updateVelocity = type.alwaysUpdateVelocity();
+
+        this.entry = new EntityTrackerEntry((ServerWorld) entity.world, entity, tickInterval, updateVelocity, this::sendToTracking);
+        this.maxTrackDistance = type.getMaxTrackDistance();
+    }
+
+    public Entity getEntity() {
+        return this.entry.entity;
+    }
+
+    public boolean tick(ChunkController controller) {
+        boolean moved = false;
+
+        long chunkPos = chunkForEntity(this.entry.entity);
+        if (chunkPos != this.chunkPos || this.chunkEntry == null) {
+            ChunkAccess chunks = controller.getMap().primary();
+
+            ChunkEntry fromChunkEntry = this.chunkEntry;
+            ChunkEntry toChunkEntry = chunks.getEntry(chunkPos);
+
+            this.chunkEntry = toChunkEntry;
+            this.chunkPos = chunkPos;
+
+            this.moveChunk(fromChunkEntry, toChunkEntry);
+            moved = true;
+        }
+
+        this.entry.tick();
+
+        return moved;
+    }
+
+    void remove() {
+        if (this.chunkEntry != null) {
+            this.chunkEntry.getTrackers().removeEntity(this);
+            this.chunkEntry = null;
+        }
+
+        if (this.trackingPlayers != null) {
+            for (ServerPlayerEntity player : this.trackingPlayers) {
+                this.entry.stopTracking(player);
+            }
+            this.trackingPlayers = null;
+        }
+    }
+
+    private void moveChunk(ChunkEntry from, ChunkEntry to) {
+        if (from != null) {
+            this.moveFromChunk(from);
+        }
+
+        if (to != null) {
+            this.moveToChunk(to);
+        }
+    }
+
+    private void moveFromChunk(ChunkEntry from) {
+        ChunkEntryTrackers trackers = from.getTrackers();
+        for (ServerPlayerEntity player : trackers.getTrackingPlayers()) {
+            this.updateTrackerUnwatched(player);
+        }
+
+        trackers.removeEntity(this);
+    }
+
+    private void moveToChunk(ChunkEntry to) {
+        ChunkEntryTrackers trackers = to.getTrackers();
+        for (ServerPlayerEntity player : trackers.getTrackingPlayers()) {
+            this.updateTrackerWatched(player);
+        }
+
+        trackers.addEntity(this);
+    }
+
+    public void updateTracker(ServerPlayerEntity player) {
+        boolean isTracked = this.isTrackedBy(player);
+        boolean canTrack = this.canBeTrackedBy(player);
+
+        if (isTracked != canTrack) {
+            if (canTrack) {
+                this.startTracking(player);
+            } else {
+                this.stopTracking(player);
+            }
+        }
+    }
+
+    public void updateTrackerWatched(ServerPlayerEntity player) {
+        if (!this.isTrackedBy(player) && this.canBeTrackedBy(player)) {
+            this.startTracking(player);
+        }
+    }
+
+    public void updateTrackerUnwatched(ServerPlayerEntity player) {
+        if (this.isTrackedBy(player) && !this.canBeTrackedBy(player)) {
+            this.stopTracking(player);
+        }
+    }
+
+    private void startTracking(ServerPlayerEntity player) {
+        if (this.trackingPlayers == null) {
+            this.trackingPlayers = new ObjectOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        if (this.trackingPlayers.add(player)) {
+            this.entry.startTracking(player);
+        }
+    }
+
+    private void stopTracking(ServerPlayerEntity player) {
+        if (this.trackingPlayers != null && this.trackingPlayers.remove(player)) {
+            if (this.trackingPlayers.isEmpty()) {
+                this.trackingPlayers = null;
+            }
+
+            this.entry.stopTracking(player);
+        }
+    }
+
+    private boolean isTrackedBy(ServerPlayerEntity player) {
+        return this.trackingPlayers != null && this.trackingPlayers.contains(player);
+    }
+
+    private boolean canBeTrackedBy(ServerPlayerEntity player) {
+        if (player == this.entry.entity) {
+            return false;
+        } else if (player.teleporting) {
+            return true;
+        }
+
+        if (this.chunkEntry == null || !this.chunkEntry.getTrackers().isTrackedBy(player)) {
+            return false;
+        }
+
+        int chunkX = ChunkPos.getPackedX(this.chunkPos);
+        int chunkZ = ChunkPos.getPackedZ(this.chunkPos);
+
+        int distance = ChunkTracker.getChunkDistance(player, chunkX, chunkZ);
+        return distance < this.getEffectiveTrackDistance();
+    }
+
+    public void sendToTrackingAndSelf(Packet<?> packet) {
+        this.sendToTracking(packet);
+        this.sendToSelf(packet);
+    }
+
+    public void sendToTracking(Packet<?> packet) {
+        if (this.trackingPlayers == null) {
+            return;
+        }
+
+        if (this.entry.entity instanceof ServerPlayerEntity) {
+            for (ServerPlayerEntity player : this.trackingPlayers) {
+                player.networkHandler.sendPacket(packet);
+            }
+        } else {
+            // entity tracker updates are lower priority than players so it should be fine to queue them
+            for (ServerPlayerEntity player : this.trackingPlayers) {
+                QueuingConnection.enqueueSend(player.networkHandler, packet);
+            }
+        }
+    }
+
+    private void sendToSelf(Packet<?> packet) {
+        if (this.entry.entity instanceof ServerPlayerEntity) {
+            ServerPlayerEntity player = (ServerPlayerEntity) this.entry.entity;
+            QueuingConnection.enqueueSend(player.networkHandler, packet);
+        }
+    }
+
+    private int getEffectiveTrackDistance() {
+        Entity entity = this.entry.entity;
+        if (!entity.hasPassengers()) {
+            return this.adjustTrackDistance(this.maxTrackDistance);
+        }
+
+        int maxDistance = this.maxTrackDistance;
+        for (Entity passenger : entity.getPassengersDeep()) {
+            maxDistance = Math.max(maxDistance, passenger.getType().getMaxTrackDistance());
+        }
+
+        return this.adjustTrackDistance(maxDistance);
+    }
+
+    private int adjustTrackDistance(int initialDistance) {
+        return this.entry.world.getServer().adjustTrackingDistance(initialDistance);
+    }
+
+    private static long chunkForEntity(Entity entity) {
+        if (!entity.updateNeeded) {
+            int x = MathHelper.floor(entity.getX()) >> 4;
+            int z = MathHelper.floor(entity.getZ()) >> 4;
+            return ChunkPos.toLong(x, z);
+        }
+
+        return ChunkPos.toLong(entity.chunkX, entity.chunkZ);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java
new file mode 100644
index 0000000000000000000000000000000000000000..1369e58016a3647c8a6c04682b1c19dd8be9c4ba
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java
@@ -0,0 +1,63 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.minecraft.entity.Entity;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.ServerPlayerEntity;
+
+public final class ChunkEntityTrackers {
+    private final ChunkController controller;
+    private final Int2ObjectMap<ChunkEntityTracker> entities = new Int2ObjectOpenHashMap<>();
+
+    public ChunkEntityTrackers(ChunkController controller) {
+        this.controller = controller;
+    }
+
+    public void tick() {
+        for (ChunkEntityTracker tracker : this.entities.values()) {
+            tracker.tick(this.controller);
+        }
+    }
+
+    public void add(Entity entity) {
+        if (this.entities.containsKey(entity.getEntityId())) {
+            return;
+        }
+
+        ChunkEntityTracker tracker = new ChunkEntityTracker(entity);
+        tracker.tick(this.controller);
+
+        this.entities.put(entity.getEntityId(), tracker);
+
+        if (entity instanceof ServerPlayerEntity) {
+            this.controller.getTracker().addPlayer((ServerPlayerEntity) entity);
+        }
+    }
+
+    public void remove(Entity entity) {
+        ChunkEntityTracker tracker = this.entities.remove(entity.getEntityId());
+        if (tracker != null) {
+            tracker.remove();
+
+            if (entity instanceof ServerPlayerEntity) {
+                this.controller.getTracker().removePlayer((ServerPlayerEntity) entity);
+            }
+        }
+    }
+
+    public void sendToTracking(Entity entity, Packet<?> packet) {
+        ChunkEntityTracker tracker = this.entities.get(entity.getEntityId());
+        if (tracker != null) {
+            tracker.sendToTracking(packet);
+        }
+    }
+
+    public void sendToTrackingAndSelf(Entity entity, Packet<?> packet) {
+        ChunkEntityTracker tracker = this.entities.get(entity.getEntityId());
+        if (tracker != null) {
+            tracker.sendToTrackingAndSelf(packet);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java
new file mode 100644
index 0000000000000000000000000000000000000000..34a9e6085634eb64df245ea9e84e7d07b7cc7ad4
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java
@@ -0,0 +1,91 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.mob.MobEntity;
+import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
+import net.minecraft.network.packet.s2c.play.ChunkRenderDistanceCenterS2CPacket;
+import net.minecraft.network.packet.s2c.play.EntityAttachS2CPacket;
+import net.minecraft.network.packet.s2c.play.EntityPassengersSetS2CPacket;
+import net.minecraft.network.packet.s2c.play.LightUpdateS2CPacket;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.ChunkSectionPos;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.chunk.light.LightingProvider;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ChunkPackets {
+    public static Data dataFor(WorldChunk chunk) {
+        return new Data(chunk);
+    }
+
+    public static Entities entitiesFor(ChunkEntry entry) {
+        Entities entities = new Entities();
+        for (ChunkEntityTracker tracker : entry.getTrackers().getEntities()) {
+            entities.addEntity(tracker.getEntity());
+        }
+
+        return entities;
+    }
+
+    public static void sendPlayerChunkPos(ServerPlayerEntity player) {
+        ChunkSectionPos pos = player.getCameraPosition();
+        QueuingConnection.enqueueSend(player.networkHandler, new ChunkRenderDistanceCenterS2CPacket(pos.getSectionX(), pos.getSectionZ()));
+    }
+
+    public static class Data {
+        private final WorldChunk chunk;
+
+        private ChunkDataS2CPacket dataPacket;
+        private LightUpdateS2CPacket lightPacket;
+
+        Data(WorldChunk chunk) {
+            this.chunk = chunk;
+        }
+
+        public void sendTo(ServerPlayerEntity player) {
+            ChunkPos chunkPos = this.chunk.getPos();
+
+            if (this.dataPacket == null) {
+                LightingProvider lighting = this.chunk.getWorld().getLightingProvider();
+
+                this.dataPacket = new ChunkDataS2CPacket(this.chunk, 0xFFFF);
+                this.lightPacket = new LightUpdateS2CPacket(chunkPos, lighting, true);
+            }
+
+            player.sendInitialChunkPackets(chunkPos, this.dataPacket, this.lightPacket);
+        }
+    }
+
+    public static class Entities {
+        private final List<MobEntity> leashedEntities = new ArrayList<>();
+        private final List<Entity> entitiesWithPassengers = new ArrayList<>();
+
+        Entities() {
+        }
+
+        public void addEntity(Entity entity) {
+            if (entity instanceof MobEntity && ((MobEntity) entity).getHoldingEntity() != null) {
+                this.leashedEntities.add((MobEntity) entity);
+            }
+
+            if (!entity.getPassengerList().isEmpty()) {
+                this.entitiesWithPassengers.add(entity);
+            }
+        }
+
+        public void sendTo(ServerPlayerEntity player) {
+            for (MobEntity entity : this.leashedEntities) {
+                QueuingConnection.enqueueSend(player.networkHandler, new EntityAttachS2CPacket(entity, entity.getHoldingEntity()));
+            }
+
+            for (Entity entity : this.entitiesWithPassengers) {
+                QueuingConnection.enqueueSend(player.networkHandler, new EntityPassengersSetS2CPacket(entity));
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6c695b20fad6ca2c0e5a4c1a9721786e3ce1583
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java
@@ -0,0 +1,75 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceSet;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.world.GameRules;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+public final class ChunkPlayerWatchers implements Iterable<ServerPlayerEntity> {
+    private final ServerWorld world;
+
+    private final ReferenceSet<ServerPlayerEntity> players = new ReferenceOpenHashSet<>();
+    private final ReferenceSet<ServerPlayerEntity> loadingPlayers = new ReferenceOpenHashSet<>();
+
+    public ChunkPlayerWatchers(ServerWorld world) {
+        this.world = world;
+    }
+
+    public void addPlayer(ServerPlayerEntity player) {
+        this.players.add(player);
+        if (this.shouldLoadChunks(player)) {
+            this.loadingPlayers.add(player);
+        }
+    }
+
+    public void removePlayer(ServerPlayerEntity player) {
+        if (this.players.remove(player)) {
+            this.loadingPlayers.remove(player);
+        }
+    }
+
+    public void setLoadingEnabled(ServerPlayerEntity player, boolean enabled) {
+        if (!this.players.contains(player)) {
+            return;
+        }
+
+        if (enabled) {
+            this.loadingPlayers.add(player);
+        } else {
+            this.loadingPlayers.remove(player);
+        }
+    }
+
+    public boolean containsPlayer(ServerPlayerEntity player) {
+        return this.players.contains(player);
+    }
+
+    public boolean isLoadingEnabled(ServerPlayerEntity player) {
+        return this.loadingPlayers.contains(player);
+    }
+
+    public boolean shouldLoadChunks(ServerPlayerEntity player) {
+        return !player.isSpectator() || this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
+    }
+
+    public boolean isEmpty() {
+        return this.players.isEmpty();
+    }
+
+    public Collection<ServerPlayerEntity> getPlayers() {
+        return this.players;
+    }
+
+    public Collection<ServerPlayerEntity> getLoadingPlayers() {
+        return this.loadingPlayers;
+    }
+
+    @Override
+    public Iterator<ServerPlayerEntity> iterator() {
+        return this.players.iterator();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java
new file mode 100644
index 0000000000000000000000000000000000000000..471c9f0a3b2054a22fe5e6b9003166318c9b0f0d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java
@@ -0,0 +1,135 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.minecraft.util.math.ChunkPos;
+
+import java.util.function.LongConsumer;
+
+final class ChunkTrackView {
+    int minX;
+    int minZ;
+    int maxX;
+    int maxZ;
+
+    ChunkTrackView() {
+    }
+
+    public static ChunkTrackView withRadius(int x, int z, int radius) {
+        ChunkTrackView view = new ChunkTrackView();
+        view.setWithRadius(x, z, radius);
+
+        return view;
+    }
+
+    public void set(int minX, int minZ, int maxX, int maxZ) {
+        this.minX = minX;
+        this.minZ = minZ;
+        this.maxX = maxX;
+        this.maxZ = maxZ;
+    }
+
+    public void setWithRadius(int x, int z, int radius) {
+        this.set(x - radius, z - radius, x + radius, z + radius);
+    }
+
+    public void forEach(LongConsumer consumer) {
+        forEach(
+                this.minX, this.minZ,
+                this.maxX, this.maxZ,
+                consumer
+        );
+    }
+
+    public void forEachDifference(ChunkTrackView other, LongConsumer consumer) {
+        if (this.equals(other)) {
+            return;
+        }
+
+        if (!this.intersects(other)) {
+            this.forEach(consumer);
+            return;
+        }
+
+        boolean tl = !other.contains(this.minX, this.minZ);
+        boolean tr = !other.contains(this.maxX, this.minZ);
+        boolean bl = !other.contains(this.minX, this.maxZ);
+        boolean br = !other.contains(this.maxX, this.maxZ);
+
+        // corners
+        if (tl) forEach(this.minX, this.minZ, other.minX - 1, other.minZ - 1, consumer);
+        if (tr) forEach(other.maxX + 1, this.minZ, this.maxX, other.minZ - 1, consumer);
+        if (bl) forEach(this.minX, other.maxZ + 1, other.minX - 1, this.maxZ, consumer);
+        if (br) forEach(other.maxX + 1, other.maxZ + 1, this.maxX, this.maxZ, consumer);
+
+        // edges
+        if (tl || tr) {
+            forEach(
+                    Math.max(other.minX - 1, this.minX), this.minZ,
+                    Math.min(other.maxX + 1, this.maxX), other.minZ - 1,
+                    consumer
+            );
+        }
+
+        if (bl || br) {
+            forEach(
+                    Math.max(other.minX - 1, this.minX), other.maxZ + 1,
+                    Math.min(other.maxX + 1, this.maxX), this.maxZ,
+                    consumer
+            );
+        }
+
+        if (tl || bl) {
+            forEach(
+                    this.minX, Math.max(other.minZ - 1, this.minZ),
+                    other.minX - 1, Math.min(other.maxZ + 1, this.maxZ),
+                    consumer
+            );
+        }
+
+        if (tr || br) {
+            forEach(
+                    other.maxX + 1, Math.max(other.minZ - 1, this.minZ),
+                    this.maxX, Math.min(other.maxZ + 1, this.maxZ),
+                    consumer
+            );
+        }
+    }
+
+    public void forEachIntersection(ChunkTrackView other, LongConsumer consumer) {
+        int minX = Math.max(this.minX, other.minX);
+        int maxX = Math.min(this.maxX, other.maxX);
+        int minZ = Math.max(this.minZ, other.minZ);
+        int maxZ = Math.min(this.maxZ, other.maxZ);
+        if (minX > maxX || minZ > maxZ) {
+            return;
+        }
+
+        forEach(minX, minZ, maxX, maxZ, consumer);
+    }
+
+    public void forEachUnion(ChunkTrackView other, LongConsumer consumer) {
+        this.forEachDifference(other, consumer);
+        other.forEachDifference(this, consumer);
+
+        this.forEachIntersection(other, consumer);
+    }
+
+    public boolean contains(int x, int z) {
+        return x >= this.minX && z >= this.minZ && x <= this.maxX && z <= this.maxZ;
+    }
+
+    public boolean intersects(ChunkTrackView view) {
+        return this.minX <= view.maxX && this.maxX >= view.minX && this.minZ <= view.maxZ && this.maxZ >= view.minZ;
+    }
+
+    private static void forEach(int minX, int minZ, int maxX, int maxZ, LongConsumer consumer) {
+        for (int z = minZ; z <= maxZ; z++) {
+            for (int x = minX; x <= maxX; x++) {
+                consumer.accept(ChunkPos.toLong(x, z));
+            }
+        }
+    }
+
+    public boolean equals(ChunkTrackView other) {
+        return this.minX == other.minX && this.minZ == other.minZ && this.maxX == other.maxX && this.maxZ == other.maxZ;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..08097d935c37dd77fd85dda22c37ef2c4cecbdeb
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java
@@ -0,0 +1,66 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.util.math.ChunkSectionPos;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class ChunkTrackWatcher {
+    private Function startTracking;
+    private Function stopTracking;
+    private Function updateTracking;
+
+    private int radius;
+
+    public ChunkTrackWatcher(int radius) {
+        this.radius = radius;
+    }
+
+    public void setStartTracking(Function startTracking) {
+        this.startTracking = startTracking;
+    }
+
+    public void setStopTracking(Function stopTracking) {
+        this.stopTracking = stopTracking;
+    }
+
+    public void setUpdateTracking(Function updateTracking) {
+        this.updateTracking = updateTracking;
+    }
+
+    public void setRadius(int radius) {
+        this.radius = radius;
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+
+    public ChunkTrackView viewAt(int x, int z) {
+        return ChunkTrackView.withRadius(x, z, this.radius);
+    }
+
+    public ChunkTrackView viewAt(ChunkSectionPos pos) {
+        return this.viewAt(pos.getX(), pos.getZ());
+    }
+
+    @Nullable
+    public Function getStartTracking() {
+        return this.startTracking;
+    }
+
+    @Nullable
+    public Function getStopTracking() {
+        return this.stopTracking;
+    }
+
+    @Nullable
+    public Function getUpdateTracking() {
+        return this.updateTracking;
+    }
+
+    public interface Function {
+        void accept(ServerPlayerEntity player, long pos, ChunkEntry entry);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..f395fe8503f857a8d28e6484ac3b7f89300d004e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java
@@ -0,0 +1,331 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.ChunkMapListener;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntryTrackers;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.ChunkSectionPos;
+import net.minecraft.world.chunk.WorldChunk;
+
+import java.util.Set;
+
+public final class ChunkTracker implements ChunkMapListener {
+    public static final int CHUNK_TICKING_DISTANCE = 8;
+
+    private final ChunkController controller;
+
+    private final ChunkPlayerWatchers players;
+    private final ChunkEntityTrackers entities;
+
+    private final ChunkTrackWatcher playerTracker;
+    private final ChunkTrackWatcher[] trackWatchers;
+
+    private int viewDistance;
+
+    public ChunkTracker(ServerWorld world, ChunkController controller) {
+        this.controller = controller;
+        this.players = new ChunkPlayerWatchers(world);
+        this.entities = new ChunkEntityTrackers(controller);
+
+        this.playerTracker = new ChunkTrackWatcher(3);
+        this.playerTracker.setStartTracking(this::startTrackingChunk);
+        this.playerTracker.setStopTracking(this::stopTrackingChunk);
+        this.playerTracker.setUpdateTracking((player, pos, entry) -> {
+            entry.getTrackers().updateTrackingPlayer(player);
+        });
+
+        ChunkTrackWatcher tickingTracker = new ChunkTrackWatcher(CHUNK_TICKING_DISTANCE);
+        tickingTracker.setStartTracking(this::startTrackingChunkTickable);
+        tickingTracker.setStopTracking(this::stopTrackingChunkTickable);
+
+        this.trackWatchers = new ChunkTrackWatcher[] {
+                this.playerTracker,
+                tickingTracker
+        };
+    }
+
+    public static int getChunkDistance(ServerPlayerEntity player, int chunkX, int chunkZ) {
+        ChunkSectionPos playerChunk = player.getCameraPosition();
+        int deltaX = playerChunk.getX() - chunkX;
+        int deltaZ = playerChunk.getZ() - chunkZ;
+
+        return Math.max(Math.abs(deltaX), Math.abs(deltaZ));
+    }
+
+    public void setViewDistance(int viewDistance) {
+        int lastViewDistance = this.viewDistance;
+        this.viewDistance = viewDistance;
+
+        this.playerTracker.setRadius(viewDistance);
+
+        for (ServerPlayerEntity player : this.players) {
+            ChunkSectionPos chunkPos = player.getCameraPosition();
+            int chunkX = chunkPos.getX();
+            int chunkZ = chunkPos.getZ();
+
+            ChunkTrackView view = ChunkTrackView.withRadius(chunkX, chunkZ, viewDistance);
+            ChunkTrackView lastView = ChunkTrackView.withRadius(chunkX, chunkZ, lastViewDistance);
+
+            this.updatePlayerTracker(player, this.playerTracker, view, lastView);
+        }
+    }
+
+    public void tick() {
+        this.entities.tick();
+
+        for (ServerPlayerEntity player : this.players) {
+            this.tickPlayer(player);
+        }
+    }
+
+    private void tickPlayer(ServerPlayerEntity player) {
+        ChunkSectionPos lastSectionPos = player.getCameraPosition();
+        ChunkSectionPos sectionPos = ChunkSectionPos.from(player);
+
+        if (!lastSectionPos.equals(sectionPos)) {
+            player.setCameraPosition(sectionPos);
+
+            if (lastSectionPos.getX() != sectionPos.getX() || lastSectionPos.getZ() != sectionPos.getZ()) {
+                ChunkPackets.sendPlayerChunkPos(player);
+            }
+        }
+
+        this.updatePlayerTickets(player, lastSectionPos, sectionPos);
+        this.updatePlayerTrackers(player, lastSectionPos, sectionPos);
+    }
+
+    private void updatePlayerTickets(ServerPlayerEntity player, ChunkSectionPos lastSectionPos, ChunkSectionPos sectionPos) {
+        boolean lastLoadingEnabled = this.players.isLoadingEnabled(player);
+        boolean loadingEnabled = this.players.shouldLoadChunks(player);
+
+        ChunkTicketManager ticketManager = this.controller.getTicketManager();
+        if (lastSectionPos.getX() != sectionPos.getX() || lastSectionPos.getZ() != sectionPos.getZ()) {
+            if (lastLoadingEnabled) {
+                ticketManager.handleChunkLeave(lastSectionPos, player);
+            }
+            if (loadingEnabled) {
+                ticketManager.handleChunkEnter(sectionPos, player);
+            }
+        }
+
+        if (lastLoadingEnabled != loadingEnabled) {
+            this.players.setLoadingEnabled(player, loadingEnabled);
+
+            if (loadingEnabled) {
+                ticketManager.handleChunkEnter(sectionPos, player);
+            } else {
+                ticketManager.handleChunkLeave(lastSectionPos, player);
+            }
+        }
+    }
+
+    private void updatePlayerTrackers(ServerPlayerEntity player, ChunkSectionPos lastSectionPos, ChunkSectionPos sectionPos) {
+        int chunkX = sectionPos.getX();
+        int chunkZ = sectionPos.getZ();
+        int lastChunkX = lastSectionPos.getX();
+        int lastChunkZ = lastSectionPos.getZ();
+
+        if (chunkX == lastChunkX && chunkZ == lastChunkZ) {
+            return;
+        }
+
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackView view = tracker.viewAt(chunkX, chunkZ);
+            ChunkTrackView lastView = tracker.viewAt(lastChunkX, lastChunkZ);
+
+            this.updatePlayerTracker(player, tracker, view, lastView);
+        }
+    }
+
+    private void updatePlayerTracker(ServerPlayerEntity player, ChunkTrackWatcher tracker, ChunkTrackView view, ChunkTrackView lastView) {
+        ChunkAccess chunks = this.controller.getMap().primary();
+
+        ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+        if (startTracking != null) {
+            view.forEachDifference(lastView, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    startTracking.accept(player, pos, entry);
+                }
+            });
+        }
+
+        ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+        if (stopTracking != null) {
+            lastView.forEachDifference(view, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    stopTracking.accept(player, pos, entry);
+                }
+            });
+        }
+
+        ChunkTrackWatcher.Function updateTracking = tracker.getUpdateTracking();
+        if (updateTracking != null) {
+            view.forEachIntersection(lastView, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    updateTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    private void startTrackingChunk(ServerPlayerEntity player, long pos, ChunkEntry entry) {
+        if (entry.getTrackers().addTrackingPlayer(player)) {
+            WorldChunk chunk = entry.getWorldChunk();
+            if (chunk != null) {
+                ChunkPackets.Data dataPackets = ChunkPackets.dataFor(chunk);
+                dataPackets.sendTo(player);
+
+                ChunkPackets.Entities entities = ChunkPackets.entitiesFor(entry);
+                entities.sendTo(player);
+            }
+        }
+    }
+
+    private void stopTrackingChunk(ServerPlayerEntity player, long pos, ChunkEntry entry) {
+        if (entry.getTrackers().removeTrackingPlayer(player)) {
+            player.sendUnloadChunkPacket(new ChunkPos(pos));
+        }
+    }
+
+    private void startTrackingChunkTickable(ServerPlayerEntity player, long pos, ChunkEntry entry) {
+        ChunkEntryTrackers trackers = entry.getTrackers();
+
+        if (trackers.getTickableTrackingPlayers().isEmpty()) {
+            ChunkMap map = this.controller.getMap();
+            map.getTickingMaps().addTickableChunk(entry);
+        }
+
+        trackers.addTickableTrackingPlayer(player);
+    }
+
+    private void stopTrackingChunkTickable(ServerPlayerEntity player, long pos, ChunkEntry entry) {
+        ChunkEntryTrackers trackers = entry.getTrackers();
+        trackers.removeTickableTrackingPlayer(player);
+
+        if (trackers.getTickableTrackingPlayers().isEmpty()) {
+            ChunkMap map = this.controller.getMap();
+            map.getTickingMaps().removeTickableChunk(entry);
+        }
+    }
+
+    public void addPlayer(ServerPlayerEntity player) {
+        this.players.addPlayer(player);
+
+        ChunkSectionPos sectionPos = ChunkSectionPos.from(player);
+        player.setCameraPosition(sectionPos);
+        ChunkPackets.sendPlayerChunkPos(player);
+
+        boolean loadChunks = this.players.shouldLoadChunks(player);
+        this.players.setLoadingEnabled(player, loadChunks);
+        if (loadChunks) {
+            this.controller.getTicketManager().handleChunkEnter(sectionPos, player);
+        }
+
+        ChunkAccess chunks = this.controller.getMap().primary();
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+            if (startTracking == null) {
+                continue;
+            }
+
+            tracker.viewAt(sectionPos).forEach(pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    startTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    public void removePlayer(ServerPlayerEntity player) {
+        ChunkSectionPos sectionPos = player.getCameraPosition();
+
+        boolean loadChunks = this.players.isLoadingEnabled(player);
+        if (loadChunks) {
+            this.controller.getTicketManager().handleChunkLeave(sectionPos, player);
+        }
+
+        this.players.removePlayer(player);
+
+        ChunkAccess chunks = this.controller.getMap().primary();
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+            if (stopTracking == null) {
+                continue;
+            }
+
+            tracker.viewAt(sectionPos).forEach(pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    stopTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void onAddChunk(ChunkEntry entry) {
+        ChunkPos chunkPos = entry.getPos();
+        long chunkKey = chunkPos.toLong();
+
+        for (ServerPlayerEntity player : this.players) {
+            int distance = getChunkDistance(player, chunkPos.x, chunkPos.z);
+
+            for (ChunkTrackWatcher tracker : this.trackWatchers) {
+                if (distance > tracker.getRadius()) {
+                    continue;
+                }
+
+                ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+                if (startTracking != null) {
+                    startTracking.accept(player, chunkKey, entry);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onRemoveChunk(ChunkEntry entry) {
+        ChunkPos chunkPos = entry.getPos();
+        long chunkKey = chunkPos.toLong();
+
+        for (ServerPlayerEntity player : this.players) {
+            int distance = getChunkDistance(player, chunkPos.x, chunkPos.z);
+
+            for (ChunkTrackWatcher tracker : this.trackWatchers) {
+                if (distance > tracker.getRadius()) {
+                    continue;
+                }
+
+                ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+                if (stopTracking != null) {
+                    stopTracking.accept(player, chunkKey, entry);
+                }
+            }
+        }
+    }
+
+    public void onChunkFull(ChunkEntry entry, WorldChunk chunk) {
+        ChunkPackets.Data data = ChunkPackets.dataFor(chunk);
+        ChunkPackets.Entities entities = ChunkPackets.entitiesFor(entry);
+
+        Set<ServerPlayerEntity> trackingPlayers = entry.getTrackers().getTrackingPlayers();
+        for (ServerPlayerEntity player : trackingPlayers) {
+            data.sendTo(player);
+            entities.sendTo(player);
+        }
+    }
+
+    public ChunkEntityTrackers getEntities() {
+        return this.entities;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java
new file mode 100644
index 0000000000000000000000000000000000000000..db6ba93b5d532bde66974cc0c674fc4af712fee6
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java
@@ -0,0 +1,185 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.async.lock.JoinLock;
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+import net.gegy1000.tictacs.chunk.entry.ChunkAccessLock;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkRequirement;
+import net.gegy1000.tictacs.chunk.step.ChunkRequirements;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+import java.util.function.Function;
+
+// TODO: ideally we can pool these instances
+final class AcquireChunks {
+    private final ChunkUpgradeKernel kernel;
+
+    private final Lock[] upgradeLocks;
+    private final Lock[] locks;
+
+    private final Lock joinLock;
+    private final Future<Unit> acquireJoinLock;
+
+    final ChunkUpgradeEntries entries;
+    volatile Result acquired;
+
+    AcquireChunks(ChunkUpgrade upgrade) {
+        this.kernel = upgrade.getKernel();
+        this.entries = upgrade.entries;
+
+        this.upgradeLocks = this.kernel.create(Lock[]::new);
+        this.locks = this.kernel.create(Lock[]::new);
+
+        this.joinLock = new JoinLock(
+                new JoinLock(this.upgradeLocks),
+                new JoinLock(this.locks)
+        );
+        this.acquireJoinLock = new Lock.AcquireFuture(this.joinLock);
+    }
+
+    private void clearBuffers() {
+        Arrays.fill(this.upgradeLocks, null);
+        Arrays.fill(this.locks, null);
+    }
+
+    @Nullable
+    public Result poll(Waker waker, ChunkStep step) {
+        if (this.acquired == null) {
+            this.acquired = this.pollAcquire(waker, step);
+            if (this.acquired != Result.OK) {
+                this.clearBuffers();
+            }
+        }
+
+        return this.acquired;
+    }
+
+    @Nullable
+    private Result pollAcquire(Waker waker, ChunkStep step) {
+        Result result = this.collectChunks(step);
+        if (result != Result.OK) {
+            return result;
+        }
+
+        if (this.acquireJoinLock.poll(waker) != null) {
+            return Result.OK;
+        } else {
+            return null;
+        }
+    }
+
+    private Result collectChunks(ChunkStep step) {
+        Lock[] upgradeLocks = this.upgradeLocks;
+        Lock[] locks = this.locks;
+
+        ChunkUpgradeEntries entries = this.entries;
+        ChunkUpgradeKernel kernel = this.kernel;
+        int radiusForStep = kernel.getRadiusFor(step);
+
+        ChunkRequirements requirements = step.getRequirements();
+
+        boolean empty = true;
+
+        for (int z = -radiusForStep; z <= radiusForStep; z++) {
+            for (int x = -radiusForStep; x <= radiusForStep; x++) {
+                ChunkEntry entry = entries.getEntry(x, z);
+                if (!entry.isValidAs(step)) {
+                    return Result.UNLOADED;
+                }
+
+                if (entry.canUpgradeTo(step)) {
+                    entry.trySpawnUpgradeTo(step);
+
+                    int idx = kernel.index(x, z);
+                    upgradeLocks[idx] = entry.getLock().upgrade();
+                    locks[idx] = entry.getLock().write(step.getLock());
+
+                    this.collectContextMargin(x, z, requirements);
+
+                    empty = false;
+                }
+            }
+        }
+
+        return empty ? Result.EMPTY : Result.OK;
+    }
+
+    private void collectContextMargin(int centerX, int centerZ, ChunkRequirements requirements) {
+        int contextRadius = requirements.getRadius();
+        if (contextRadius <= 0) {
+            return;
+        }
+
+        Lock[] locks = this.locks;
+        ChunkUpgradeEntries entries = this.entries;
+        ChunkUpgradeKernel kernel = this.kernel;
+
+        int kernelRadius = kernel.getRadius();
+
+        int minX = Math.max(centerX - contextRadius, -kernelRadius);
+        int maxX = Math.min(centerX + contextRadius, kernelRadius);
+        int minZ = Math.max(centerZ - contextRadius, -kernelRadius);
+        int maxZ = Math.min(centerZ + contextRadius, kernelRadius);
+
+        for (int z = minZ; z <= maxZ; z++) {
+            for (int x = minX; x <= maxX; x++) {
+                int idx = kernel.index(x, z);
+
+                if (locks[idx] == null) {
+                    int distance = Math.max(Math.abs(x - centerX), Math.abs(z - centerZ));
+                    ChunkRequirement requirement = requirements.byDistance(distance);
+
+                    if (requirement != null) {
+                        ChunkEntry entry = entries.getEntry(x, z);
+                        ChunkAccessLock lock = entry.getLock();
+                        ChunkLockType lockType = requirement.step.getLock();
+
+                        if (requirement.write) {
+                            locks[idx] = lock.write(lockType);
+                        } else if (requirement.read) {
+                            locks[idx] = lock.read(lockType);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void release() {
+        if (this.acquired == Result.OK) {
+            this.joinLock.release();
+        }
+
+        this.clearBuffers();
+
+        this.acquired = null;
+    }
+
+    <T> void openUpgradeTasks(Future<T>[] tasks, Function<ChunkEntry, Future<T>> function) {
+        Lock[] upgradeLocks = AcquireChunks.this.upgradeLocks;
+        ChunkUpgradeEntries entries = AcquireChunks.this.entries;
+        ChunkUpgradeKernel kernel = AcquireChunks.this.kernel;
+        int radius = kernel.getRadius();
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                int idx = kernel.index(x, z);
+                if (upgradeLocks[idx] != null) {
+                    tasks[idx] = function.apply(entries.getEntry(x, z));
+                }
+            }
+        }
+    }
+
+    public enum Result {
+        OK,
+        UNLOADED,
+        EMPTY
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..495e4f0c07d913b633177c035a8029a2374ec70f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java
@@ -0,0 +1,55 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+
+final class ChunkLoadFuture implements Future<Chunk> {
+    final ChunkController controller;
+    final ChunkEntry entry;
+
+    volatile Future<Unit> acquireLock;
+    volatile Future<Chunk> loadFuture;
+
+    public ChunkLoadFuture(ChunkController controller, ChunkEntry entry) {
+        this.controller = controller;
+        this.entry = entry;
+    }
+
+    @Nullable
+    @Override
+    public Chunk poll(Waker waker) {
+        Lock upgradeLock = this.entry.getLock().upgrade();
+
+        if (this.loadFuture == null) {
+            if (this.acquireLock == null) {
+                this.acquireLock = upgradeLock.acquireAsync();
+            }
+
+            if (this.acquireLock.poll(waker) == null) {
+                return null;
+            }
+
+            this.loadFuture = this.controller.spawnLoadChunk(this.entry);
+        }
+
+        Chunk chunk = this.loadFuture.poll(waker);
+        if (chunk == null) {
+            return null;
+        }
+
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+        upgrader.notifyUpgradeOk(this.entry, ChunkStep.EMPTY, chunk);
+
+        upgradeLock.release();
+
+        return chunk;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ba894622f74d493d3a5fccc6942b83a5fa4ca2a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java
@@ -0,0 +1,23 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+
+class ChunkUpgrade {
+    final ChunkStep fromStep;
+    final ChunkStep toStep;
+    final ChunkUpgradeEntries entries;
+
+    ChunkUpgrade(ChunkStep fromStep, ChunkStep toStep, ChunkUpgradeEntries entries) {
+        this.fromStep = fromStep;
+        this.toStep = toStep;
+        this.entries = entries;
+    }
+
+    public boolean isEmpty() {
+        return this.toStep.lessOrEqual(this.fromStep);
+    }
+
+    public ChunkUpgradeKernel getKernel() {
+        return ChunkUpgradeKernel.betweenSteps(this.fromStep, this.toStep);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b4948ea3179e060cf1dc9345e6f82cc431701ab
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java
@@ -0,0 +1,27 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import com.google.common.collect.Iterators;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Iterator;
+
+final class ChunkUpgradeEntries implements Iterable<ChunkEntry> {
+    final ChunkUpgradeKernel kernel;
+    final ChunkEntry[] entries;
+
+    ChunkUpgradeEntries(ChunkUpgradeKernel kernel) {
+        this.kernel = kernel;
+        this.entries = kernel.create(ChunkEntry[]::new);
+    }
+
+    @NotNull
+    ChunkEntry getEntry(int x, int z) {
+        return this.entries[this.kernel.index(x, z)];
+    }
+
+    @Override
+    public Iterator<ChunkEntry> iterator() {
+        return Iterators.forArray(this.entries);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..d649304e2cb9ff28cea3eabe8db17e8c79e98e39
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java
@@ -0,0 +1,217 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.Result;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+
+public final class ChunkUpgradeFuture implements Future<Unit> {
+    final ChunkController controller;
+
+    final ChunkEntry entry;
+    final ChunkStep targetStep;
+
+    private final ChunkUpgradeStepper stepper;
+
+    private volatile PrepareUpgradeFuture prepareUpgrade;
+
+    private volatile ChunkUpgrade upgrade;
+    private volatile AcquireChunks acquireChunks;
+
+    private volatile ChunkStep currentStep;
+
+    private volatile Future<Unit> acquireStep;
+    private volatile boolean stepReady;
+
+    public ChunkUpgradeFuture(ChunkController controller, ChunkEntry entry, ChunkStep targetStep) {
+        this.controller = controller;
+        this.entry = entry;
+        this.targetStep = targetStep;
+
+        this.stepper = new ChunkUpgradeStepper(this);
+        this.prepareUpgrade = new PrepareUpgradeFuture(controller, entry, targetStep);
+    }
+
+    @Nullable
+    @Override
+    public Unit poll(Waker waker) {
+        if (this.upgrade == null) {
+            Result<ChunkUpgrade> prepare = this.prepareUpgrade.poll(waker);
+            if (prepare == null) {
+                return null;
+            }
+
+            this.prepareUpgrade = null;
+
+            if (prepare.isError()) {
+                // this chunk is no longer valid to be upgraded: abort
+                this.controller.getUpgrader().notifyUpgradeUnloaded(this.entry, this.targetStep);
+                return Unit.INSTANCE;
+            }
+
+            this.upgrade = prepare.get();
+
+            if (this.upgrade.isEmpty()) {
+                return Unit.INSTANCE;
+            }
+
+            this.currentStep = this.upgrade.fromStep.getNext();
+        }
+
+        while (true) {
+            ChunkStep currentStep = this.currentStep;
+
+            if (!this.pollStepReady(currentStep, waker)) {
+                return null;
+            }
+
+            if (this.acquireChunks == null) {
+                this.acquireChunks = new AcquireChunks(this.upgrade);
+            }
+
+            // poll to acquire read/write access to all the relevant entries
+            AcquireChunks.Result result = this.acquireChunks.poll(waker, currentStep);
+            if (result == null) {
+                return null;
+            }
+
+            // if some of the chunk entries have unloaded since we've started, we can't continue
+            if (result == AcquireChunks.Result.UNLOADED) {
+                return this.returnUnloaded(currentStep);
+            }
+
+            try {
+                if (result == AcquireChunks.Result.OK) {
+                    Chunk[] pollChunks = this.stepper.pollStep(waker, this.upgrade.entries, this.acquireChunks, currentStep);
+                    if (pollChunks == null) {
+                        return null;
+                    }
+
+                    this.notifyUpgrades(pollChunks, currentStep);
+                }
+
+                this.releaseStep();
+            } catch (ChunkNotLoadedException err) {
+                return this.returnUnloaded(currentStep);
+            } catch (Exception e) {
+                TicTacs.LOGGER.error("Failed to generate chunk at {}", this.entry.getPos(), e);
+                return this.returnUnloaded(currentStep);
+            }
+
+            if (currentStep.lessThan(this.targetStep)) {
+                this.currentStep = currentStep.getNext();
+            } else {
+                // we've finished upgrading this chunk!
+                return Unit.INSTANCE;
+            }
+        }
+    }
+
+    private boolean pollStepReady(ChunkStep currentStep, Waker waker) {
+        if (this.stepReady) {
+            return true;
+        }
+
+        if (this.acquireStep == null) {
+            ChunkStep.Acquire acquire = currentStep.getAcquireTask();
+            if (acquire == null) {
+                this.stepReady = true;
+                return true;
+            }
+
+            this.acquireStep = acquire.acquire(this.controller);
+        }
+
+        if (this.acquireStep.poll(waker) != null) {
+            this.stepReady = true;
+            this.acquireStep = null;
+            return true;
+        }
+
+        return false;
+    }
+
+    private Unit returnUnloaded(ChunkStep currentStep) {
+        this.notifyUpgradeUnloaded(currentStep);
+        this.releaseStep();
+
+        return Unit.INSTANCE;
+    }
+
+    private void releaseStep() {
+        this.stepper.reset();
+        this.acquireChunks.release();
+
+        ChunkStep.Release releaseTask = this.currentStep.getReleaseTask();
+        if (releaseTask != null) {
+            releaseTask.release(this.controller);
+        }
+
+        this.acquireChunks = null;
+        this.acquireStep = null;
+        this.stepReady = false;
+    }
+
+    private void notifyUpgrades(Chunk[] chunks, ChunkStep step) {
+        ChunkUpgradeEntries entries = this.upgrade.entries;
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        ChunkUpgradeKernel kernel = this.upgrade.getKernel();
+        int radius = kernel.getRadiusFor(step);
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                Chunk chunk = chunks[kernel.index(x, z)];
+                if (chunk != null) {
+                    ChunkEntry entry = entries.getEntry(x, z);
+                    upgrader.notifyUpgradeOk(entry, step, chunk);
+                }
+            }
+        }
+    }
+
+    private void notifyUpgradeUnloaded(ChunkStep step) {
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        upgrader.notifyUpgradeUnloaded(this.entry, step);
+
+        // let the chunk entries know that we're not trying to upgrade them anymore
+        for (ChunkEntry entry : this.upgrade.entries) {
+            entry.notifyUpgradeCanceled(step);
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder display = new StringBuilder();
+        display.append("upgrading ").append(this.entry.getPos()).append(" to ").append(this.targetStep).append(": ");
+
+        if (this.upgrade != null) {
+            if (this.currentStep.greaterOrEqual(this.targetStep) && this.stepReady && this.acquireChunks.acquired != null) {
+                display.append("ready!");
+            } else {
+                if (this.stepReady) {
+                    if (this.acquireChunks.acquired != null) {
+                        display.append("waiting for upgrade to ").append(this.currentStep);
+                    } else {
+                        display.append("waiting to acquire entry locks @").append(this.currentStep);
+                    }
+                } else {
+                    display.append("waiting for ").append(this.currentStep).append(" to be ready");
+                }
+            }
+        } else {
+            display.append("preparing upgrade");
+        }
+
+        return display.toString();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java
new file mode 100644
index 0000000000000000000000000000000000000000..24677d0bac44ba339a034efc71340eca025b0c79
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java
@@ -0,0 +1,88 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.step.StepKernelResolver;
+
+import java.util.List;
+import java.util.function.IntFunction;
+
+public final class ChunkUpgradeKernel {
+    private static final List<ChunkStep> STEPS = ChunkStep.STEPS;
+    private static final int STEP_COUNT = STEPS.size();
+
+    private static final ChunkUpgradeKernel[] BETWEEN_STEPS = new ChunkUpgradeKernel[STEP_COUNT * STEP_COUNT];
+
+    static {
+        // TODO: this table can be more compact by not having null entries
+        for (int fromIdx = 0; fromIdx < STEP_COUNT; fromIdx++) {
+            ChunkStep from = ChunkStep.byIndex(fromIdx - 1);
+
+            for (int toIdx = fromIdx - 1; toIdx < STEP_COUNT; toIdx++) {
+                ChunkStep to = ChunkStep.byIndex(toIdx);
+                if (to == null) {
+                    continue;
+                }
+
+                BETWEEN_STEPS[toIdx + fromIdx * STEP_COUNT] = new ChunkUpgradeKernel(from, to);
+            }
+        }
+    }
+
+    private final ChunkStep from;
+    private final ChunkStep to;
+    private final int radius;
+    private final int size;
+
+    private ChunkUpgradeKernel(ChunkStep from, ChunkStep to) {
+        if (to.lessThan(from)) {
+            throw new IllegalArgumentException(from + " > " + to);
+        }
+
+        this.from = from;
+        this.to = to;
+
+        this.radius = to != from ? StepKernelResolver.effectiveRadiusFor(to, from) : 0;
+        this.size = this.radius * 2 + 1;
+    }
+
+    public static ChunkUpgradeKernel forStep(ChunkStep step) {
+        return BETWEEN_STEPS[step.getIndex()];
+    }
+
+    public static ChunkUpgradeKernel betweenSteps(ChunkStep from, ChunkStep to) {
+        if (to.lessThan(from)) {
+            throw new IllegalArgumentException(from + " > " + to);
+        }
+
+        int fromIdx = from != null ? from.getIndex() + 1 : 0;
+        int toIdx = to.getIndex();
+        return BETWEEN_STEPS[toIdx + fromIdx * STEP_COUNT];
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+
+    public int getRadiusFor(ChunkStep step) {
+        return ChunkStep.getDistanceFromFull(step) - ChunkStep.getDistanceFromFull(this.to);
+    }
+
+    public int getSize() {
+        return this.size;
+    }
+
+    public int index(int x, int z) {
+        int radius = this.radius;
+        if (TicTacs.DEBUG) {
+            if (x < -radius || z < -radius || x > radius || z > radius) {
+                throw new IllegalArgumentException("[" + x + "; " + z + "] out of radius=" + this.radius);
+            }
+        }
+        return (x + radius) + (z + radius) * this.size;
+    }
+
+    public <T> T create(IntFunction<T> function) {
+        return function.apply(this.size * this.size);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b98a9d166819a817e697f9300b4ceba8f3889266
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java
@@ -0,0 +1,164 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.AtomicPool;
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.JoinAllArray;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.Chunk;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.AbstractList;
+import java.util.Arrays;
+
+final class ChunkUpgradeStepper {
+    private static final AtomicPool<ContextView> CONTEXT_POOL = new AtomicPool<>(512, ContextView::new);
+    private static final AtomicPool<TaskWithContext> TASK_POOL = new AtomicPool<>(512, TaskWithContext::new);
+
+    private final ChunkUpgradeFuture parent;
+
+    private final Future<Chunk>[] tasks;
+    private final Chunk[] chunks;
+
+    private volatile boolean pollingTasks;
+
+    @SuppressWarnings("unchecked")
+    ChunkUpgradeStepper(ChunkUpgradeFuture parent) {
+        this.parent = parent;
+
+        ChunkUpgradeKernel kernel = ChunkUpgradeKernel.forStep(parent.targetStep);
+        this.tasks = kernel.create(Future[]::new);
+        this.chunks = kernel.create(Chunk[]::new);
+    }
+
+    void reset() {
+        this.pollingTasks = false;
+        Arrays.fill(this.chunks, null);
+        Arrays.fill(this.tasks, null);
+    }
+
+    @Nullable
+    Chunk[] pollStep(Waker waker, ChunkUpgradeEntries entries, AcquireChunks chunks, ChunkStep step) {
+        Future<Chunk>[] tasks = this.tasks;
+
+        if (!this.pollingTasks) {
+            this.pollingTasks = true;
+            this.openUpgradeTasks(entries, chunks, step, tasks);
+        }
+
+        return JoinAllArray.poll(waker, tasks, this.chunks);
+    }
+
+    private void openUpgradeTasks(ChunkUpgradeEntries entries, AcquireChunks chunks, ChunkStep step, Future<Chunk>[] tasks) {
+        chunks.openUpgradeTasks(tasks, entry -> this.upgradeChunk(entry, entries, step));
+    }
+
+    private Future<Chunk> upgradeChunk(ChunkEntry entry, ChunkUpgradeEntries entries, ChunkStep step) {
+        ContextView context = this.openContext(entry, entries, step);
+
+        Future<Chunk> future = this.parent.controller.getUpgrader().runStepTask(entry, step, context);
+        return this.createTaskWithContext(future, context);
+    }
+
+    private ContextView openContext(ChunkEntry entry, ChunkUpgradeEntries entries, ChunkStep step) {
+        ContextView context = CONTEXT_POOL.acquire();
+        ChunkPos targetPos = entry.getPos();
+
+        int targetRadius = step.getRequirements().getRadius();
+        context.open(this.parent.entry.pos, entries, targetPos, targetRadius);
+
+        return context;
+    }
+
+    private TaskWithContext createTaskWithContext(Future<Chunk> future, ContextView context) {
+        TaskWithContext task = TASK_POOL.acquire();
+        task.future = future;
+        task.context = context;
+
+        return task;
+    }
+
+    static class TaskWithContext implements Future<Chunk> {
+        Future<Chunk> future;
+        ContextView context;
+
+        @Nullable
+        @Override
+        public Chunk poll(Waker waker) {
+            Chunk poll = this.future.poll(waker);
+            if (poll != null) {
+                this.release();
+                return poll;
+            }
+
+            return null;
+        }
+
+        void release() {
+            this.context.release();
+
+            this.future = null;
+            this.context = null;
+
+            TASK_POOL.release(this);
+        }
+    }
+
+    static class ContextView extends AbstractList<Chunk> {
+        private ChunkUpgradeEntries source;
+        private int targetSize;
+
+        private int targetToSourceOffsetX;
+        private int targetToSourceOffsetZ;
+
+        void open(
+                ChunkPos sourceOrigin, ChunkUpgradeEntries source,
+                ChunkPos targetOrigin, int targetRadius
+        ) {
+            this.source = source;
+            this.targetSize = targetRadius * 2 + 1;
+
+            this.targetToSourceOffsetX = (targetOrigin.x - targetRadius) - sourceOrigin.x;
+            this.targetToSourceOffsetZ = (targetOrigin.z - targetRadius) - sourceOrigin.z;
+
+            if (TicTacs.DEBUG) {
+                if (targetRadius > source.kernel.getRadius()) {
+                    throw new IllegalStateException("target radius larger than source radius");
+                }
+
+                Chunk chunk = this.get(this.size() / 2);
+                if (chunk == null) {
+                    throw new IllegalStateException("center chunk is null");
+                }
+
+                if (!chunk.getPos().equals(targetOrigin)) {
+                    throw new IllegalStateException("center chunk pos does not match target pos");
+                }
+            }
+        }
+
+        @Override
+        public Chunk get(int targetIndex) {
+            int targetX = targetIndex % this.targetSize;
+            int targetZ = targetIndex / this.targetSize;
+            int sourceX = targetX + this.targetToSourceOffsetX;
+            int sourceZ = targetZ + this.targetToSourceOffsetZ;
+
+            ChunkEntry entry = this.source.getEntry(sourceX, sourceZ);
+            return entry.getProtoChunk();
+        }
+
+        @Override
+        public int size() {
+            return this.targetSize * this.targetSize;
+        }
+
+        void release() {
+            this.source = null;
+            CONTEXT_POOL.release(this);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java
new file mode 100644
index 0000000000000000000000000000000000000000..55d09d2e532c1bf2b031b3334bf7d22a1c35d98e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java
@@ -0,0 +1,99 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.async.lock.NullLock;
+import net.gegy1000.tictacs.async.lock.Semaphore;
+import net.gegy1000.tictacs.async.worker.ChunkExecutor;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.step.ChunkStepContext;
+import net.gegy1000.tictacs.compatibility.TicTacsCompatibility;
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+
+import java.util.List;
+
+public final class ChunkUpgrader {
+    private final ChunkExecutor worker = ChunkExecutor.INSTANCE;
+
+    private final ChunkController controller;
+
+    private final ServerWorld world;
+    private final ChunkGenerator generator;
+    private final StructureManager structures;
+    private final ServerLightingProvider lighting;
+
+    public final Lock lightingThrottler = TicTacsCompatibility.STARLIGHT_LOADED ? NullLock.INSTANCE : new Semaphore(32);
+
+    public ChunkUpgrader(
+            ServerWorld world,
+            ChunkController controller,
+            ChunkGenerator generator,
+            StructureManager structures,
+            ServerLightingProvider lighting
+    ) {
+        this.world = world;
+        this.generator = generator;
+        this.structures = structures;
+        this.lighting = lighting;
+
+        this.controller = controller;
+    }
+
+    public void spawnUpgradeTo(ChunkEntry entry, ChunkStep step) {
+        if (entry.trySpawnUpgradeTo(step)) {
+            this.worker.spawn(entry, this.upgradeTo(entry, step));
+        }
+    }
+
+    public Future<Chunk> loadChunk(ChunkEntry entry) {
+        if (entry.trySpawnLoad()) {
+            return new ChunkLoadFuture(this.controller, entry);
+        } else {
+            return entry.getListenerFor(ChunkStep.EMPTY);
+        }
+    }
+
+    private Future<Unit> upgradeTo(ChunkEntry entry, ChunkStep step) {
+        // TODO: pool instances
+        return new ChunkUpgradeFuture(this.controller, entry, step);
+    }
+
+    Future<Chunk> runStepTask(ChunkEntry entry, ChunkStep step, List<Chunk> chunks) {
+        // TODO: reuse context objects
+        ChunkStepContext context = new ChunkStepContext(this.controller, entry, this.world, this.generator, this.structures, this.lighting, entry.getProtoChunk(), chunks);
+
+        if (this.hasAlreadyUpgradedTo(entry, step)) {
+            return step.runLoad(context);
+        } else {
+            return step.runUpgrade(context);
+        }
+    }
+
+    private boolean hasAlreadyUpgradedTo(ChunkEntry entry, ChunkStep step) {
+        ProtoChunk currentChunk = entry.getProtoChunk();
+        return currentChunk != null && currentChunk.getStatus().isAtLeast(step.getMaximumStatus());
+    }
+
+    void notifyUpgradeOk(ChunkEntry entry, ChunkStep step, Chunk chunk) {
+        entry.completeUpgradeOk(step, chunk);
+
+        ChunkStatus status = step.getMaximumStatus();
+
+        this.controller.notifyStatus(entry.getPos(), status);
+        ChunkStep.trySetStatus(chunk, status);
+    }
+
+    void notifyUpgradeUnloaded(ChunkEntry entry, ChunkStep step) {
+        entry.notifyUpgradeUnloaded(step);
+        this.controller.notifyStatus(entry.getPos(), null);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..0258300df645258378f2967844a148553d86baba
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java
@@ -0,0 +1,226 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.justnow.Waker;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.JoinAllArray;
+import net.gegy1000.tictacs.chunk.future.Result;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ProtoChunk;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.Arrays;
+
+class PrepareUpgradeFuture implements Future<Result<ChunkUpgrade>> {
+    final ChunkController controller;
+
+    final ChunkEntry entry;
+    final ChunkStep targetStep;
+
+    private volatile ChunkStep fromStep;
+
+    private volatile ChunkUpgradeEntries entries;
+    private volatile Future<Chunk>[] loadFutures;
+    private volatile Chunk[] loadedChunks;
+
+    private volatile boolean collectedEntries;
+
+    private volatile Future<Unit> flushListener;
+
+    PrepareUpgradeFuture(ChunkController controller, ChunkEntry entry, ChunkStep targetStep) {
+        this.controller = controller;
+        this.entry = entry;
+        this.targetStep = targetStep;
+
+        // we don't want to do redundant work for generating neighbors if this chunk is already loaded
+        // the only exception for this is where the chunk step has an on-load task that need to run with context
+        this.fromStep = ChunkStep.min(this.targetStep, ChunkStep.MIN_WITH_LOAD_TASK.getPrevious());
+    }
+
+    @Nullable
+    @Override
+    public Result<ChunkUpgrade> poll(Waker waker) {
+        // this chunk is no longer valid to be upgraded to our target
+        if (!this.entry.isValidAs(this.targetStep)) {
+            return Result.error();
+        }
+
+        // we iterate downwards until we find a step that we can safely upgrade from
+        while (true) {
+            // we first need to collect all the required chunk entries
+            if (!this.collectedEntries) {
+                if (this.entries == null) {
+                    this.entries = new ChunkUpgradeEntries(ChunkUpgradeKernel.betweenSteps(this.fromStep, this.targetStep));
+                }
+
+                if (!this.pollCollectEntries(waker, this.entries)) {
+                    return null;
+                }
+
+                this.collectedEntries = true;
+            }
+
+            // we then need to load the relevant chunks from disk to test if this upgrade is valid
+            Chunk[] chunks = this.pollLoadChunks(waker, this.entries);
+            if (chunks == null) {
+                return null;
+            }
+
+            ChunkStep newStep = this.tryStep(chunks);
+            if (newStep == null) {
+                // we've loaded enough context
+                this.notifyChunkLoads(chunks);
+                return Result.ok(new ChunkUpgrade(this.fromStep, this.targetStep, this.entries));
+            }
+
+            this.fromStep = newStep;
+
+            this.entries = null;
+            this.loadFutures = null;
+            this.loadedChunks = null;
+            this.collectedEntries = false;
+        }
+    }
+
+    private void notifyChunkLoads(Chunk[] chunks) {
+        ChunkUpgradeKernel kernel = this.entries.kernel;
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        int radius = kernel.getRadius();
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                ChunkEntry entry = this.entries.getEntry(x, z);
+                if (entry.canUpgradeTo(this.fromStep)) {
+                    Chunk chunk = chunks[kernel.index(x, z)];
+                    upgrader.notifyUpgradeOk(entry, this.fromStep, chunk);
+                }
+            }
+        }
+    }
+
+    @Nullable
+    private ChunkStep tryStep(Chunk[] chunks) {
+        // we have reached the lowest step
+        if (this.fromStep == ChunkStep.EMPTY) {
+            return null;
+        }
+
+        ChunkStep minimumStep = this.getMinimumStepFor(chunks);
+
+        // the lowest step in this area is greater than or equal to the step we are trying to upgrade from
+        if (this.fromStep.lessOrEqual(minimumStep)) {
+            return null;
+        }
+
+        // we try upgrade from the lowest step in the area
+        return minimumStep;
+    }
+
+    @Nullable
+    private ChunkStep getMinimumStepFor(Chunk[] chunks) {
+        ChunkStep minimumStep = ChunkStep.FULL;
+
+        for (Chunk chunk : chunks) {
+            ChunkStep step = ChunkStep.byFullStatus(chunk.getStatus());
+            if (step == ChunkStep.EMPTY) {
+                return ChunkStep.EMPTY;
+            }
+
+            if (step.lessThan(minimumStep)) {
+                minimumStep = step;
+            }
+        }
+
+        return minimumStep;
+    }
+
+    private boolean pollCollectEntries(Waker waker, ChunkUpgradeEntries entries) {
+        if (this.flushListener != null) {
+            if (this.flushListener.poll(waker) == null) {
+                return false;
+            } else {
+                this.flushListener = null;
+            }
+        }
+
+        while (true) {
+            ChunkAccess chunks = this.controller.getMap().visible();
+
+            // acquire a flush listener now so that we can be sure nothing has changed since we checked the entries
+            ChunkMap.FlushListener flushListener = this.controller.getMap().awaitFlush();
+
+            // not all of the required entries are loaded: wait for the entry list to update
+            if (!this.tryCollectEntries(chunks, entries)) {
+                // if a flush has happened since we last checked, try again now
+                if (flushListener.poll(waker) != null) {
+                    continue;
+                }
+
+                this.flushListener = flushListener;
+                return false;
+            }
+
+            // we have everything we need: we don't need to listen for flushes anymore
+            flushListener.invalidateWaker();
+
+            return true;
+        }
+    }
+
+    private boolean tryCollectEntries(ChunkAccess chunks, ChunkUpgradeEntries entries) {
+        int originX = this.entry.pos.x;
+        int originZ = this.entry.pos.z;
+
+        ChunkEntry[] array = this.entries.entries;
+        ChunkUpgradeKernel kernel = entries.kernel;
+        int radius = kernel.getRadius();
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                ChunkEntry entry = chunks.getEntry(x + originX, z + originZ);
+
+                // all chunk entries must be available before upgrading
+                if (entry == null) {
+                    Arrays.fill(array, null);
+                    return false;
+                }
+
+                array[kernel.index(x, z)] = entry;
+            }
+        }
+
+        return true;
+    }
+
+    @Nullable
+    private Chunk[] pollLoadChunks(Waker waker, ChunkUpgradeEntries entries) {
+        ChunkUpgradeKernel kernel = entries.kernel;
+        int radius = kernel.getRadius();
+
+        if (this.loadFutures == null) {
+            this.loadFutures = kernel.create(Future[]::new);
+            this.loadedChunks = kernel.create(Chunk[]::new);
+            ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+            for (int z = -radius; z <= radius; z++) {
+                for (int x = -radius; x <= radius; x++) {
+                    ChunkEntry entry = entries.getEntry(x, z);
+
+                    ProtoChunk chunk = entry.getProtoChunk();
+                    if (chunk != null) {
+                        this.loadedChunks[kernel.index(x, z)] = chunk;
+                    } else {
+                        this.loadFutures[kernel.index(x, z)] = upgrader.loadChunk(entry);
+                    }
+                }
+            }
+        }
+
+        return JoinAllArray.poll(waker, this.loadFutures, this.loadedChunks);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/client/DebugRendererExt.java b/src/main/java/net/gegy1000/tictacs/client/DebugRendererExt.java
new file mode 100644
index 0000000000000000000000000000000000000000..779493c629a04fce24f81910642228b91deb1465
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/client/DebugRendererExt.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.client;
+
+public interface DebugRendererExt {
+	TicTacsDebugRenderer get();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/client/LevelMapOverlay.java b/src/main/java/net/gegy1000/tictacs/client/LevelMapOverlay.java
new file mode 100644
index 0000000000000000000000000000000000000000..f24478f9feb22b89e01a26cfcea0242c35496a8c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/client/LevelMapOverlay.java
@@ -0,0 +1,74 @@
+package net.gegy1000.tictacs.client;
+
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.gui.DrawableHelper;
+import net.minecraft.client.texture.NativeImage;
+import net.minecraft.client.texture.NativeImageBackedTexture;
+import net.minecraft.client.util.math.MatrixStack;
+import net.minecraft.client.world.ClientWorld;
+import net.minecraft.server.integrated.IntegratedServer;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.Identifier;
+
+public final class LevelMapOverlay extends DrawableHelper implements AutoCloseable {
+    private static final MinecraftClient CLIENT = MinecraftClient.getInstance();
+    private static final Identifier TEXTURE_ID = new Identifier(TicTacs.ID, "level_map");
+
+    private NativeImageBackedTexture texture;
+    private int textureWidth;
+    private int textureHeight;
+
+    private long lastTextureUpdate;
+
+    public void render(MatrixStack transform) {
+        ClientWorld clientWorld = CLIENT.world;
+        if (clientWorld == null) {
+            return;
+        }
+
+        IntegratedServer server = CLIENT.getServer();
+        if (server == null) {
+            return;
+        }
+
+        long time = clientWorld.getTime();
+        if (time - this.lastTextureUpdate > 20) {
+            ServerWorld serverWorld = server.getWorld(clientWorld.getRegistryKey());
+            ThreadedAnvilChunkStorage tacs = serverWorld.getChunkManager().threadedAnvilChunkStorage;
+            ChunkController controller = (ChunkController) tacs;
+
+            NativeImage image = LevelMapRenderer.render(CLIENT.player.getPos(), controller);
+            this.updateTexture(image);
+
+            this.lastTextureUpdate = time;
+        }
+
+        CLIENT.getTextureManager().bindTexture(TEXTURE_ID);
+        DrawableHelper.drawTexture(transform, 0, 0, 0.0F, 0.0F, this.textureWidth, this.textureHeight, this.textureWidth, this.textureHeight);
+    }
+
+    private void updateTexture(NativeImage image) {
+        this.releaseTexture();
+
+        this.texture = new NativeImageBackedTexture(image);
+        this.textureWidth = image.getWidth();
+        this.textureHeight = image.getHeight();
+
+        CLIENT.getTextureManager().registerTexture(TEXTURE_ID, this.texture);
+    }
+
+    @Override
+    public void close() {
+        this.releaseTexture();
+        CLIENT.getTextureManager().destroyTexture(TEXTURE_ID);
+    }
+
+    private void releaseTexture() {
+        if (this.texture != null) {
+            this.texture.close();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/client/LevelMapRenderer.java b/src/main/java/net/gegy1000/tictacs/client/LevelMapRenderer.java
new file mode 100644
index 0000000000000000000000000000000000000000..9044d3fd701205ca152184e90157993b326acf27
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/client/LevelMapRenderer.java
@@ -0,0 +1,190 @@
+package net.gegy1000.tictacs.client;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.client.texture.NativeImage;
+import net.minecraft.client.util.Rect2i;
+import net.minecraft.server.world.ChunkTicket;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.util.Util;
+import net.minecraft.util.collection.SortedArraySet;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
+
+import java.util.Collection;
+
+public final class LevelMapRenderer {
+    private static final Object2IntMap<ChunkStep> STATUS_TO_COLOR = Util.make(new Object2IntOpenHashMap<>(), map -> {
+        map.defaultReturnValue(0);
+        map.put(ChunkStep.EMPTY, 0xFF545454);
+        map.put(ChunkStep.STRUCTURE_STARTS, 0xFF999999);
+        map.put(ChunkStep.SURFACE, 0xFF723530);
+        map.put(ChunkStep.FEATURES, 0xFF00C621);
+        map.put(ChunkStep.LIGHTING, 0xFFA0A0A0);
+        map.put(ChunkStep.FULL, 0xFFFFFFFF);
+    });
+
+    private static final int TICKABLE = 0xFF0000FF;
+    private static final int ENTITY_TICKABLE = 0xFF00FFFF;
+
+    private static final int MAX_LEVEL = ChunkLevelTracker.MAX_LEVEL + 1;
+
+    private static final RenderType TYPE = RenderType.STEP;
+
+    public static NativeImage render(Vec3d camera, ChunkController controller) {
+        ChunkAccess map = controller.getMap().visible();
+        Collection<ChunkEntry> entries = map.getEntries();
+
+        Rect2i bounds = computeBounds(entries);
+
+        NativeImage image;
+        switch (TYPE) {
+            case STEP:
+                image = renderSteps(map, bounds);
+                break;
+            case LEVEL:
+                image = renderLeveled(controller, map, bounds);
+                break;
+            default: throw new UnsupportedOperationException();
+        }
+
+        int cameraX = MathHelper.floor(camera.x / 16.0) - bounds.getX();
+        int cameraZ = MathHelper.floor(camera.z / 16.0) - bounds.getY();
+
+        if (cameraX >= 0 && cameraZ >= 0 && cameraX < bounds.getWidth() && cameraZ < bounds.getHeight()) {
+            image.setPixelColor(cameraX, cameraZ, 0xFF0000FF);
+        }
+
+        return image;
+    }
+
+    private static NativeImage renderSteps(ChunkAccess map, Rect2i bounds) {
+        int minX = bounds.getX();
+        int minY = bounds.getY();
+
+        int width = bounds.getWidth();
+        int height = bounds.getHeight();
+
+        NativeImage image = new NativeImage(width, height, false);
+
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                long pos = ChunkPos.toLong(x + minX, y + minY);
+                ChunkEntry entry = map.getEntry(pos);
+
+                int color = 0;
+                if (entry != null && ChunkLevelTracker.isLoaded(entry.getLevel())) {
+                    color = getColorForChunk(entry);
+                }
+
+                image.setPixelColor(x, y, color);
+            }
+        }
+
+        return image;
+    }
+
+    private static int getColorForChunk(ChunkEntry entry) {
+        ChunkStep currentStep = entry.getCurrentStep();
+        if (currentStep != null) {
+            if (entry.isTickingEntities()) {
+                return ENTITY_TICKABLE;
+            }
+
+            if (entry.isTicking()) {
+                return TICKABLE;
+            }
+
+            return STATUS_TO_COLOR.getInt(currentStep);
+        }
+
+        return 0;
+    }
+
+    private static NativeImage renderLeveled(ChunkController controller, ChunkAccess map, Rect2i bounds) {
+        ChunkTicketManager ticketManager = controller.getTicketManager();
+
+        int minX = bounds.getX();
+        int minY = bounds.getY();
+
+        int width = bounds.getWidth();
+        int height = bounds.getHeight();
+
+        NativeImage image = new NativeImage(width, height, false);
+
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                long pos = ChunkPos.toLong(x + minX, y + minY);
+                ChunkEntry entry = map.getEntry(pos);
+
+                SortedArraySet<ChunkTicket<?>> tickets = ticketManager.ticketsByPosition.get(pos);
+                if (tickets != null && !tickets.isEmpty()) {
+                    boolean player = false;
+                    boolean light = false;
+                    for (ChunkTicket<?> ticket : tickets) {
+                        ChunkTicketType<?> type = ticket.getType();
+                        if (type == ChunkTicketType.PLAYER) player = true;
+                        if (type == ChunkTicketType.LIGHT) light = true;
+                    }
+
+                    int color = 0xFF0000FF;
+                    if (player) color |= 0xFF0000; // blue
+                    if (light) color |= 0xFF00; // green
+
+                    image.setPixelColor(x, y, color);
+
+                    continue;
+                }
+
+                if (entry != null && ChunkLevelTracker.isLoaded(entry.getLevel())) {
+                    int level = entry.getLevel();
+                    int levelRange = MAX_LEVEL - ChunkLevelTracker.FULL_LEVEL;
+
+                    int renderLevel = Math.max(level, ChunkLevelTracker.FULL_LEVEL) - ChunkLevelTracker.FULL_LEVEL;
+
+                    int brightness = (levelRange - renderLevel) * 255 / levelRange;
+                    int color = (0xFF << 24) | (brightness << 16) | (brightness << 8) | brightness;
+
+                    image.setPixelColor(x, y, color);
+                } else {
+                    image.setPixelColor(x, y, 0xFFFF0000);
+                }
+            }
+        }
+
+        return image;
+    }
+
+    private static Rect2i computeBounds(Collection<ChunkEntry> entries) {
+        int minX = Integer.MAX_VALUE;
+        int minZ = Integer.MAX_VALUE;
+        int maxX = Integer.MIN_VALUE;
+        int maxZ = Integer.MIN_VALUE;
+
+        for (ChunkEntry entry : entries) {
+            ChunkPos pos = entry.getPos();
+            int x = pos.x;
+            int z = pos.z;
+
+            if (x < minX) minX = x;
+            if (x > maxX) maxX = x;
+
+            if (z < minZ) minZ = z;
+            if (z > maxZ) maxZ = z;
+        }
+
+        return new Rect2i(minX, minZ, maxX - minX, maxZ - minZ);
+    }
+
+    private enum RenderType {
+        LEVEL,
+        STEP
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugLevelTracker.java b/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugLevelTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe3eaf8bf4ec4a4319d30d36637032e3450270fd
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugLevelTracker.java
@@ -0,0 +1,44 @@
+package net.gegy1000.tictacs.client;
+
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+
+public final class TicTacsDebugLevelTracker {
+    public static final TicTacsDebugLevelTracker INSTANCE = new TicTacsDebugLevelTracker();
+
+    private final Long2IntMap levels = new Long2IntOpenHashMap();
+    private final Long2LongMap redTime = new Long2LongOpenHashMap();
+
+    private TicTacsDebugLevelTracker() {
+        this.levels.defaultReturnValue(ChunkLevelTracker.MAX_LEVEL + 1);
+    }
+
+    public void setLevel(long pos, int level) {
+        if (ChunkLevelTracker.isUnloaded(level)) {
+            this.levels.remove(pos);
+            this.redTime.remove(pos);
+            return;
+        }
+
+        int prevLevel = this.levels.put(pos, level);
+        if (prevLevel != level) {
+            this.redTime.put(pos, System.currentTimeMillis() + 2000);
+        }
+    }
+
+    public int getLevel(long pos) {
+        return this.levels.get(pos);
+    }
+
+    public long getRedTime(long pos) {
+        return this.redTime.get(pos);
+    }
+
+    public LongCollection chunks() {
+        return this.levels.keySet();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugRenderer.java b/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugRenderer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d12af19da9c0e109ebee5fb82bab9a72e4bb4e3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/client/TicTacsDebugRenderer.java
@@ -0,0 +1,49 @@
+package net.gegy1000.tictacs.client;
+
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.systems.RenderSystem;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.api.Environment;
+import net.minecraft.client.render.VertexConsumerProvider;
+import net.minecraft.client.render.debug.DebugRenderer;
+import net.minecraft.client.util.math.MatrixStack;
+import net.minecraft.util.math.ChunkPos;
+
+@Environment(EnvType.CLIENT)
+public class TicTacsDebugRenderer implements DebugRenderer.Renderer {
+	@Override
+	public void render(MatrixStack matrices, VertexConsumerProvider vertexConsumers, double cameraX, double cameraY, double cameraZ) {
+		RenderSystem.pushMatrix();
+		RenderSystem.enableBlend();
+		RenderSystem.blendFuncSeparate(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SrcFactor.ONE, GlStateManager.DstFactor.ZERO);
+		RenderSystem.color4f(0.0F, 1.0F, 0.0F, 0.75F);
+		RenderSystem.disableTexture();
+
+		long systime = System.currentTimeMillis();
+
+		TicTacsDebugLevelTracker tracker = TicTacsDebugLevelTracker.INSTANCE;
+
+		LongIterator iterator = tracker.chunks().iterator();
+		while (iterator.hasNext()) {
+			long pos = iterator.nextLong();
+			int chunkX = ChunkPos.getPackedX(pos);
+			int chunkZ = ChunkPos.getPackedZ(pos);
+
+			int level = tracker.getLevel(pos);
+			long redTime = tracker.getRedTime(pos);
+
+			double x = (chunkX << 4) + 8.5;
+			double y = 128 + 1.2;
+			double z = (chunkZ << 4) + 8.5;
+
+			int color = systime <= redTime ? 0xff0000 : -1;
+
+			DebugRenderer.drawString(String.valueOf(level), x, y, z, color, 0.25F, true, 0.0F, true);
+		}
+
+		RenderSystem.enableTexture();
+		RenderSystem.disableBlend();
+		RenderSystem.popMatrix();
+	}
+}
diff --git a/src/main/java/net/gegy1000/tictacs/compatibility/PhosphorServerLightingProviderAccess.java b/src/main/java/net/gegy1000/tictacs/compatibility/PhosphorServerLightingProviderAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..10e648ff68f514d03c32f956ecc28662c437452c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/compatibility/PhosphorServerLightingProviderAccess.java
@@ -0,0 +1,9 @@
+package net.gegy1000.tictacs.compatibility;
+
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface PhosphorServerLightingProviderAccess {
+    CompletableFuture<Chunk> setupLightmaps(Chunk chunk);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/compatibility/TicTacsCompatibility.java b/src/main/java/net/gegy1000/tictacs/compatibility/TicTacsCompatibility.java
new file mode 100644
index 0000000000000000000000000000000000000000..74c5a241aa440b59fb5c44bea0d41f23e331ccea
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/compatibility/TicTacsCompatibility.java
@@ -0,0 +1,31 @@
+package net.gegy1000.tictacs.compatibility;
+
+import net.fabricmc.loader.api.FabricLoader;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.tictacs.chunk.future.FutureHandle;
+import net.gegy1000.tictacs.chunk.step.ChunkStepContext;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.concurrent.CompletableFuture;
+
+public final class TicTacsCompatibility {
+    public static final boolean STARLIGHT_LOADED = FabricLoader.getInstance().isModLoaded("starlight");
+    public static final boolean PHOSPHOR_LOADED = FabricLoader.getInstance().isModLoaded("phosphor");
+
+    public static Future<Chunk> afterFeaturesStep(ChunkStepContext ctx) {
+        if (PHOSPHOR_LOADED) {
+            return afterFeaturesStepPhosphor(ctx);
+        } else {
+            return Future.ready(ctx.chunk);
+        }
+    }
+
+    private static Future<Chunk> afterFeaturesStepPhosphor(ChunkStepContext ctx) {
+        FutureHandle<Chunk> handle = new FutureHandle<>();
+
+        CompletableFuture<Chunk> future = ((PhosphorServerLightingProviderAccess) ctx.lighting).setupLightmaps(ctx.chunk);
+        future.thenAccept(handle::complete);
+
+        return handle;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/config/TicTacsConfig.java b/src/main/java/net/gegy1000/tictacs/config/TicTacsConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..2582d4fda46ad94c3fb266fd2765bbae1cb0bb95
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/config/TicTacsConfig.java
@@ -0,0 +1,102 @@
+package net.gegy1000.tictacs.config;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.annotations.SerializedName;
+import net.gegy1000.tictacs.TicTacs;
+import net.minecraft.util.math.MathHelper;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.Reader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+public final class TicTacsConfig {
+    public static final int VERSION = 2;
+
+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
+
+    private static TicTacsConfig config;
+
+    public int version = VERSION;
+
+    @SerializedName("thread_count")
+    public int threadCount = computeDefaultThreadCount();
+
+    @SerializedName("max_view_distance")
+    public int maxViewDistance = 32;
+
+    @SerializedName("feature_generation_radius")
+    public int featureGenerationRadius = 2;
+
+    @SerializedName("debug")
+    public Debug debug = new Debug();
+
+    public static class Debug {
+        @SerializedName("chunk_levels")
+        public boolean chunkLevels;
+
+        @SerializedName("chunk_map")
+        public boolean chunkMap;
+    }
+
+    private static int computeDefaultThreadCount() {
+        return MathHelper.clamp(Runtime.getRuntime().availableProcessors() / 2, 1, 2);
+    }
+
+    public boolean isSingleThreaded() {
+        return this.threadCount == 1;
+    }
+
+    @NotNull
+    public static TicTacsConfig get() {
+        if (config == null) {
+            try {
+                config = loadConfig();
+            } catch (IOException e) {
+                TicTacs.LOGGER.warn("Failed to read config file", e);
+                config = new TicTacsConfig();
+            }
+        }
+
+        return config;
+    }
+
+    private static TicTacsConfig loadConfig() throws IOException {
+        Path path = Paths.get("config", "tictacs.json");
+        if (!Files.exists(path)) {
+            return createConfig(path);
+        }
+
+        try (BufferedReader reader = Files.newBufferedReader(path)) {
+            TicTacsConfig config = parseConfig(reader);
+
+            // version change: recreate the config
+            if (config.version != VERSION) {
+                return createConfig(path);
+            }
+
+            return config;
+        }
+    }
+
+    private static TicTacsConfig createConfig(Path path) throws IOException {
+        TicTacsConfig config = new TicTacsConfig();
+
+        Files.createDirectories(path.getParent());
+
+        try (BufferedWriter writer = Files.newBufferedWriter(path)) {
+            writer.write(GSON.toJson(config));
+        }
+
+        return config;
+    }
+
+    private static TicTacsConfig parseConfig(Reader reader) {
+        return GSON.fromJson(reader, TicTacsConfig.class);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..95e5c807f9b49356345719781f4f01884de9209a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java
@@ -0,0 +1,98 @@
+package net.gegy1000.tictacs.lighting;
+
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.world.chunk.light.LightingProvider;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+
+// TODO: consolidate lighting workers?
+public final class LightingExecutor implements Runnable, AutoCloseable {
+    private final LightingProvider lightingProvider;
+
+    private volatile Queues queues = new Queues();
+    private volatile Queues processingQueues = new Queues();
+
+    private final Thread thread;
+    private volatile boolean closed;
+
+    private final AtomicBoolean parked = new AtomicBoolean();
+
+    public LightingExecutor(LightingProvider lightingProvider) {
+        this.lightingProvider = lightingProvider;
+
+        this.thread = new Thread(this);
+        this.thread.setName("lighting-worker");
+        this.thread.setDaemon(true);
+        this.thread.start();
+    }
+
+    public void enqueue(Runnable task, ServerLightingProvider.Stage stage) {
+        this.queues.enqueue(task, stage);
+        this.wake();
+    }
+
+    public void wake() {
+        if (this.hasTasks() && this.parked.compareAndSet(true, false)) {
+            LockSupport.unpark(this.thread);
+        }
+    }
+
+    @Override
+    public void run() {
+        while (!this.closed) {
+            if (this.hasTasks()) {
+                Queues queues = this.queues;
+                this.queues = this.processingQueues;
+                this.processingQueues = queues;
+
+                this.runTasks(queues);
+            } else {
+                this.parked.set(true);
+                LockSupport.park();
+            }
+        }
+    }
+
+    private boolean hasTasks() {
+        return !this.queues.isEmpty() || this.lightingProvider.hasUpdates();
+    }
+
+    private void runTasks(Queues queues) {
+        this.processQueue(queues.preUpdate);
+        this.lightingProvider.doLightUpdates(Integer.MAX_VALUE, true, true);
+        this.processQueue(queues.postUpdate);
+    }
+
+    private void processQueue(Queue<Runnable> queue) {
+        Runnable task;
+        while ((task = queue.poll()) != null) {
+            task.run();
+        }
+    }
+
+    @Override
+    public void close() {
+        this.closed = true;
+        this.wake();
+    }
+
+    private static class Queues {
+        final Queue<Runnable> preUpdate = new ConcurrentLinkedQueue<>();
+        final Queue<Runnable> postUpdate = new ConcurrentLinkedQueue<>();
+
+        void enqueue(Runnable task, ServerLightingProvider.Stage stage) {
+            if (stage == ServerLightingProvider.Stage.PRE_UPDATE) {
+                this.preUpdate.add(task);
+            } else {
+                this.postUpdate.add(task);
+            }
+        }
+
+        boolean isEmpty() {
+            return this.preUpdate.isEmpty() && this.postUpdate.isEmpty();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2379a0bf52ea416dd7343d46dd4f014fd90a758
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.lighting;
+
+public interface LightingExecutorHolder {
+    LightingExecutor getLightingExecutor();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ChunkHolderMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ChunkHolderMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d951b46f2956b556e02462ba2d568481516426e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ChunkHolderMixin.java
@@ -0,0 +1,50 @@
+package net.gegy1000.tictacs.mixin;
+
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.world.chunk.ChunkStatus;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Redirect;
+
+import java.util.concurrent.CompletableFuture;
+
+@Mixin(ChunkHolder.class)
+public class ChunkHolderMixin {
+    @Shadow
+    @Final
+    private static ChunkHolder.LevelType[] LEVEL_TYPES;
+
+    /**
+     * @reason we replace the future handling in {@link net.gegy1000.tictacs.chunk.entry.ChunkEntry}, and we don't want
+     * vanilla's logic to mess with ours.
+     * @author gegy1000
+     */
+    @Redirect(method = "tick", at = @At(value = "INVOKE", target = "Ljava/util/concurrent/CompletableFuture;complete(Ljava/lang/Object;)Z"))
+    private <T> boolean complete(CompletableFuture<T> future, T result) {
+        return true;
+    }
+
+    /**
+     * @reason replace with chunk step logic
+     * @author gegy1000
+     */
+    @Overwrite
+    public static ChunkStatus getTargetStatusForLevel(int level) {
+        return ChunkEntry.getTargetStep(level).getMaximumStatus();
+    }
+
+    /**
+     * @reason replace full level constant
+     * @author gegy1000
+     */
+    @Overwrite
+    public static ChunkHolder.LevelType getLevelType(int distance) {
+        return LEVEL_TYPES[MathHelper.clamp(ChunkLevelTracker.FULL_LEVEL - distance + 1, 0, LEVEL_TYPES.length - 1)];
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ChunkStatusMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ChunkStatusMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..e97598cfe12c0b49c8b86f9686467c433997dae9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ChunkStatusMixin.java
@@ -0,0 +1,36 @@
+package net.gegy1000.tictacs.mixin;
+
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.world.chunk.ChunkStatus;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+
+@Mixin(ChunkStatus.class)
+public class ChunkStatusMixin {
+    /**
+     * @reason replace with ChunkStep values
+     * @author gegy1000
+     */
+    @Overwrite
+    public static int getMaxDistanceFromFull() {
+        return ChunkStep.getMaxDistance() + 1;
+    }
+
+    /**
+     * @reason replace with ChunkStep values
+     * @author gegy1000
+     */
+    @Overwrite
+    public static ChunkStatus byDistanceFromFull(int distance) {
+        return ChunkStep.byDistanceFromFull(distance).getMaximumStatus();
+    }
+
+    /**
+     * @reason replace with ChunkStep values
+     * @author gegy1000
+     */
+    @Overwrite
+    public static int getDistanceFromFull(ChunkStatus status) {
+        return ChunkStep.getDistanceFromFull(ChunkStep.byStatus(status));
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ChunkTicketManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ChunkTicketManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..add15b46b449dad08bca084e1365cdc8e3c01931
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ChunkTicketManagerMixin.java
@@ -0,0 +1,30 @@
+package net.gegy1000.tictacs.mixin;
+
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.minecraft.server.world.ChunkTicketManager;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.Constant;
+import org.spongepowered.asm.mixin.injection.ModifyConstant;
+
+@Mixin(ChunkTicketManager.class)
+public class ChunkTicketManagerMixin {
+    @ModifyConstant(method = "<init>", constant = @Constant(intValue = 33))
+    private int getFullLevelForNearbyChunkTicketUpdater(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+
+    @ModifyConstant(method = "<clinit>", constant = @Constant(intValue = 33))
+    private static int getFullLevelForNearbyPlayerTicketLevel(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+
+    @ModifyConstant(method = "addTicket(Lnet/minecraft/server/world/ChunkTicketType;Lnet/minecraft/util/math/ChunkPos;ILjava/lang/Object;)V", constant = @Constant(intValue = 33))
+    private int getFullChunkLevelForAddTicket(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+
+    @ModifyConstant(method = "removeTicket(Lnet/minecraft/server/world/ChunkTicketType;Lnet/minecraft/util/math/ChunkPos;ILjava/lang/Object;)V", constant = @Constant(intValue = 33))
+    private int getFullChunkLevelForRemoveTicket(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ServerChunkManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ServerChunkManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e2287637acb3921dfdbc6c140a17b22fc2e706e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ServerChunkManagerMixin.java
@@ -0,0 +1,305 @@
+package net.gegy1000.tictacs.mixin;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.AsyncChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.LossyChunkCache;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.entity.Entity;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.profiler.Profiler;
+import net.minecraft.world.BlockView;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.WorldChunk;
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.Unique;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Function;
+
+@Mixin(ServerChunkManager.class)
+public abstract class ServerChunkManagerMixin implements AsyncChunkAccess {
+    @Shadow
+    @Final
+    private ServerWorld world;
+    @Shadow
+    @Final
+    private ChunkTicketManager ticketManager;
+    @Shadow
+    @Final
+    private ServerChunkManager.MainThreadExecutor mainThreadExecutor;
+    @Shadow
+    @Final
+    public ThreadedAnvilChunkStorage threadedAnvilChunkStorage;
+
+    @Shadow
+    @Final
+    private Thread serverThread;
+
+    @Unique
+    private final LossyChunkCache fastCache = new LossyChunkCache(32);
+
+    @Inject(method = "initChunkCaches", at = @At("HEAD"))
+    private void clearChunkCache(CallbackInfo ci) {
+        this.fastCache.clear();
+    }
+
+    /**
+     * @reason optimize chunk query and cache logic and avoid blocking the main thread if possible
+     * @author gegy1000
+     */
+    @Overwrite
+    @Nullable
+    public Chunk getChunk(int x, int z, ChunkStatus status, boolean create) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        if (create) {
+            if (Thread.currentThread() != this.serverThread) {
+                return this.getOrCreateChunkOffThread(x, z, step);
+            } else {
+                return this.getOrCreateChunkOnThread(x, z, step);
+            }
+        } else {
+            return this.getExistingChunk(x, z, step);
+        }
+    }
+
+    private Chunk getOrCreateChunkOnThread(int x, int z, ChunkStep step) {
+        // first we test if the chunk already exists in our small cache
+        Chunk cached = this.fastCache.get(x, z, step);
+        if (cached != null) {
+            return cached;
+        }
+
+        // if it does not exist, try load it from the chunk entry
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        Chunk chunk = this.getExistingChunkFor(entry, step);
+
+        // the chunk is not ready, we must interface and join the chunk future
+        if (chunk == null) {
+            Either<Chunk, ChunkHolder.Unloaded> result = this.joinFuture(this.createChunk(x, z, step));
+
+            chunk = result.map(
+                    Function.identity(),
+                    err -> { throw new IllegalStateException("Chunk not there when requested: " + err); }
+            );
+        }
+
+        this.fastCache.put(x, z, step, chunk);
+
+        return chunk;
+    }
+
+    private <T> T joinFuture(CompletableFuture<T> future) {
+        if (!future.isDone()) {
+            this.mainThreadExecutor.runTasks(future::isDone);
+        }
+        return future.join();
+    }
+
+    private Chunk getOrCreateChunkOffThread(int x, int z, ChunkStep step) {
+        Either<Chunk, ChunkHolder.Unloaded> result = CompletableFuture.supplyAsync(
+                () -> this.createChunk(x, z, step),
+                this.mainThreadExecutor
+        ).join().join();
+
+        return result.map(
+                chunk -> chunk,
+                unloaded -> {
+                    throw new IllegalStateException("Chunk not there when requested: " + unloaded);
+                }
+        );
+    }
+
+    /**
+     * @reason optimize chunk query and cache logic and avoid blocking the main thread if possible
+     * @author gegy1000
+     */
+    @Overwrite
+    @Nullable
+    public WorldChunk getWorldChunk(int x, int z) {
+        return (WorldChunk) this.getExistingChunk(x, z, ChunkStep.FULL);
+    }
+
+    /**
+     * @reason optimize chunk query
+     * @author gegy1000
+     */
+    @Overwrite
+    @Nullable
+    public BlockView getChunk(int x, int z) {
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        if (entry != null) {
+            return entry.getChunkAtLeast(ChunkStep.FEATURES);
+        }
+        return null;
+    }
+
+    @Override
+    public Chunk getExistingChunk(int x, int z, ChunkStep step) {
+        if (Thread.currentThread() != this.serverThread) {
+            return this.loadExistingChunk(x, z, step);
+        }
+
+        Chunk cached = this.fastCache.get(x, z, step);
+        if (cached != null) {
+            return cached;
+        }
+
+        Chunk chunk = this.loadExistingChunk(x, z, step);
+        this.fastCache.put(x, z, step, chunk);
+
+        return chunk;
+    }
+
+    @Override
+    public Chunk getAnyExistingChunk(int x, int z) {
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        if (entry != null) {
+            return entry.getChunk();
+        }
+        return null;
+    }
+
+    @Nullable
+    private Chunk loadExistingChunk(int x, int z, ChunkStep step) {
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        return this.getExistingChunkFor(entry, step);
+    }
+
+    @Nullable
+    private Chunk getExistingChunkFor(@Nullable ChunkEntry entry, ChunkStep step) {
+        if (entry != null && entry.isValidAs(step)) {
+            return entry.getChunkForStep(step);
+        }
+        return null;
+    }
+
+    /**
+     * @reason replace with implementation that will not return true for partially loaded chunks
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean isChunkLoaded(int x, int z) {
+        return this.getExistingChunk(x, z, ChunkStep.FULL) != null;
+    }
+
+    @Override
+    public CompletableFuture<Chunk> getOrCreateChunkAsync(int x, int z, ChunkStep step) {
+        CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> future;
+
+        if (Thread.currentThread() != this.serverThread) {
+            future = CompletableFuture.supplyAsync(() -> this.createChunk(x, z, step), this.mainThreadExecutor)
+                    .thenCompose(Function.identity());
+        } else {
+            future = this.createChunk(x, z, step);
+        }
+
+        return future.thenApply(result -> result.map(
+                chunk -> chunk,
+                unloaded -> {
+                    throw new IllegalStateException("Chunk not there when requested: " + unloaded);
+                })
+        );
+    }
+
+    private CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> createChunk(int x, int z, ChunkStep step) {
+        ChunkEntry entry = this.getChunkEntry(x, z);
+
+        ChunkPos pos = new ChunkPos(x, z);
+        int level = getLevelForStep(step);
+        this.ticketManager.addTicketWithLevel(ChunkTicketType.UNKNOWN, pos, level, pos);
+
+        while (entry == null || !entry.isValidAs(step)) {
+            Profiler profiler = this.world.getProfiler();
+            profiler.push("chunkLoad");
+
+            // tick the ticket manager to propagate any changes and reacquire the chunk entry
+            this.tick();
+            entry = this.getChunkEntry(x, z);
+
+            profiler.pop();
+
+            if (entry == null || !entry.isValidAs(step)) {
+                throw new IllegalStateException("No chunk entry after ticket has been added");
+            }
+        }
+
+        ChunkController controller = (ChunkController) this.threadedAnvilChunkStorage;
+        return controller.getChunkAs(entry, step).asVanilla();
+    }
+
+    @Override
+    public boolean shouldChunkExist(int x, int z, ChunkStep step) {
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        return entry != null && entry.getLevel() <= getLevelForStep(step);
+    }
+
+    private static int getLevelForStep(ChunkStep step) {
+        return ChunkLevelTracker.FULL_LEVEL + ChunkStep.getDistanceFromFull(step);
+    }
+
+    @Nullable
+    private ChunkEntry getChunkEntry(int x, int z) {
+        return (ChunkEntry) this.getChunkHolder(ChunkPos.toLong(x, z));
+    }
+
+    @Nullable
+    private ChunkEntry getChunkEntry(long pos) {
+        return (ChunkEntry) this.getChunkHolder(pos);
+    }
+
+    /**
+     * @reason direct logic to {@link ChunkEntry} and avoid allocation
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean shouldTickEntity(Entity entity) {
+        ChunkEntry entry = this.getChunkEntry(MathHelper.floor(entity.getX()) >> 4, MathHelper.floor(entity.getZ()) >> 4);
+        return entry != null && entry.isTickingEntities();
+    }
+
+    /**
+     * @reason direct logic to {@link ChunkEntry} and avoid allocation
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean shouldTickChunk(ChunkPos pos) {
+        ChunkEntry entry = this.getChunkEntry(pos.toLong());
+        return entry != null && entry.isTickingEntities();
+    }
+
+    /**
+     * @reason direct logic to {@link ChunkEntry} and avoid allocation
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean shouldTickBlock(BlockPos pos) {
+        ChunkEntry entry = this.getChunkEntry(pos.getX() >> 4, pos.getZ() >> 4);
+        return entry != null && entry.isTicking();
+    }
+
+    @Shadow
+    protected abstract boolean tick();
+
+    @Shadow
+    @Nullable
+    protected abstract ChunkHolder getChunkHolder(long pos);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/TacsAccessor.java b/src/main/java/net/gegy1000/tictacs/mixin/TacsAccessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc139d681f3935e8fac3d5baf1b0e3bdbc69c106
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/TacsAccessor.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs.mixin;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ChunkTaskPrioritySystem;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.gen.Accessor;
+
+@Mixin(ThreadedAnvilChunkStorage.class)
+public interface TacsAccessor {
+    @Accessor
+    LongSet getLoadedChunks();
+
+    @Accessor("unloadedChunks")
+    LongSet getQueuedUnloads();
+
+    @Accessor("chunksToUnload")
+    Long2ObjectLinkedOpenHashMap<ChunkHolder> getUnloadingChunks();
+
+    @Accessor
+    ChunkTaskPrioritySystem getChunkTaskPrioritySystem();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ThreadedAnvilChunkStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ThreadedAnvilChunkStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc9c8ec5605429fde1125445b4365f3e51cdf655
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ThreadedAnvilChunkStorageMixin.java
@@ -0,0 +1,514 @@
+package net.gegy1000.tictacs.mixin;
+
+import com.google.common.collect.Iterables;
+import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Either;
+import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
+import net.gegy1000.justnow.future.Future;
+import net.gegy1000.justnow.tuple.Unit;
+import net.gegy1000.tictacs.VoidActor;
+import net.gegy1000.tictacs.async.worker.ChunkMainThreadExecutor;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.future.AwaitAll;
+import net.gegy1000.tictacs.chunk.future.ChunkNotLoadedFuture;
+import net.gegy1000.tictacs.chunk.future.LazyRunnableFuture;
+import net.gegy1000.tictacs.chunk.future.VanillaChunkFuture;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.tracker.ChunkTracker;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.boss.dragon.EnderDragonPart;
+import net.minecraft.network.Packet;
+import net.minecraft.server.WorldGenerationProgressListener;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.server.world.PlayerChunkWatchingManager;
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.thread.TaskExecutor;
+import net.minecraft.util.thread.ThreadExecutor;
+import net.minecraft.world.PersistentStateManager;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkProvider;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+import net.minecraft.world.level.storage.LevelStorage;
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.Unique;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Constant;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.ModifyConstant;
+import org.spongepowered.asm.mixin.injection.Redirect;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BooleanSupplier;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+@Mixin(ThreadedAnvilChunkStorage.class)
+public abstract class ThreadedAnvilChunkStorageMixin implements ChunkController {
+    @Shadow
+    @Final
+    private ThreadExecutor<Runnable> mainThreadExecutor;
+    @Shadow
+    @Final
+    private ServerLightingProvider serverLightingProvider;
+    @Shadow
+    @Final
+    private ThreadedAnvilChunkStorage.TicketManager ticketManager;
+    @Shadow
+    @Final
+    private WorldGenerationProgressListener worldGenerationProgressListener;
+    @Shadow
+    @Final
+    private AtomicInteger totalChunksLoadedCount;
+    @Shadow
+    private int watchDistance;
+
+    @Unique
+    private ChunkMap map;
+    @Unique
+    private ChunkUpgrader upgrader;
+    @Unique
+    private ChunkTracker tracker;
+
+    @Unique
+    private ChunkLevelTracker levelTracker;
+
+    @Unique
+    private ChunkMainThreadExecutor chunkMainExecutor;
+
+    @Inject(method = "<init>", at = @At("RETURN"))
+    private void init(
+            ServerWorld world,
+            LevelStorage.Session levelSession,
+            DataFixer dataFixer,
+            StructureManager structures,
+            Executor threadPool,
+            ThreadExecutor<Runnable> mainThread,
+            ChunkProvider chunkProvider,
+            ChunkGenerator chunkGenerator,
+            WorldGenerationProgressListener progressListener,
+            Supplier<PersistentStateManager> persistentStateSupplier,
+            int watchDistance,
+            boolean syncWrite,
+            CallbackInfo ci
+    ) {
+        ServerLightingProvider lighting = this.serverLightingProvider;
+
+        this.map = new ChunkMap(world, this);
+        this.upgrader = new ChunkUpgrader(world, this, chunkGenerator, structures, lighting);
+
+        this.levelTracker = new ChunkLevelTracker(world, this);
+
+        this.tracker = new ChunkTracker(world, this);
+        this.tracker.setViewDistance(this.watchDistance);
+
+        this.map.addListener(this.tracker);
+
+        this.chunkMainExecutor = new ChunkMainThreadExecutor(mainThread);
+    }
+
+    @ModifyConstant(method = "<clinit>", constant = @Constant(intValue = 33))
+    private static int getFullChunkLevel(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+
+    @Redirect(
+            method = "<init>",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/util/thread/TaskExecutor;create(Ljava/util/concurrent/Executor;Ljava/lang/String;)Lnet/minecraft/util/thread/TaskExecutor;",
+                    ordinal = 0
+            )
+    )
+    private TaskExecutor<Runnable> createWorldgenActor(Executor executor, String name) {
+        return new VoidActor(name);
+    }
+
+    @Override
+    public ChunkMap getMap() {
+        return this.map;
+    }
+
+    @Override
+    public ChunkUpgrader getUpgrader() {
+        return this.upgrader;
+    }
+
+    @Override
+    public ChunkTicketManager getTicketManager() {
+        return this.ticketManager;
+    }
+
+    @Override
+    public ChunkTracker getTracker() {
+        return this.tracker;
+    }
+
+    @Override
+    public ChunkListener getChunkAs(ChunkEntry entry, ChunkStep step) {
+        this.upgrader.spawnUpgradeTo(entry, step);
+        return entry.getListenerFor(step);
+    }
+
+    @Override
+    public Future<Unit> getRadiusAs(ChunkPos pos, int radius, ChunkStep step) {
+        ChunkAccess chunks = this.map.visible();
+
+        ChunkMap.FlushListener flushListener = this.map.awaitFlush();
+
+        int size = radius * 2 + 1;
+        Future<Chunk>[] futures = new Future[size * size];
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                int idx = (x + radius) + (z + radius) * size;
+                ChunkEntry entry = chunks.getEntry(pos.x + x, pos.z + z);
+                if (entry == null) {
+                    return flushListener.andThen(unit -> this.getRadiusAs(pos, radius, step));
+                }
+
+                if (entry.isValidAs(step)) {
+                    this.upgrader.spawnUpgradeTo(entry, step);
+                    futures[idx] = entry.getListenerFor(step);
+                } else {
+                    return ChunkNotLoadedFuture.get();
+                }
+            }
+        }
+
+        flushListener.invalidateWaker();
+
+        return AwaitAll.of(futures);
+    }
+
+    @Override
+    public Future<Chunk> spawnLoadChunk(ChunkEntry entry) {
+        return VanillaChunkFuture.of(this.loadChunk(entry.getPos()));
+    }
+
+    @Override
+    public void notifyStatus(ChunkPos pos, ChunkStatus status) {
+        this.worldGenerationProgressListener.setChunkStatus(pos, status);
+    }
+
+    @Override
+    public <T> void spawnOnMainThread(ChunkEntry entry, Future<T> future) {
+        this.chunkMainExecutor.spawn(entry, future);
+    }
+
+    @Override
+    public void spawnOnMainThread(ChunkEntry entry, Runnable runnable) {
+        this.chunkMainExecutor.spawn(entry, new LazyRunnableFuture(runnable));
+    }
+
+    /**
+     * @reason delegate to ChunkMap
+     * @author gegy1000
+     */
+    @Nullable
+    @Overwrite
+    public ChunkHolder getCurrentChunkHolder(long pos) {
+        return this.map.primary().getEntry(pos);
+    }
+
+    /**
+     * @reason delegate to ChunkMap
+     * @author gegy1000
+     */
+    @Nullable
+    @Overwrite
+    public ChunkHolder getChunkHolder(long pos) {
+        return this.map.visible().getEntry(pos);
+    }
+
+    /**
+     * @reason replace usage of ChunkStatus and delegate to custom upgrader logic
+     * @author gegy1000
+     */
+    @Overwrite
+    public CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> getChunk(ChunkHolder holder, ChunkStatus status) {
+        ChunkStep step = ChunkStep.byStatus(status);
+
+        ChunkEntry entry = (ChunkEntry) holder;
+        this.upgrader.spawnUpgradeTo(entry, step);
+
+        return entry.getListenerFor(step).asVanilla();
+    }
+    
+    @Inject(method = "tick", at = @At("HEAD")) // TODO
+    public void tick(BooleanSupplier runWhile, CallbackInfo ci) {
+        this.map.flushToVisible();
+    }
+
+    @Redirect( // Maybe look back at
+            method = "unloadChunks",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lit/unimi/dsi/fastutil/longs/Long2ObjectLinkedOpenHashMap;remove(J)Ljava/lang/Object;",
+                    remap = false
+            )
+    )
+    private Object removeChunkForUnload(Long2ObjectLinkedOpenHashMap<ChunkHolder> map, long pos) {
+        return this.map.primary().removeEntry(pos);
+    }
+
+    @Redirect( //TODO
+            method = "save(Z)V",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lit/unimi/dsi/fastutil/longs/Long2ObjectLinkedOpenHashMap;values()Lit/unimi/dsi/fastutil/objects/ObjectCollection;",
+                    remap = false
+            )
+    )
+    private ObjectCollection<?> getChunks(Long2ObjectLinkedOpenHashMap<?> map) {
+        return this.map.primary().getEntries();
+    }
+
+    @Inject(method = "close", at = @At("RETURN"))
+    private void close(CallbackInfo ci) {
+        this.chunkMainExecutor.close();
+    }
+
+    /**
+     * @reason delegate to ChunkLevelTracker
+     * @author gegy1000
+     */
+    @Nullable
+    @Overwrite
+    private ChunkHolder setLevel(long pos, int toLevel, @Nullable ChunkHolder entry, int fromLevel) {
+        return this.levelTracker.setLevel(pos, toLevel, (ChunkEntry) entry, fromLevel);
+    }
+
+    /**
+     * @reason replace the level used for light tickets
+     * @author gegy1000
+     */
+    @Overwrite
+    public void releaseLightTicket(ChunkPos pos) {
+        this.mainThreadExecutor.send(() -> {
+            this.ticketManager.removeTicketWithLevel(ChunkTicketType.LIGHT, pos, ChunkLevelTracker.LIGHT_TICKET_LEVEL, pos);
+        });
+    }
+
+    /**
+     * @reason replace usage of async area-loading
+     * @author gegy1000
+     */
+    @Overwrite
+    public CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> makeChunkEntitiesTickable(ChunkPos pos) {
+        CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> future = new CompletableFuture<>();
+
+        ChunkEntry entry = this.map.primary().getEntry(pos);
+
+        this.spawnOnMainThread(entry, this.getRadiusAs(pos, 2, ChunkStep.FULL).handle((ok, err) -> {
+            if (err == null && entry.getWorldChunk() != null) {
+                future.complete(Either.left(entry.getWorldChunk()));
+            } else {
+                future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+            }
+            return Unit.INSTANCE;
+        }));
+
+        return future;
+    }
+    // Stopped here --------------------------------------------
+    /**
+     * @reason replace usage of async area-loading
+     * @author gegy1000
+     */
+    @Overwrite
+    public CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> makeChunkTickable(ChunkHolder holder) {
+        CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> future = new CompletableFuture<>();
+        ChunkEntry entry = (ChunkEntry) holder;
+
+        this.spawnOnMainThread(entry, this.getRadiusAs(entry.getPos(), 1, ChunkStep.FULL)
+                .handle((ok, err) -> {
+                    if (err != null) {
+                        future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+                        return Unit.INSTANCE;
+                    }
+
+                    WorldChunk chunk = entry.getWorldChunk();
+                    if (chunk != null) {
+                        chunk.runPostProcessing();
+
+                        this.totalChunksLoadedCount.getAndIncrement();
+                        this.tracker.onChunkFull(entry, chunk);
+                        this.map.getTickingMaps().addTrackableChunk(entry);
+
+                        future.complete(Either.left(chunk));
+                    } else {
+                        future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+                    }
+
+                    return Unit.INSTANCE;
+                })
+        );
+
+        return future;
+    }
+
+    /**
+     * @reason delegate to ChunkMap
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean updateHolderMap() {
+        return this.map.flushToVisible();
+    }
+
+    /**
+     * @reason delegate to ChunkMap
+     * @author gegy1000
+     */
+    @Overwrite
+    public int getLoadedChunkCount() {
+        return this.map.getEntryCount();
+    }
+
+    /**
+     * @reason delegate to ChunkMap
+     * @author gegy1000
+     */
+    @Overwrite
+    public Iterable<ChunkHolder> entryIterator() {
+        return Iterables.unmodifiableIterable(this.map.visible().getEntries());
+    }
+
+    @ModifyConstant(method = "setViewDistance", constant = @Constant(intValue = 33))
+    private int getMaxViewDistance(int level) {
+        return ChunkLevelTracker.FULL_LEVEL;
+    }
+
+    @Redirect(
+            method = "setViewDistance",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lit/unimi/dsi/fastutil/longs/Long2ObjectLinkedOpenHashMap;values()Lit/unimi/dsi/fastutil/objects/ObjectCollection;",
+                    remap = false
+            )
+    )
+    private ObjectCollection<ChunkHolder> setViewDistance(Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks) {
+        if (this.tracker != null) {
+            this.tracker.setViewDistance(this.watchDistance);
+        }
+        return ObjectLists.emptyList();
+    }
+
+    /**
+     * @reason delegate to ChunkTracker
+     * @author gegy1000
+     */
+    @Overwrite
+    public void loadEntity(Entity entity) {
+        if (entity instanceof EnderDragonPart) {
+            return;
+        }
+        this.tracker.getEntities().add(entity);
+    }
+
+    /**
+     * @reason delegate to ChunkTracker
+     * @author gegy1000
+     */
+    @Overwrite
+    public void unloadEntity(Entity entity) {
+        this.tracker.getEntities().remove(entity);
+    }
+
+    /**
+     * @reason delegate to ChunkTracker
+     * @author gegy1000
+     */
+    @Overwrite
+    public void sendToOtherNearbyPlayers(Entity entity, Packet<?> packet) {
+        this.tracker.getEntities().sendToTracking(entity, packet);
+    }
+
+    /**
+     * @reason delegate to ChunkTracker
+     * @author gegy1000
+     */
+    @Overwrite
+    public void sendToNearbyPlayers(Entity entity, Packet<?> packet) {
+        this.tracker.getEntities().sendToTrackingAndSelf(entity, packet);
+    }
+
+    /**
+     * @reason use cached list of tracking players on the chunk entry
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean isTooFarFromPlayersToSpawnMobs(ChunkPos chunkPos) {
+        long pos = chunkPos.toLong();
+
+        ChunkEntry entry = this.map.visible().getEntry(pos);
+        return entry == null || !entry.isChunkTickable();
+    }
+
+    /**
+     * @reason use cached list of tracking players on the chunk entry
+     * @author gegy1000
+     */
+    @Redirect(
+            method = "getPlayersWatchingChunk",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/world/PlayerChunkWatchingManager;getPlayersWatchingChunk(J)Ljava/util/stream/Stream;"
+            )
+    )
+    private Stream<ServerPlayerEntity> getPlayersWatchingChunk(PlayerChunkWatchingManager watchManager, long pos) {
+        return this.getPlayersWatchingChunk(pos);
+    }
+
+    private Stream<ServerPlayerEntity> getPlayersWatchingChunk(long pos) {
+        ChunkEntry entry = this.map.visible().getEntry(pos);
+        if (entry != null) {
+            return entry.getTrackers().getTrackingPlayers().stream();
+        }
+        return Stream.empty();
+    }
+
+    /**
+     * @reason delegate to ChunkTracker
+     * @author gegy1000
+     */
+    @Overwrite
+    public void tickPlayerMovement() {
+        this.tracker.tick();
+    }
+
+    /**
+     * @reason we already detect player movement across chunks through normal entity tracker handling
+     * @author gegy1000
+     */
+    @Inject(method = "updateCameraPosition", at = @At("HEAD"), cancellable = true)
+    private void updateCameraPosition(ServerPlayerEntity player, CallbackInfo ci) {
+        ci.cancel();
+    }
+
+    @Shadow
+    protected abstract CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> loadChunk(ChunkPos pos);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/TicTacsMixinPlugin.java b/src/main/java/net/gegy1000/tictacs/mixin/TicTacsMixinPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..8154e0d498a9f3d707580dd8e7ed8658bf13c383
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/TicTacsMixinPlugin.java
@@ -0,0 +1,54 @@
+package net.gegy1000.tictacs.mixin;
+
+import net.fabricmc.loader.api.FabricLoader;
+import org.objectweb.asm.tree.ClassNode;
+import org.spongepowered.asm.mixin.extensibility.IMixinConfigPlugin;
+import org.spongepowered.asm.mixin.extensibility.IMixinInfo;
+
+import java.util.List;
+import java.util.Set;
+
+public final class TicTacsMixinPlugin implements IMixinConfigPlugin {
+    private static final String MIXIN_ROOT = "net.gegy1000.tictacs.mixin";
+    private static final String STARLIGHT_MIXIN_ROOT = MIXIN_ROOT + ".starlight";
+    private static final String PHOSPHOR_MIXIN_ROOT = MIXIN_ROOT + ".phosphor";
+
+    private static final boolean STARLIGHT_LOADED = FabricLoader.getInstance().isModLoaded("starlight");
+    private static final boolean PHOSPHOR_LOADED = FabricLoader.getInstance().isModLoaded("phosphor");
+
+    @Override
+    public void onLoad(String mixinPackage) {
+    }
+
+    @Override
+    public String getRefMapperConfig() {
+        return null;
+    }
+
+    @Override
+    public boolean shouldApplyMixin(String targetClassName, String mixinClassName) {
+        if (mixinClassName.startsWith(MIXIN_ROOT)) {
+            return (STARLIGHT_LOADED || !mixinClassName.startsWith(STARLIGHT_MIXIN_ROOT))
+                    && (PHOSPHOR_LOADED || !mixinClassName.startsWith(PHOSPHOR_MIXIN_ROOT));
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public void acceptTargets(Set<String> myTargets, Set<String> otherTargets) {
+    }
+
+    @Override
+    public List<String> getMixins() {
+        return null;
+    }
+
+    @Override
+    public void preApply(String targetClassName, ClassNode targetClass, String mixinClassName, IMixinInfo mixinInfo) {
+    }
+
+    @Override
+    public void postApply(String targetClassName, ClassNode targetClass, String mixinClassName, IMixinInfo mixinInfo) {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/actor/TaskExecutorMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/actor/TaskExecutorMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8db5e6b469344433bd61a319148efeffb38824d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/actor/TaskExecutorMixin.java
@@ -0,0 +1,21 @@
+package net.gegy1000.tictacs.mixin.actor;
+
+import net.gegy1000.tictacs.OwnThreadActor;
+import net.minecraft.util.Util;
+import net.minecraft.util.thread.TaskExecutor;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
+
+import java.util.concurrent.Executor;
+
+@Mixin(TaskExecutor.class)
+public class TaskExecutorMixin<T> {
+    @Inject(method = "create", at = @At("HEAD"), cancellable = true)
+    private static void create(Executor executor, String name, CallbackInfoReturnable<TaskExecutor<Runnable>> ci) {
+        if (executor == Util.getMainWorkerExecutor()) {
+            ci.setReturnValue(OwnThreadActor.create(name));
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/chunk_ticking/ServerChunkManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/chunk_ticking/ServerChunkManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..003789e0cbca2e9b9c5e8b21b91dcf37dc565212
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/chunk_ticking/ServerChunkManagerMixin.java
@@ -0,0 +1,189 @@
+package net.gegy1000.tictacs.mixin.chunk_ticking;
+
+import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.WorldGenerationProgressListener;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.util.profiler.Profiler;
+import net.minecraft.world.GameRules;
+import net.minecraft.world.PersistentStateManager;
+import net.minecraft.world.SpawnHelper;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.gen.chunk.ChunkGenerator;
+import net.minecraft.world.level.storage.LevelStorage;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.Unique;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+@Mixin(value = ServerChunkManager.class, priority = 999)
+public abstract class ServerChunkManagerMixin {
+    @Shadow
+    @Final
+    public ThreadedAnvilChunkStorage threadedAnvilChunkStorage;
+    @Shadow
+    @Final
+    private ServerWorld world;
+    @Shadow
+    private long lastMobSpawningTime;
+    @Shadow
+    @Nullable
+    private SpawnHelper.Info spawnEntry;
+    @Shadow
+    @Final
+    private ChunkTicketManager ticketManager;
+    @Shadow
+    private boolean spawnAnimals;
+    @Shadow
+    private boolean spawnMonsters;
+
+    private ChunkAccess primaryChunks;
+    private final List<ChunkEntry> tickingChunks = new ArrayList<>();
+
+    @Inject(method = "<init>", at = @At("RETURN"))
+    private void init(ServerWorld world, LevelStorage.Session session, DataFixer dataFixer, StructureManager structureManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, boolean bl, WorldGenerationProgressListener worldGenerationProgressListener, Supplier<PersistentStateManager> supplier, CallbackInfo ci) {
+        this.primaryChunks = ((ChunkController) this.threadedAnvilChunkStorage).getMap().primary();
+    }
+
+    /**
+     * @reason optimize chunk ticking and iteration logic
+     * @author gegy1000
+     */
+    @Overwrite
+    private void tickChunks() {
+        long time = this.world.getTime();
+
+        long timeSinceSpawn = time - this.lastMobSpawningTime;
+        this.lastMobSpawningTime = time;
+
+        boolean doMobSpawning = this.world.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING);
+        boolean spawnMobs = doMobSpawning && (this.spawnMonsters || this.spawnAnimals);
+
+        if (!this.world.isDebugWorld()) {
+            Profiler profiler = this.world.getProfiler();
+            profiler.push("pollingChunks");
+
+            this.flushChunkUpgrades();
+
+            this.spawnEntry = spawnMobs ? this.setupSpawnInfo(this.ticketManager.getSpawningChunkCount()) : null;
+            this.tickChunks(timeSinceSpawn, this.spawnEntry);
+
+            if (doMobSpawning) {
+                profiler.push("customSpawners");
+                this.world.tickSpawners(this.spawnMonsters, this.spawnAnimals);
+                profiler.pop();
+            }
+
+            profiler.pop();
+        }
+
+        this.threadedAnvilChunkStorage.tickPlayerMovement();
+    }
+
+    private void flushChunkUpgrades() {
+        ChunkController controller = (ChunkController) this.threadedAnvilChunkStorage;
+        Collection<ChunkEntry> trackableChunks = controller.getMap().getTickingMaps().getTrackableEntries();
+
+        Profiler profiler = this.world.getProfiler();
+        profiler.push("broadcast");
+
+        for (ChunkEntry entry : trackableChunks) {
+            WorldChunk worldChunk = entry.getWorldChunk();
+            if (worldChunk != null) {
+                entry.flushUpdates(worldChunk);
+            }
+        }
+
+        profiler.pop();
+    }
+
+    private void tickChunks(long timeSinceSpawn, SpawnHelper.Info spawnInfo) {
+        ChunkController controller = (ChunkController) this.threadedAnvilChunkStorage;
+
+        List<ChunkEntry> tickingChunks = this.collectTickingChunks(controller);
+        if (!tickingChunks.isEmpty()) {
+            this.tickChunks(timeSinceSpawn, spawnInfo, tickingChunks);
+        }
+
+        this.tickingChunks.clear();
+    }
+
+    private void tickChunks(long timeSinceSpawn, SpawnHelper.Info spawnInfo, List<ChunkEntry> chunks) {
+        boolean spawnAnimals = this.world.getTime() % 400 == 0L;
+        int tickSpeed = this.world.getGameRules().getInt(GameRules.RANDOM_TICK_SPEED);
+
+        for (ChunkEntry entry : chunks) {
+            WorldChunk worldChunk = entry.getWorldChunk();
+
+            if (worldChunk != null && entry.isChunkTickable()) {
+                worldChunk.setInhabitedTime(worldChunk.getInhabitedTime() + timeSinceSpawn);
+
+                if (spawnInfo != null && this.world.getWorldBorder().contains(entry.getPos())) {
+                    SpawnHelper.spawn(this.world, worldChunk, spawnInfo, this.spawnAnimals, this.spawnMonsters, spawnAnimals);
+                }
+
+                this.world.tickChunk(worldChunk, tickSpeed);
+            }
+        }
+    }
+
+    private SpawnHelper.Info setupSpawnInfo(int spawnChunkCount) {
+        Profiler profiler = this.world.getProfiler();
+        profiler.push("naturalSpawnCount");
+
+        SpawnHelper.Info spawnInfo = SpawnHelper.setupSpawn(spawnChunkCount, this.world.iterateEntities(), this::ifChunkLoaded);
+
+        profiler.pop();
+
+        return spawnInfo;
+    }
+
+    private List<ChunkEntry> collectTickingChunks(ChunkController controller) {
+        Collection<ChunkEntry> entries = controller.getMap().getTickingMaps().getTickableEntries();
+        if (entries.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        List<ChunkEntry> tickingChunks = this.tickingChunks;
+        tickingChunks.clear();
+        tickingChunks.addAll(entries);
+
+        Collections.shuffle(tickingChunks);
+
+        return tickingChunks;
+    }
+
+    @Unique
+    private void ifChunkLoaded(long pos, Consumer<WorldChunk> consumer) {
+        ChunkEntry entry = this.primaryChunks.getEntry(pos);
+        if (entry != null) {
+            Either<WorldChunk, ChunkHolder.Unloaded> accessible = entry.getAccessibleFuture().getNow(null);
+            if (accessible == null) {
+                return;
+            }
+
+            accessible.ifLeft(consumer);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/client/GameOptionsMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/client/GameOptionsMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..793b157d6ce6648c3cd300df3f97f87605ecd5f1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/client/GameOptionsMixin.java
@@ -0,0 +1,15 @@
+package net.gegy1000.tictacs.mixin.client;
+
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import net.minecraft.client.options.GameOptions;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.Constant;
+import org.spongepowered.asm.mixin.injection.ModifyConstant;
+
+@Mixin(GameOptions.class)
+public class GameOptionsMixin {
+    @ModifyConstant(method = "<init>", constant = @Constant(floatValue = 32.0F))
+    private float modifyMaxViewDistance(float viewDistance) {
+        return TicTacsConfig.get().maxViewDistance;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/client/MinecraftClientMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/client/MinecraftClientMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..be075589086c00390857b36820bdbdc388b6901b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/client/MinecraftClientMixin.java
@@ -0,0 +1,31 @@
+package net.gegy1000.tictacs.mixin.client;
+
+import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.gui.WorldGenerationProgressTracker;
+import net.minecraft.server.WorldGenerationProgressListener;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;
+
+@Mixin(MinecraftClient.class)
+public class MinecraftClientMixin {
+    @Inject(
+            method = "method_17533",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Ljava/util/concurrent/atomic/AtomicReference;set(Ljava/lang/Object;)V",
+                    shift = At.Shift.AFTER
+            ),
+            cancellable = true,
+            locals = LocalCapture.CAPTURE_FAILHARD,
+            remap = false
+    )
+    private void getWorldProgressListener(
+            int radius, CallbackInfoReturnable<WorldGenerationProgressListener> ci,
+            WorldGenerationProgressTracker tracker
+    ) {
+        ci.setReturnValue(tracker);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/client/WorldGenerationProgressTrackerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/client/WorldGenerationProgressTrackerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..7b60fd275f816b1dd2cb8347343695f8a387e16d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/client/WorldGenerationProgressTrackerMixin.java
@@ -0,0 +1,94 @@
+package net.gegy1000.tictacs.mixin.client;
+
+import net.minecraft.client.gui.WorldGenerationProgressTracker;
+import net.minecraft.server.WorldGenerationProgressLogger;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.chunk.ChunkStatus;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import org.jetbrains.annotations.Nullable;
+
+@Mixin(WorldGenerationProgressTracker.class)
+public class WorldGenerationProgressTrackerMixin {
+    @Shadow
+    private ChunkPos spawnPos;
+
+    @Shadow
+    @Final
+    private int size;
+
+    @Shadow
+    private boolean running;
+
+    @Shadow
+    @Final
+    private WorldGenerationProgressLogger progressLogger;
+
+    @Shadow
+    @Final
+    private int radius;
+
+    private ChunkStatus[] array;
+
+    private int offsetX;
+    private int offsetZ;
+
+    @Inject(method = "<init>", at = @At("RETURN"))
+    private void init(CallbackInfo ci) {
+        this.array = new ChunkStatus[this.size * this.size];
+    }
+
+    @Inject(method = "start(Lnet/minecraft/util/math/ChunkPos;)V", at = @At("RETURN"))
+    private void start(ChunkPos spawnPos, CallbackInfo ci) {
+        this.array = new ChunkStatus[this.size * this.size];
+
+        this.offsetX = this.radius - this.spawnPos.x;
+        this.offsetZ = this.radius - this.spawnPos.z;
+    }
+
+    /**
+     * @reason set into backing array
+     * @author gegy1000
+     */
+    @Overwrite
+    public void setChunkStatus(ChunkPos pos, @Nullable ChunkStatus status) {
+        if (this.running) {
+            this.progressLogger.setChunkStatus(pos, status);
+
+            int idx = this.index(pos.x + this.offsetX, pos.z + this.offsetZ);
+            if (idx != -1) {
+                this.array[idx] = status;
+            }
+        }
+    }
+
+    /**
+     * @reason get from backing array
+     * @author gegy1000
+     */
+    @Overwrite
+    @Nullable
+    public ChunkStatus getChunkStatus(int x, int z) {
+        int idx = this.index(x, z);
+        if (idx == -1) {
+            return null;
+        }
+
+        return this.array[idx];
+    }
+
+    private int index(int x, int z) {
+        int size = this.size;
+        if (x < 0 || z < 0 || x >= size || z >= size) {
+            return -1;
+        }
+
+        return x + z * size;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/client/debug/DebugRendererMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/client/debug/DebugRendererMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0a9f7a75b3dae73876d024274a2734deeae0234
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/client/debug/DebugRendererMixin.java
@@ -0,0 +1,33 @@
+package net.gegy1000.tictacs.mixin.client.debug;
+
+import net.gegy1000.tictacs.client.TicTacsDebugRenderer;
+import net.gegy1000.tictacs.client.DebugRendererExt;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import net.minecraft.client.MinecraftClient;
+import net.minecraft.client.render.VertexConsumerProvider;
+import net.minecraft.client.render.debug.DebugRenderer;
+import net.minecraft.client.util.math.MatrixStack;
+
+@Mixin(DebugRenderer.class)
+public class DebugRendererMixin implements DebugRendererExt {
+	private TicTacsDebugRenderer ticTacsDebugRenderer;
+
+	@Inject(method = "<init>", at = @At("RETURN"))
+	private void handleConstructor(MinecraftClient client, CallbackInfo ci) {
+		this.ticTacsDebugRenderer = new TicTacsDebugRenderer();
+	}
+
+	@Inject(method = "render", at = @At("HEAD"))
+	private void handleRender(MatrixStack matrices, VertexConsumerProvider.Immediate vertexConsumers, double cameraX, double cameraY, double cameraZ, CallbackInfo ci) {
+        this.ticTacsDebugRenderer.render(matrices, vertexConsumers, cameraX, cameraY, cameraZ);
+	}
+
+	@Override
+	public TicTacsDebugRenderer get() {
+		return this.ticTacsDebugRenderer;
+	}
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/client/debug/InGameHudMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/client/debug/InGameHudMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d2f10c5c5113bc9f99a50614ceb2fa5e5668c6d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/client/debug/InGameHudMixin.java
@@ -0,0 +1,22 @@
+package net.gegy1000.tictacs.mixin.client.debug;
+
+import net.gegy1000.tictacs.client.LevelMapOverlay;
+import net.gegy1000.tictacs.config.TicTacsConfig;
+import net.minecraft.client.gui.hud.InGameHud;
+import net.minecraft.client.util.math.MatrixStack;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+@Mixin(InGameHud.class)
+public class InGameHudMixin {
+    private final LevelMapOverlay levelMap = new LevelMapOverlay();
+
+    @Inject(method = "render", at = @At("RETURN"))
+    private void render(MatrixStack transform, float deltaTime, CallbackInfo ci) {
+        if (TicTacsConfig.get().debug.chunkMap) {
+            this.levelMap.render(transform);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/debug/ServerChunkManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/debug/ServerChunkManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..23c05e1e1229d33ef197492712008aada18b81ee
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/debug/ServerChunkManagerMixin.java
@@ -0,0 +1,60 @@
+package net.gegy1000.tictacs.mixin.debug;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.TicTacs;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.util.profiler.Profiler;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;
+
+import java.util.concurrent.CompletableFuture;
+
+@Mixin(value = ServerChunkManager.class, priority = 2000)
+public class ServerChunkManagerMixin {
+    private long startBlockTime;
+    private Exception blockTrace;
+
+    @Inject(
+            method = "getChunk(IILnet/minecraft/world/chunk/ChunkStatus;Z)Lnet/minecraft/world/chunk/Chunk;",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/world/ServerChunkManager$MainThreadExecutor;runTasks(Ljava/util/function/BooleanSupplier;)V",
+                    shift = At.Shift.BEFORE
+            ),
+            locals = LocalCapture.CAPTURE_FAILHARD
+    )
+    private void startRecordBlockingChunk(
+            int x, int z, ChunkStatus leastStatus, boolean create, CallbackInfoReturnable<Chunk> ci,
+            Profiler profiler, long key, CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> future
+    ) {
+        if (!future.isDone()) {
+            this.blockTrace = new Exception();
+            this.startBlockTime = System.nanoTime();
+        }
+    }
+
+    @Inject(
+            method = "getChunk(IILnet/minecraft/world/chunk/ChunkStatus;Z)Lnet/minecraft/world/chunk/Chunk;",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/world/ServerChunkManager;putInCache(JLnet/minecraft/world/chunk/Chunk;Lnet/minecraft/world/chunk/ChunkStatus;)V",
+                    shift = At.Shift.BEFORE
+            )
+    )
+    private void stopRecordBlockingChunk(int x, int z, ChunkStatus leastStatus, boolean create, CallbackInfoReturnable<Chunk> ci) {
+        if (this.blockTrace != null) {
+            long timeNs = System.nanoTime() - this.startBlockTime;
+            long timeMs = timeNs / 1000000;
+
+            TicTacs.LOGGER.warn("Blocked on chunk for {}ms", timeMs, this.blockTrace);
+
+            this.blockTrace = null;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/PalettedContainerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/PalettedContainerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..2497dfba0989d964eb4dacac2f87cb82ab8dc2c0
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/PalettedContainerMixin.java
@@ -0,0 +1,50 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import net.minecraft.world.chunk.Palette;
+import net.minecraft.world.chunk.PalettedContainer;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+@Mixin(PalettedContainer.class)
+public abstract class PalettedContainerMixin<T> {
+    private static final int SIZE = 16 * 16 * 16;
+
+    @Shadow
+    private int paletteSize;
+
+    @Shadow
+    private Palette<T> palette;
+
+    @Inject(method = "count", at = @At("HEAD"), cancellable = true)
+    private void count(PalettedContainer.CountConsumer<T> consumer, CallbackInfo ci) {
+        // test for uniformity on small palettes
+        int paletteSize = this.paletteSize;
+        if (paletteSize > 4) {
+            return;
+        }
+
+        Palette<T> palette = this.palette;
+        T uniformValue = null;
+
+        for (int i = 0; i < paletteSize; i++) {
+            T entry = palette.getByIndex(i);
+            if (entry == null || entry == uniformValue) {
+                continue;
+            }
+
+            if (uniformValue == null) {
+                uniformValue = entry;
+            } else {
+                // we have more than one value, delegate to default behavior
+                return;
+            }
+        }
+
+        // this section only has 1 palette entry!
+        consumer.accept(uniformValue, SIZE);
+        ci.cancel();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/PointOfInterestStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/PointOfInterestStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..e36179f128d7470d8e2f38e228c0f2076fb8dedc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/PointOfInterestStorageMixin.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import com.mojang.datafixers.DataFixer;
+import com.mojang.serialization.Codec;
+import net.gegy1000.tictacs.PoiStorageAccess;
+import net.minecraft.datafixer.DataFixTypes;
+import net.minecraft.util.Util;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.ChunkSectionPos;
+import net.minecraft.world.chunk.ChunkSection;
+import net.minecraft.world.poi.PointOfInterestSet;
+import net.minecraft.world.poi.PointOfInterestStorage;
+import net.minecraft.world.poi.PointOfInterestType;
+import net.minecraft.world.storage.SerializingRegionBasedStorage;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.io.File;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+
+@Mixin(PointOfInterestStorage.class)
+public abstract class PointOfInterestStorageMixin extends SerializingRegionBasedStorage<PointOfInterestSet> implements PoiStorageAccess {
+    private PointOfInterestStorageMixin(File directory, Function<Runnable, Codec<PointOfInterestSet>> codecFactory, Function<Runnable, PointOfInterestSet> factory, DataFixer dataFixer, DataFixTypes dataFixTypes, boolean bl) {
+        super(directory, codecFactory, factory, dataFixer, dataFixTypes, bl);
+    }
+
+    @Shadow
+    protected abstract void scanAndPopulate(ChunkSection section, ChunkSectionPos sectionPos, BiConsumer<BlockPos, PointOfInterestType> add);
+
+    @Override
+    public void initSectionWithPois(ChunkPos pos, ChunkSection section) {
+        ChunkSectionPos sectionPos = ChunkSectionPos.from(pos, section.getYOffset() >> 4);
+        Util.ifPresentOrElse(this.get(sectionPos.asLong()), set -> {
+            set.updatePointsOfInterest(add -> this.scanAndPopulate(section, sectionPos, add));
+        }, () -> {
+            PointOfInterestSet set = this.getOrCreate(sectionPos.asLong());
+            this.scanAndPopulate(section, sectionPos, set::add);
+        });
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/SerializingRegionBasedStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/SerializingRegionBasedStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..dad1eec8efdc767663f44c39fc9b42fe57fbd097
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/SerializingRegionBasedStorageMixin.java
@@ -0,0 +1,50 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import com.mojang.serialization.DynamicOps;
+import net.gegy1000.tictacs.AsyncChunkIo;
+import net.gegy1000.tictacs.AsyncRegionStorageIo;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtOps;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.storage.SerializingRegionBasedStorage;
+import net.minecraft.world.storage.StorageIoWorker;
+import org.apache.logging.log4j.Logger;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import org.jetbrains.annotations.Nullable;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+
+@Mixin(SerializingRegionBasedStorage.class)
+public abstract class SerializingRegionBasedStorageMixin implements AsyncRegionStorageIo, AsyncChunkIo {
+    @Shadow
+    @Final
+    private static Logger LOGGER;
+
+    @Shadow
+    @Final
+    private StorageIoWorker worker;
+
+    @Shadow
+    protected abstract <T> void update(ChunkPos pos, DynamicOps<T> dynamicOps, @Nullable T data);
+
+    @Override
+    public CompletableFuture<Void> loadDataAtAsync(ChunkPos pos, Executor mainThreadExecutor) {
+        return this.getNbtAsync(pos).thenAcceptAsync(tag -> {
+            this.update(pos, NbtOps.INSTANCE, tag);
+        }, mainThreadExecutor);
+    }
+
+    @Override
+    public CompletableFuture<CompoundTag> getNbtAsync(ChunkPos pos) {
+        return ((AsyncChunkIo) this.worker).getNbtAsync(pos).handle((tag, throwable) -> {
+            if (throwable != null) {
+                LOGGER.error("Error reading chunk {} data from disk", pos, throwable);
+                return null;
+            }
+            return tag;
+        });
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/StorageIoWorkerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/StorageIoWorkerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9535bc54a845f912c1aa188f7de589c9a11b793
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/StorageIoWorkerMixin.java
@@ -0,0 +1,55 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.AsyncChunkIo;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.storage.RegionBasedStorage;
+import net.minecraft.world.storage.StorageIoWorker;
+import org.apache.logging.log4j.Logger;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+@Mixin(StorageIoWorker.class)
+public abstract class StorageIoWorkerMixin implements AsyncChunkIo {
+    @Shadow
+    @Final
+    private static Logger LOGGER;
+
+    @Shadow
+    @Final
+    private RegionBasedStorage storage;
+
+    @Shadow
+    @Final
+    private Map<ChunkPos, StorageIoWorker.Result> results;
+
+    @Shadow
+    protected abstract <T> CompletableFuture<T> run(Supplier<Either<T, Exception>> supplier);
+
+    @Override
+    public CompletableFuture<CompoundTag> getNbtAsync(ChunkPos pos) {
+        return this.run(() -> {
+            StorageIoWorker.Result result = this.results.get(pos);
+            if (result == null) {
+                return this.loadNbtAt(pos);
+            }
+            return Either.left(result.nbt);
+        });
+    }
+
+    public Either<CompoundTag, Exception> loadNbtAt(ChunkPos pos) {
+        try {
+            CompoundTag compoundTag = this.storage.getTagAt(pos);
+            return Either.left(compoundTag);
+        } catch (Exception e) {
+            LOGGER.warn("Failed to read chunk {}", pos, e);
+            return Either.right(e);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/ThreadedAnvilChunkStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/ThreadedAnvilChunkStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6bca45eddbfd1b40e4c53891bcc2eb83c67a470
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/ThreadedAnvilChunkStorageMixin.java
@@ -0,0 +1,149 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Either;
+import net.fabricmc.fabric.api.util.NbtType;
+import net.gegy1000.tictacs.AsyncChunkIo;
+import net.gegy1000.tictacs.AsyncRegionStorageIo;
+import net.gegy1000.tictacs.chunk.io.ChunkData;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.util.Util;
+import net.minecraft.util.crash.CrashException;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.thread.ThreadExecutor;
+import net.minecraft.world.PersistentStateManager;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.chunk.ProtoChunk;
+import net.minecraft.world.chunk.UpgradeData;
+import net.minecraft.world.poi.PointOfInterestStorage;
+import net.minecraft.world.storage.VersionedChunkStorage;
+import org.apache.logging.log4j.Logger;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+
+import org.jetbrains.annotations.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.function.Supplier;
+
+@Mixin(ThreadedAnvilChunkStorage.class)
+public abstract class ThreadedAnvilChunkStorageMixin extends VersionedChunkStorage implements AsyncChunkIo {
+    @Shadow
+    @Final
+    private static Logger LOGGER;
+
+    @Shadow
+    @Final
+    private ServerWorld world;
+    @Shadow
+    @Final
+    private PointOfInterestStorage pointOfInterestStorage;
+    @Shadow
+    @Final
+    private StructureManager structureManager;
+    @Shadow
+    @Final
+    private Supplier<PersistentStateManager> persistentStateManagerFactory;
+    @Shadow
+    @Final
+    private ThreadExecutor<Runnable> mainThreadExecutor;
+
+    private ThreadedAnvilChunkStorageMixin(File file, DataFixer dataFixer, boolean dsync) {
+        super(file, dataFixer, dsync);
+    }
+
+    /**
+     * @reason avoid blocking the main thread to load chunk
+     * @author gegy1000
+     */
+    @Overwrite
+    public CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> loadChunk(ChunkPos pos) {
+        return this.getUpdatedChunkTagAsync(pos)
+                .thenApplyAsync(tag -> this.deserializeChunkData(pos, tag), Util.getMainWorkerExecutor())
+                .handleAsync((data, throwable) -> {
+                    if (throwable != null) {
+                        if (throwable instanceof CompletionException) {
+                            throwable = throwable.getCause();
+                        }
+                        LOGGER.error("Couldn't load chunk {}", pos, throwable);
+                    }
+
+                    return this.createChunkFromData(pos, data);
+                }, this.mainThreadExecutor);
+    }
+
+    private Either<Chunk, ChunkHolder.Unloaded> createChunkFromData(ChunkPos pos, ChunkData data) {
+        if (data != null) {
+            this.world.getProfiler().visit("chunkLoad");
+
+            try {
+                Chunk chunk = data.createChunk(this.world, this.structureManager, this.pointOfInterestStorage);
+                chunk.setLastSaveTime(this.world.getTime());
+
+                this.method_27053(pos, chunk.getStatus().getChunkType());
+                return Either.left(chunk);
+            } catch (CrashException crash) {
+                Throwable cause = crash.getCause();
+                if (!(cause instanceof IOException)) {
+                    this.method_27054(pos);
+                    throw crash;
+                }
+
+                LOGGER.error("Couldn't load chunk {}", pos, crash);
+            } catch (Exception e) {
+                LOGGER.error("Couldn't load chunk {}", pos, e);
+            }
+        }
+
+        this.method_27054(pos);
+        return Either.left(new ProtoChunk(pos, UpgradeData.NO_UPGRADE_DATA));
+    }
+
+    @Nullable
+    private ChunkData deserializeChunkData(ChunkPos pos, CompoundTag tag) {
+        if (tag == null) {
+            return null;
+        }
+
+        if (!tag.contains("Level", NbtType.COMPOUND) || !tag.getCompound("Level").contains("Status", NbtType.STRING)) {
+            LOGGER.error("Chunk file at {} is missing level data, skipping", pos);
+            return null;
+        }
+
+        return ChunkData.deserialize(pos, tag);
+    }
+
+    private CompletableFuture<CompoundTag> getUpdatedChunkTagAsync(ChunkPos pos) {
+        CompletableFuture<CompoundTag> chunkTag = this.getNbtAsync(pos)
+                .thenCompose(tag -> {
+                    if (tag != null && getDataVersion(tag) < SharedConstants.getGameVersion().getWorldVersion()) {
+                        // TODO: ideally we don't need to datafix chunks on the main thread
+                        return CompletableFuture.supplyAsync(() -> {
+                            return this.updateChunkTag(this.world.getRegistryKey(), this.persistentStateManagerFactory, tag);
+                        }, this.mainThreadExecutor);
+                    }
+
+                    return CompletableFuture.completedFuture(tag);
+                });
+
+        CompletableFuture<Void> loadPoi = ((AsyncRegionStorageIo) this.pointOfInterestStorage).loadDataAtAsync(pos, this.mainThreadExecutor);
+
+        return chunkTag.thenCombine(loadPoi, (tag, v) -> tag);
+    }
+
+    @Shadow
+    protected abstract void method_27054(ChunkPos chunkPos);
+
+    @Shadow
+    protected abstract byte method_27053(ChunkPos chunkPos, ChunkStatus.ChunkType chunkType);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/io/VersionedChunkStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/io/VersionedChunkStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..be9a87b9360ee3133c360e8a9aabe98865fa6c3b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/io/VersionedChunkStorageMixin.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs.mixin.io;
+
+import net.gegy1000.tictacs.AsyncChunkIo;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.storage.StorageIoWorker;
+import net.minecraft.world.storage.VersionedChunkStorage;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.util.concurrent.CompletableFuture;
+
+@Mixin(VersionedChunkStorage.class)
+public class VersionedChunkStorageMixin implements AsyncChunkIo {
+    @Shadow
+    @Final
+    private StorageIoWorker worker;
+
+    @Override
+    public CompletableFuture<CompoundTag> getNbtAsync(ChunkPos pos) {
+        return ((AsyncChunkIo) this.worker).getNbtAsync(pos);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/lighting/ServerLightingProviderMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/lighting/ServerLightingProviderMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..efc889a7a6608eae8c09ce4ba116b8cdd96c5ab9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/lighting/ServerLightingProviderMixin.java
@@ -0,0 +1,63 @@
+package net.gegy1000.tictacs.mixin.lighting;
+
+import net.gegy1000.tictacs.lighting.LightingExecutor;
+import net.gegy1000.tictacs.lighting.LightingExecutorHolder;
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.world.chunk.ChunkProvider;
+import net.minecraft.world.chunk.light.LightingProvider;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Unique;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import java.util.function.IntSupplier;
+
+@Mixin(ServerLightingProvider.class)
+public abstract class ServerLightingProviderMixin extends LightingProvider implements LightingExecutorHolder {
+    @Unique
+    private final LightingExecutor lightingExecutor = new LightingExecutor(this);
+
+    private ServerLightingProviderMixin(ChunkProvider chunks, boolean blockLight, boolean skyLight) {
+        super(chunks, blockLight, skyLight);
+    }
+
+    /**
+     * @reason wake up the executor on each tick for lighting updates that have been indirectly queued
+     * @author gegy1000
+     */
+    @Overwrite
+    public void tick() {
+        this.lightingExecutor.wake();
+    }
+
+    /**
+     * @reason delegate to the lighting executor
+     * @author gegy1000
+     */
+    @Overwrite
+    private void enqueue(int x, int z, IntSupplier levelSupplier, ServerLightingProvider.Stage stage, Runnable task) {
+        this.lightingExecutor.enqueue(task, stage);
+    }
+
+    /**
+     * @reason allow doLightUpdates to be called from the executor
+     * @author gegy1000
+     */
+    @Override
+    @Overwrite
+    public int doLightUpdates(int maxUpdateCount, boolean doSkylight, boolean skipEdgeLightPropagation) {
+        return super.doLightUpdates(maxUpdateCount, doSkylight, skipEdgeLightPropagation);
+    }
+
+    @Inject(method = "close", at = @At("HEAD"))
+    public void close(CallbackInfo ci) {
+        this.lightingExecutor.close();
+    }
+
+    @Override
+    public LightingExecutor getLightingExecutor() {
+        return this.lightingExecutor;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/lighting/ThreadedAnvilChunkStorageMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/lighting/ThreadedAnvilChunkStorageMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddbe3842bde57e94e5b1442e38861fc39d1d4e3c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/lighting/ThreadedAnvilChunkStorageMixin.java
@@ -0,0 +1,26 @@
+package net.gegy1000.tictacs.mixin.lighting;
+
+import net.gegy1000.tictacs.VoidActor;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.thread.TaskExecutor;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Redirect;
+
+import java.util.concurrent.Executor;
+
+@Mixin(ThreadedAnvilChunkStorage.class)
+public abstract class ThreadedAnvilChunkStorageMixin implements ChunkController {
+    @Redirect(
+            method = "<init>",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/util/thread/TaskExecutor;create(Ljava/util/concurrent/Executor;Ljava/lang/String;)Lnet/minecraft/util/thread/TaskExecutor;",
+                    ordinal = 1
+            )
+    )
+    private TaskExecutor<Runnable> createLightingActor(Executor executor, String name) {
+        return new VoidActor(name);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ClientConnectionMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ClientConnectionMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..8bcbb31ff4122a544658cb352f6521df097a69cf
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ClientConnectionMixin.java
@@ -0,0 +1,118 @@
+package net.gegy1000.tictacs.mixin.packet_queue;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.gegy1000.tictacs.QueuingConnection;
+import net.minecraft.network.ClientConnection;
+import net.minecraft.network.NetworkState;
+import net.minecraft.network.Packet;
+import org.apache.logging.log4j.Logger;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.asm.mixin.Unique;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Queue;
+
+@Mixin(ClientConnection.class)
+public abstract class ClientConnectionMixin implements QueuingConnection {
+    @Shadow
+    @Final
+    private Queue<ClientConnection.QueuedPacket> packetQueue;
+
+    @Shadow
+    private Channel channel;
+
+    @Shadow
+    private int packetsSentCounter;
+
+    @Shadow
+    @Final
+    private static Logger LOGGER;
+
+    @Shadow
+    public abstract void setState(NetworkState state);
+
+    @Override
+    public void enqueueSend(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+        this.packetQueue.add(new ClientConnection.QueuedPacket(packet, callback));
+    }
+
+    /**
+     * @reason send multiple queued packets by only scheduling to the event loop once
+     * @author gegy1000
+     */
+    @Overwrite
+    public void sendQueuedPackets() {
+        if (this.channel == null || !this.channel.isOpen()) {
+            return;
+        }
+
+        List<ClientConnection.QueuedPacket> queue = this.drainQueue();
+        if (queue.isEmpty()) {
+            return;
+        }
+
+        NetworkState currentState = this.channel.attr(ClientConnection.ATTR_KEY_PROTOCOL).get();
+
+        ClientConnection.QueuedPacket lastPacket = queue.get(queue.size() - 1);
+        NetworkState lastState = NetworkState.getPacketHandlerState(lastPacket.packet);
+
+        this.packetsSentCounter += queue.size();
+
+        if (lastState != currentState) {
+            LOGGER.debug("Disabled auto read");
+            this.channel.config().setAutoRead(false);
+        }
+
+        if (this.channel.eventLoop().inEventLoop()) {
+            this.sendQueue(queue, currentState, lastState);
+        } else {
+            this.channel.eventLoop().execute(() -> {
+                this.sendQueue(queue, currentState, lastState);
+            });
+        }
+    }
+
+    @Unique
+    private List<ClientConnection.QueuedPacket> drainQueue() {
+        if (this.packetQueue.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        List<ClientConnection.QueuedPacket> buffer = new ArrayList<>(this.packetQueue.size());
+
+        ClientConnection.QueuedPacket queued;
+        while ((queued = this.packetQueue.poll()) != null) {
+            buffer.add(queued);
+        }
+
+        return buffer;
+    }
+
+    @Unique
+    private void sendQueue(List<ClientConnection.QueuedPacket> queue, NetworkState currentState, NetworkState lastState) {
+        if (lastState != currentState) {
+            this.setState(lastState);
+        }
+
+        for (ClientConnection.QueuedPacket packet : queue) {
+            ChannelFuture future = this.channel.write(packet.packet);
+            if (packet.callback != null) {
+                future.addListener(packet.callback);
+            }
+            future.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        }
+
+        this.channel.flush();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayNetworkHandlerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayNetworkHandlerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f1b9e07f341959e41c4b0c173b3df150ee1f4f8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayNetworkHandlerMixin.java
@@ -0,0 +1,25 @@
+package net.gegy1000.tictacs.mixin.packet_queue;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.gegy1000.tictacs.QueuingConnection;
+import net.minecraft.network.ClientConnection;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.ServerPlayNetworkHandler;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import org.jetbrains.annotations.Nullable;
+
+@Mixin(ServerPlayNetworkHandler.class)
+public class ServerPlayNetworkHandlerMixin implements QueuingConnection {
+    @Shadow
+    @Final
+    public ClientConnection connection;
+
+    @Override
+    public void enqueueSend(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+        ((QueuingConnection) this.connection).enqueueSend(packet, callback);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayerEntityMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayerEntityMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..124e9331a0d2a76ea9faf20cc52483243dd005ca
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/packet_queue/ServerPlayerEntityMixin.java
@@ -0,0 +1,34 @@
+package net.gegy1000.tictacs.mixin.packet_queue;
+
+import net.gegy1000.tictacs.QueuingConnection;
+import net.minecraft.network.Packet;
+import net.minecraft.server.network.ServerPlayNetworkHandler;
+import net.minecraft.server.network.ServerPlayerEntity;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Redirect;
+
+@Mixin(ServerPlayerEntity.class)
+public class ServerPlayerEntityMixin {
+    @Redirect(
+            method = "sendInitialChunkPackets",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/network/ServerPlayNetworkHandler;sendPacket(Lnet/minecraft/network/Packet;)V"
+            )
+    )
+    private void sendInitialChunkPacket(ServerPlayNetworkHandler network, Packet<?> packet) {
+        QueuingConnection.enqueueSend(network, packet);
+    }
+
+    @Redirect(
+            method = "sendUnloadChunkPacket",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/network/ServerPlayNetworkHandler;sendPacket(Lnet/minecraft/network/Packet;)V"
+            )
+    )
+    private void sendUnloadChunkPacket(ServerPlayNetworkHandler network, Packet<?> packet) {
+        QueuingConnection.enqueueSend(network, packet);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/phosphor/PhosphorServerLightingProviderMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/phosphor/PhosphorServerLightingProviderMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..20214f2847ec53fce9e9f50515e3e20f95ba62ba
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/phosphor/PhosphorServerLightingProviderMixin.java
@@ -0,0 +1,17 @@
+package net.gegy1000.tictacs.mixin.phosphor;
+
+import net.gegy1000.tictacs.compatibility.PhosphorServerLightingProviderAccess;
+import net.minecraft.server.world.ServerLightingProvider;
+import net.minecraft.world.chunk.Chunk;
+import org.spongepowered.asm.mixin.Mixin;
+
+import java.util.concurrent.CompletableFuture;
+
+@Mixin(value = ServerLightingProvider.class, priority = 999)
+public abstract class PhosphorServerLightingProviderMixin implements PhosphorServerLightingProviderAccess {
+    // implement with lower priority than phosphor's mixin
+    @Override
+    public CompletableFuture<Chunk> setupLightmaps(Chunk chunk) {
+        return CompletableFuture.completedFuture(chunk);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/starlight/StarlightServerWorldMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/starlight/StarlightServerWorldMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..ace631733e3323dc94d8d03ca9e52511a3d277bd
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/starlight/StarlightServerWorldMixin.java
@@ -0,0 +1,40 @@
+package net.gegy1000.tictacs.mixin.starlight;
+
+import ca.spottedleaf.starlight.common.world.ExtendedWorld;
+import net.gegy1000.tictacs.AsyncChunkAccess;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.profiler.Profiler;
+import net.minecraft.util.registry.RegistryKey;
+import net.minecraft.world.MutableWorldProperties;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.WorldChunk;
+import net.minecraft.world.dimension.DimensionType;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.util.function.Supplier;
+
+@Mixin(value = ServerWorld.class, priority = 1001)
+public abstract class StarlightServerWorldMixin extends World implements ExtendedWorld {
+    @Shadow
+    @Final
+    private ServerChunkManager serverChunkManager;
+
+    private StarlightServerWorldMixin(MutableWorldProperties properties, RegistryKey<World> registryRef, DimensionType dimensionType, Supplier<Profiler> profiler, boolean isClient, boolean debugWorld, long seed) {
+        super(properties, registryRef, dimensionType, profiler, isClient, debugWorld, seed);
+    }
+
+    // these implementations are not strictly necessary, but they optimize starlight's chunk queries
+    @Override
+    public WorldChunk getChunkAtImmediately(int x, int z) {
+        return this.serverChunkManager.getWorldChunk(x, z);
+    }
+
+    @Override
+    public Chunk getAnyChunkImmediately(int x, int z) {
+        return ((AsyncChunkAccess) this.serverChunkManager).getAnyExistingChunk(x, z);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/ChunkRegionMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/ChunkRegionMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c9f6ca004a2b045ac85f95bded7fe755f1b99f1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/ChunkRegionMixin.java
@@ -0,0 +1,39 @@
+package net.gegy1000.tictacs.mixin.threading_fix;
+
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.structure.StructureStart;
+import net.minecraft.util.math.ChunkSectionPos;
+import net.minecraft.world.ChunkRegion;
+import net.minecraft.world.gen.StructureAccessor;
+import net.minecraft.world.gen.feature.StructureFeature;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.Unique;
+
+import java.util.stream.Stream;
+
+@Mixin(ChunkRegion.class)
+public class ChunkRegionMixin {
+    @Shadow
+    @Final
+    private ServerWorld world;
+
+    @Unique
+    private StructureAccessor structureAccess;
+
+    /**
+     * @reason vanilla calls getStructures on the main world object. we don't want to do this! this can cause a race
+     * condition where both the main thread and the worker threads are blocking on a chunk to load.
+     * @author gegy1000
+     */
+    @Overwrite
+    public Stream<? extends StructureStart<?>> getStructures(ChunkSectionPos pos, StructureFeature<?> feature) {
+        if (this.structureAccess == null) {
+            this.structureAccess = this.world.getStructureAccessor().forRegion((ChunkRegion) (Object) this);
+        }
+
+        return this.structureAccess.getStructuresWithChildren(pos, feature);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/StructureManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/StructureManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..05006a22fb604b2bb0ea7a941d23e3f6d381da98
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/StructureManagerMixin.java
@@ -0,0 +1,32 @@
+package net.gegy1000.tictacs.mixin.threading_fix;
+
+import com.mojang.datafixers.DataFixer;
+import net.minecraft.resource.ResourceManager;
+import net.minecraft.structure.Structure;
+import net.minecraft.structure.StructureManager;
+import net.minecraft.util.Identifier;
+import net.minecraft.world.level.storage.LevelStorage;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Mutable;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@Mixin(StructureManager.class)
+public class StructureManagerMixin {
+    @Shadow
+    @Final
+    @Mutable
+    private Map<Identifier, Structure> structures;
+
+    @Inject(method = "<init>", at = @At("RETURN"))
+    private void init(ResourceManager resourceManager, LevelStorage.Session session, DataFixer dataFixer, CallbackInfo ci) {
+        // wrap the structures map so that it can be accessed concurrently
+        this.structures = new ConcurrentHashMap<>(this.structures);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/WeightedListMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/WeightedListMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e5c4dde14b7b80d18f0375db3ee81aa9bcaebde
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/threading_fix/WeightedListMixin.java
@@ -0,0 +1,41 @@
+package net.gegy1000.tictacs.mixin.threading_fix;
+
+import net.minecraft.util.collection.WeightedList;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.util.List;
+import java.util.Random;
+
+@Mixin(WeightedList.class)
+public class WeightedListMixin<U> {
+    @Shadow
+    @Final
+    protected List<WeightedList.Entry<U>> entries;
+
+    /**
+     * @reason remove use of streams and support concurrent access
+     * @author gegy1000
+     */
+    @Overwrite
+    public U pickRandom(Random random) {
+        WeightedList.Entry<U> selectedEntry = null;
+        double selectedValue = 0.0;
+
+        for (WeightedList.Entry<U> entry : this.entries) {
+            double value = Math.pow(random.nextFloat(), 1.0F / entry.weight);
+            if (value > selectedValue) {
+                selectedEntry = entry;
+                selectedValue = value;
+            }
+        }
+
+        if (selectedEntry == null) {
+            throw new IllegalStateException("no entries in WeightedList");
+        }
+
+        return selectedEntry.getElement();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ticket/ChunkTicketManagerMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ticket/ChunkTicketManagerMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..9f465b60f3ab6d811302ffd2e8e7f27e50625435
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ticket/ChunkTicketManagerMixin.java
@@ -0,0 +1,100 @@
+package net.gegy1000.tictacs.mixin.ticket;
+
+import it.unimi.dsi.fastutil.longs.LongList;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.ticket.PlayerTicketManager;
+import net.gegy1000.tictacs.chunk.ticket.TicketTracker;
+import net.minecraft.server.world.ChunkHolder;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.server.world.ChunkTicketType;
+import net.minecraft.server.world.ThreadedAnvilChunkStorage;
+import net.minecraft.util.math.ChunkPos;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.Unique;
+
+import java.util.Comparator;
+import java.util.Set;
+
+@Mixin(ChunkTicketManager.class)
+public abstract class ChunkTicketManagerMixin implements TicketTracker {
+    private static final ChunkTicketType<ChunkPos> GENERATION_TICKET = ChunkTicketType.create("player_generation", Comparator.comparingLong(ChunkPos::toLong));
+
+    @Shadow
+    @Final
+    public ChunkTicketManager.DistanceFromNearestPlayerTracker distanceFromNearestPlayerTracker;
+    @Shadow
+    @Final
+    public ChunkTicketManager.NearbyChunkTicketUpdater nearbyChunkTicketUpdater;
+    @Shadow
+    @Final
+    public ChunkTicketManager.TicketDistanceLevelPropagator distanceFromTicketTracker;
+    @Shadow
+    @Final
+    public Set<ChunkHolder> chunkHolders;
+
+    private PlayerTicketManager fullTickets;
+    private PlayerTicketManager generationTickets;
+
+    /**
+     * @reason redirect player ticket logic to {@link PlayerTicketManager}
+     * @author gegy1000
+     */
+    @Overwrite
+    public boolean tick(ThreadedAnvilChunkStorage tacs) {
+        this.initialize(tacs);
+
+        LongList fullTickets = this.fullTickets.collectTickets();
+        LongList generationTickets = this.generationTickets.collectTickets();
+
+        this.distanceFromNearestPlayerTracker.updateLevels();
+        this.nearbyChunkTicketUpdater.updateLevels();
+
+        int completedTasks = Integer.MAX_VALUE - this.distanceFromTicketTracker.update(Integer.MAX_VALUE);
+
+        this.fullTickets.waitForChunks(fullTickets);
+        this.generationTickets.waitForChunks(generationTickets);
+
+        if (!this.chunkHolders.isEmpty()) {
+            for (ChunkHolder holder : this.chunkHolders) {
+                ChunkEntry entry = (ChunkEntry) holder;
+                entry.onUpdateLevel(tacs);
+            }
+            this.chunkHolders.clear();
+            return true;
+        }
+
+        return completedTasks != 0;
+    }
+
+    @Unique
+    private void initialize(ThreadedAnvilChunkStorage tacs) {
+        if (this.fullTickets == null || this.generationTickets == null) {
+            ChunkController controller = (ChunkController) tacs;
+            this.fullTickets = new PlayerTicketManager(controller, ChunkStep.FULL, 2, ChunkTicketType.PLAYER, 2);
+            this.generationTickets = new PlayerTicketManager(controller, ChunkStep.GENERATION, 0, GENERATION_TICKET, 5);
+        }
+    }
+
+    @Override
+    public void enqueueTicket(long pos, int distance) {
+        this.fullTickets.enqueueTicket(pos, distance);
+        this.generationTickets.enqueueTicket(pos, distance);
+    }
+
+    @Override
+    public void removeTicket(long pos) {
+        this.fullTickets.removeTicket(pos);
+        this.generationTickets.removeTicket(pos);
+    }
+
+    @Override
+    public void moveTicket(long pos, int fromDistance, int toDistance) {
+        this.fullTickets.moveTicket(pos, fromDistance, toDistance);
+        this.generationTickets.moveTicket(pos, fromDistance, toDistance);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/ticket/NearbyChunkTicketUpdaterMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/ticket/NearbyChunkTicketUpdaterMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab742922f19356847348edf8e940c4fe1343a97a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/ticket/NearbyChunkTicketUpdaterMixin.java
@@ -0,0 +1,51 @@
+package net.gegy1000.tictacs.mixin.ticket;
+
+import net.gegy1000.tictacs.chunk.ticket.TicketTracker;
+import net.minecraft.server.world.ChunkTaskPrioritySystem;
+import net.minecraft.server.world.ChunkTicketManager;
+import net.minecraft.util.math.ChunkPos;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Redirect;
+
+import java.util.function.IntConsumer;
+import java.util.function.IntSupplier;
+
+@Mixin(ChunkTicketManager.NearbyChunkTicketUpdater.class)
+public class NearbyChunkTicketUpdaterMixin {
+    @Shadow(aliases = "field_17463")
+    private ChunkTicketManager ticketManager;
+
+    /**
+     * @author gegy1000
+     * @see ChunkTicketManagerMixin
+     */
+    @Overwrite
+    public void updateTicket(long pos, int distance, boolean wasTracked, boolean isTracked) {
+        if (wasTracked == isTracked) {
+            return;
+        }
+
+        TicketTracker ticketTracker = (TicketTracker) this.ticketManager;
+        if (isTracked) {
+            ticketTracker.enqueueTicket(pos, distance);
+        } else {
+            ticketTracker.removeTicket(pos);
+        }
+    }
+
+    @Redirect(
+            method = "updateLevels",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/server/world/ChunkTaskPrioritySystem;updateLevel(Lnet/minecraft/util/math/ChunkPos;Ljava/util/function/IntSupplier;ILjava/util/function/IntConsumer;)V"
+            )
+    )
+    private void updateLevel(ChunkTaskPrioritySystem ctps, ChunkPos pos, IntSupplier getLevel, int targetLevel, IntConsumer setLevel) {
+        TicketTracker ticketTracker = (TicketTracker) this.ticketManager;
+        ticketTracker.moveTicket(pos.toLong(), getLevel.getAsInt(), targetLevel);
+        setLevel.accept(targetLevel);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/EntityMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/EntityMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..028b31f7b09034aad08b5d59f0ff692eeb2173ac
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/EntityMixin.java
@@ -0,0 +1,107 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import net.minecraft.block.BlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.MovementType;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.Redirect;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
+
+@Mixin(Entity.class)
+public abstract class EntityMixin {
+    @Shadow
+    public World world;
+
+    @Shadow
+    public boolean updateNeeded;
+
+    @Shadow
+    private boolean chunkPosUpdateRequested;
+
+    @Shadow
+    public abstract BlockPos getBlockPos();
+
+    @Inject(method = "move", at = @At("HEAD"), cancellable = true)
+    private void move(MovementType type, Vec3d movement, CallbackInfo ci) {
+        // skip entity move logic if the current chunk is not loaded
+        // this can often otherwise cause the main thread to block while waiting for a chunk to load
+        // it is not important for this check to be correct, only that it eliminates most normal cases of blocking
+
+        BlockPos pos = this.getBlockPos();
+        if (!this.world.isChunkLoaded(pos) || !this.world.isChunkLoaded(pos.add(movement.x, movement.y, movement.z))) {
+            ci.cancel();
+        }
+    }
+
+    @Redirect(
+            method = "getLandingBlockState",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private BlockState getBlockStateForLandingBlockState(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "getLandingPos",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private BlockState getBlockStateForLandingPos(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "isInsideBubbleColumn",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private BlockState getBlockStateForBubbleColumn(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "updateMovementInFluid",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getFluidState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/fluid/FluidState;"
+            )
+    )
+    private FluidState getFluidStateForMovement(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getFluidStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "updateSubmergedInWaterState",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getFluidState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/fluid/FluidState;"
+            )
+    )
+    private FluidState getFluidStateForSubmergedState(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getFluidStateIfLoaded(pos);
+    }
+
+    @Inject(method = "isChunkPosUpdateRequested", at = @At("HEAD"))
+    private void isChunkPosUpdateRequested(CallbackInfoReturnable<Boolean> ci) {
+        // if we're not added to any chunk, try add us to a chunk
+        if (!this.updateNeeded) {
+            this.chunkPosUpdateRequested = true;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/LivingEntityMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/LivingEntityMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..db0147e9f6d78521fa022f6fde0daef185820a4d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/LivingEntityMixin.java
@@ -0,0 +1,71 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import net.minecraft.block.BlockState;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityType;
+import net.minecraft.entity.LivingEntity;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.Vec3d;
+import net.minecraft.world.World;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.Redirect;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+@Mixin(LivingEntity.class)
+public abstract class LivingEntityMixin extends Entity {
+    private LivingEntityMixin(EntityType<?> type, World world) {
+        super(type, world);
+    }
+
+    @Inject(method = "travel", at = @At("HEAD"), cancellable = true)
+    private void travel(Vec3d movement, CallbackInfo ci) {
+        // skip entity travel logic if the current chunk is not loaded
+        if (!this.world.isChunkLoaded(this.getBlockPos())) {
+            ci.cancel();
+        }
+    }
+
+    @Redirect(
+            method = "getBlockState",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private BlockState getBlockStateAtEntity(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "travel",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private BlockState getBlockStateForMovement(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+    }
+
+    @Redirect(
+            method = "travel",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/World;getFluidState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/fluid/FluidState;"
+            )
+    )
+    private FluidState getFluidStateForMovement(World world, BlockPos pos) {
+        return ((NonBlockingWorldAccess) world).getFluidStateIfLoaded(pos);
+    }
+
+    @Inject(method = "applyMovementEffects", at = @At("HEAD"), cancellable = true)
+    private void applyMovementEffects(BlockPos pos, CallbackInfo ci) {
+        if (!this.world.isChunkLoaded(pos)) {
+            ci.cancel();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerPlayerEntityMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerPlayerEntityMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a4db831aef09fa24bd668ff67d461e82b627532
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerPlayerEntityMixin.java
@@ -0,0 +1,25 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityType;
+import net.minecraft.server.network.ServerPlayerEntity;
+import net.minecraft.world.World;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
+
+@Mixin(ServerPlayerEntity.class)
+public abstract class ServerPlayerEntityMixin extends Entity {
+    private ServerPlayerEntityMixin(EntityType<?> type, World world) {
+        super(type, world);
+    }
+
+    @Inject(method = "playerTick", at = @At("HEAD"), cancellable = true)
+    private void playerTick(CallbackInfo ci) {
+        // skip player ticking if chunk is not loaded to replicate thread-blocking behavior in vanilla
+        if (!this.world.isChunkLoaded(this.getBlockPos())) {
+            ci.cancel();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerWorldMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerWorldMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2f62a231d70e5c1e637586c02c28e577c689ca2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/ServerWorldMixin.java
@@ -0,0 +1,108 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.gegy1000.tictacs.AsyncChunkAccess;
+import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.block.BlockState;
+import net.minecraft.block.Blocks;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.fluid.Fluids;
+import net.minecraft.server.world.ServerChunkManager;
+import net.minecraft.server.world.ServerWorld;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.profiler.Profiler;
+import net.minecraft.util.registry.RegistryKey;
+import net.minecraft.world.Heightmap;
+import net.minecraft.world.MutableWorldProperties;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import net.minecraft.world.dimension.DimensionType;
+import org.jetbrains.annotations.Nullable;
+import org.spongepowered.asm.mixin.Final;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+@Mixin(ServerWorld.class)
+public abstract class ServerWorldMixin extends World implements NonBlockingWorldAccess, AsyncChunkAccess {
+    @Shadow
+    @Final
+    private ServerChunkManager serverChunkManager;
+
+    private ServerWorldMixin(MutableWorldProperties properties, RegistryKey<World> registryKey, DimensionType dimensionType, Supplier<Profiler> supplier, boolean client, boolean debugWorld, long biomeSeed) {
+        super(properties, registryKey, dimensionType, supplier, client, debugWorld, biomeSeed);
+    }
+
+    @Override
+    public BlockState getBlockStateIfLoaded(BlockPos pos) {
+        if (isOutOfBuildLimitVertically(pos)) {
+            return Blocks.VOID_AIR.getDefaultState();
+        }
+
+        Chunk chunk = this.getExistingChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStep.FEATURES);
+        if (chunk != null) {
+            return chunk.getBlockState(pos);
+        } else {
+            return Blocks.AIR.getDefaultState();
+        }
+    }
+
+    @Override
+    public FluidState getFluidStateIfLoaded(BlockPos pos) {
+        if (isOutOfBuildLimitVertically(pos)) {
+            return Fluids.EMPTY.getDefaultState();
+        }
+
+        Chunk chunk = this.getExistingChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStep.FEATURES);
+        if (chunk != null) {
+            return chunk.getFluidState(pos);
+        } else {
+            return Fluids.EMPTY.getDefaultState();
+        }
+    }
+
+    @Override
+    public int getTopY(Heightmap.Type heightmap, int x, int z) {
+        if (x < -30000000 || z < -30000000 || x >= 30000000 || z >= 30000000) {
+            return this.getSeaLevel() + 1;
+        }
+
+        int chunkX = x >> 4;
+        int chunkZ = z >> 4;
+        if (this.shouldChunkExist(chunkX, chunkZ, ChunkStep.FEATURES)) {
+            Chunk chunk = this.getChunk(chunkX, chunkZ, ChunkStatus.FEATURES);
+            return chunk.sampleHeightmap(heightmap, x & 15, z & 15) + 1;
+        } else {
+            return 0;
+        }
+    }
+
+    @Override
+    public boolean isChunkLoaded(int x, int z) {
+        return this.getExistingChunk(x, z, ChunkStep.FULL) != null;
+    }
+
+    @Override
+    public Chunk getExistingChunk(int x, int z, ChunkStep step) {
+        return ((AsyncChunkAccess) this.serverChunkManager).getExistingChunk(x, z, step);
+    }
+
+    @Nullable
+    @Override
+    public Chunk getAnyExistingChunk(int chunkX, int chunkZ) {
+        return ((AsyncChunkAccess) this.serverChunkManager).getAnyExistingChunk(chunkX, chunkZ);
+    }
+
+    @Override
+    public CompletableFuture<Chunk> getOrCreateChunkAsync(int x, int z, ChunkStep step) {
+        return ((AsyncChunkAccess) this.serverChunkManager).getOrCreateChunkAsync(x, z, step);
+    }
+
+    @Override
+    public boolean shouldChunkExist(int x, int z, ChunkStep step) {
+        return ((AsyncChunkAccess) this.serverChunkManager).shouldChunkExist(x, z, step);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/VoxelShapesMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/VoxelShapesMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..33138a61297904234a9fc471887d53a5ab5b7154
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/VoxelShapesMixin.java
@@ -0,0 +1,28 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import net.minecraft.block.BlockState;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.shape.VoxelShapes;
+import net.minecraft.world.WorldView;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Redirect;
+
+@Mixin(value = VoxelShapes.class, priority = 1001)
+public class VoxelShapesMixin {
+    @Redirect(
+            method = "calculatePushVelocity(Lnet/minecraft/util/math/Box;Lnet/minecraft/world/WorldView;DLnet/minecraft/block/ShapeContext;Lnet/minecraft/util/math/AxisCycleDirection;Ljava/util/stream/Stream;)D",
+            at = @At(
+                    value = "INVOKE",
+                    target = "Lnet/minecraft/world/WorldView;getBlockState(Lnet/minecraft/util/math/BlockPos;)Lnet/minecraft/block/BlockState;"
+            )
+    )
+    private static BlockState getBlockState(WorldView world, BlockPos pos) {
+        if (world instanceof NonBlockingWorldAccess) {
+            return ((NonBlockingWorldAccess) world).getBlockStateIfLoaded(pos);
+        } else {
+            return world.getBlockState(pos);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/mixin/unblocking/WorldMixin.java b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/WorldMixin.java
new file mode 100644
index 0000000000000000000000000000000000000000..9631a72c0334e314cbbefa19610746621c6087de
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/mixin/unblocking/WorldMixin.java
@@ -0,0 +1,57 @@
+package net.gegy1000.tictacs.mixin.unblocking;
+
+import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import net.minecraft.block.BlockState;
+import net.minecraft.block.Blocks;
+import net.minecraft.fluid.FluidState;
+import net.minecraft.fluid.Fluids;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.ChunkStatus;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+
+@Mixin(World.class)
+public abstract class WorldMixin implements NonBlockingWorldAccess {
+    @Shadow
+    public static boolean isOutOfBuildLimitVertically(BlockPos pos) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Shadow
+    public abstract Chunk getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create);
+
+    /**
+     * TODO: ideally, we don't want to @Overwrite this
+     *
+     * @reason we don't need to require a FULL chunk, because after the FEATURES step, no more blocks should be changed.
+     * this allows us to not block on lighting to retrieve a block
+     * @author gegy1000
+     */
+    @Overwrite
+    public BlockState getBlockState(BlockPos pos) {
+        if (isOutOfBuildLimitVertically(pos)) {
+            return Blocks.VOID_AIR.getDefaultState();
+        }
+
+        Chunk chunk = this.getChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.FEATURES, true);
+        return chunk.getBlockState(pos);
+    }
+
+    /**
+     * @reason we don't need to require a FULL chunk, because after the FEATURES step, no more blocks should be changed.
+     * this allows us to not block on lighting to retrieve a block
+     * @author gegy1000
+     */
+    @Overwrite
+    public FluidState getFluidState(BlockPos pos) {
+        if (isOutOfBuildLimitVertically(pos)) {
+            return Fluids.EMPTY.getDefaultState();
+        }
+
+        Chunk chunk = this.getChunk(pos.getX() >> 4, pos.getZ() >> 4, ChunkStatus.FEATURES, true);
+        return chunk.getFluidState(pos);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java b/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..00fbe5c9970079e90ee04dd4e38c1ecda6509d20
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java
@@ -0,0 +1,23 @@
+package net.gegy1000.tictacs.util;
+
+import sun.misc.Unsafe;
+
+import java.lang.reflect.Field;
+
+public final class UnsafeAccess {
+    private static final Unsafe INSTANCE = getUnsafe();
+
+    private static Unsafe getUnsafe() {
+        try {
+            Field field = Unsafe.class.getDeclaredField("theUnsafe");
+            field.setAccessible(true);
+            return (Unsafe) field.get(null);
+        } catch (ReflectiveOperationException e) {
+            throw new Error("failed to access unsafe", e);
+        }
+    }
+
+    public static Unsafe get() {
+        return INSTANCE;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 13948d6225efc4bbac87788d970d00e6a62586a1..cb5c031222cd5c4d281b3b1a3b12dc8a38ee953c 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -54,8 +54,115 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.entity.Player; // CraftBukkit
 import org.spigotmc.AsyncCatcher;
+// Titanium start - tic-tacs imports
+import net.minecraft.server.WorldLoadListener;
+import net.gegy1000.tictacs.VoidActor;
+import net.gegy1000.tictacs.async.worker.ChunkMainThreadExecutor;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.future.AwaitAll;
+import net.gegy1000.tictacs.chunk.future.ChunkNotLoadedFuture;
+import net.gegy1000.tictacs.chunk.future.LazyRunnableFuture;
+import net.gegy1000.tictacs.chunk.future.VanillaChunkFuture;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.tracker.ChunkTracker;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+// Titanium end - tic-tacs imports
+
+
+public abstract class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d, ChunkController {
+    // Titanium start - tic-tacs
+    public ThreadExecutor<Runnable> mainThreadExecutor;
+    public LightEngineThreaded lightEngineThreaded;
+    public ChunkDistanceManager ticketManager;
+    public WorldLoadListener worldLoadListener;
+    public AtomicInteger totalChunksLoadedCount;
+    public int watchDistance;
+    public ChunkMap map = new ChunkMap(world, this);
+    public ChunkUpgrader upgrader = new ChunkUpgrader(world, this, chunkGenerator, structures, lighting);
+    public ChunkTracker tracker = new ChunkTracker(world, this);
+    public ChunkLevelTracker levelTracker = new ChunkLevelTracker(world, this);
+    public ChunkMainThreadExecutor chunkMainExecutor = new ChunkMainThreadExecutor(mainThread);
+    public LightEngineThreaded lighting = this.lightengineThreaded;
+
+    tracker.PlayerChunkMap.a(watchDistance<int>);
+
+    map.addListener(tracker<ChunkTracker>);
+    
+    private TaskExecutor<Runnable> createWorldgenActor(Executor executor, String name) {
+        return new VoidActor(name);
+    }
+    public ChunkMap getMap() {
+        return this.map;
+    }
+    
+    public ChunkUpgrader getUpgrader() {
+        return this.upgrader;
+    }
+
+    public ChunkTracker getTracker() {
+        return this.tracker;
+    }
+
+    public ChunkListener getChunkAs(ChunkEntry entry, ChunkStep step) {
+        this.upgrader.spawnUpgradeTo(entry, step);
+        return entry.getListenerFor(step);
+    }
+
+    public Future<Unit> getRadiusAs(ChunkPos pos, int radius, ChunkStep step) {
+        ChunkAccess chunks = this.map.visible();
+
+        ChunkMap.FlushListener flushListener = this.map.awaitFlush();
+
+        int size = radius * 2 + 1;
+        Future<Chunk>[] futures = new Future[size * size];
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                int idx = (x + radius) + (z + radius) * size;
+                ChunkEntry entry = chunks.getEntry(pos.x + x, pos.z + z);
+                if (entry == null) {
+                    return flushListener.andThen(unit -> this.getRadiusAs(pos, radius, step));
+                }
+
+                if (entry.isValidAs(step)) {
+                    this.upgrader.spawnUpgradeTo(entry, step);
+                    futures[idx] = entry.getListenerFor(step);
+                } else {
+                    return ChunkNotLoadedFuture.get();
+                }
+            }
+        }
+
+        flushListener.invalidateWaker();
+
+        return AwaitAll.of(futures);
+    }
+
+    public Future<Chunk> spawnLoadChunk(ChunkEntry entry) {
+        return VanillaChunkFuture.of(this.loadChunk(entry.getPos()));
+    }
+
+    public void notifyStatus(ChunkPos pos, ChunkStatus status) {
+        this.worldGenerationProgressListener.setChunkStatus(pos, status);
+    }
+
+    public <T> void spawnOnMainThread(ChunkEntry entry, Future<T> future) {
+        this.chunkMainExecutor.spawn(entry, future);
+    }
+
+    public void spawnOnMainThread(ChunkEntry entry, Runnable runnable) {
+        this.chunkMainExecutor.spawn(entry, new LazyRunnableFuture(runnable));
+    }
+
+    private ObjectCollection<?> getChunks(Long2ObjectLinkedOpenHashMap<?> map) {
+        return this.map.primary().getEntries();
+    }
+    // Titanium end
 
-public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
@@ -823,13 +930,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> b(ChunkCoordIntPair chunkcoordintpair) {
-        return this.a(chunkcoordintpair, 2, (i) -> {
-            return ChunkStatus.FULL;
-        }).thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                return (Chunk) list.get(list.size() / 2);
-            });
-        }, this.mainInvokingExecutor); // Paper
+        // Titanium start - tic-tacs
+        CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> future = new CompletableFuture<>();
+
+        ChunkEntry entry = this.map.primary().getEntry(chunkcoordintpair);
+
+        this.spawnOnMainThread(entry, this.getRadiusAs(pos, 2, ChunkStep.FULL).handle((ok, err) -> {
+            if (err == null && entry.getWorldChunk() != null) {
+                future.complete(Either.left(entry.getWorldChunk()));
+            } else {
+                future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+            }
+            return Unit.INSTANCE;
+        }));
+
+        return future;
+        // Titanium start
     }
 
     @Nullable
@@ -875,6 +991,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Override
     public void close() throws IOException {
+        /*
         try {
             this.lightThread.shutdown(); // Paper
             this.p.close();
@@ -883,7 +1000,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         } finally {
             super.close();
         }
-
+        */
+        this.chunkMainExecutor.close(); // Titanium - tic-tacs
     }
 
     // Paper start - incremental autosave
@@ -1186,44 +1304,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(PlayerChunk playerchunk, ChunkStatus chunkstatus) {
-        ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-
-        if (chunkstatus == ChunkStatus.EMPTY) {
-            return this.f(chunkcoordintpair);
-        } else {
-            CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = playerchunk.a(chunkstatus.e(), this);
+        // Titanium start - tic-tacs
+        ChunkStep step = ChunkStep.byStatus(chunkstatus);
 
-            return completablefuture.thenComposeAsync((either) -> {
-                Optional<IChunkAccess> optional = either.left();
+        ChunkEntry entry = (ChunkEntry) playerchunk;
+        this.upgrader.spawnUpgradeTo(entry, step);
 
-                if (!optional.isPresent()) {
-                    return CompletableFuture.completedFuture(either);
-                } else {
-                    if (chunkstatus == ChunkStatus.LIGHT) {
-                        this.chunkDistanceManager.a(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.a(ChunkStatus.FEATURES), chunkcoordintpair);
-                    }
-
-                    IChunkAccess ichunkaccess = (IChunkAccess) optional.get();
-
-                    if (ichunkaccess.getChunkStatus().b(chunkstatus)) {
-                        CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture1; // Paper
-
-                        if (chunkstatus == ChunkStatus.LIGHT) {
-                            completablefuture1 = this.b(playerchunk, chunkstatus);
-                        } else {
-                            completablefuture1 = chunkstatus.a(this.world, this.definedStructureManager, this.lightEngine, (ichunkaccess1) -> {
-                                return this.c(playerchunk);
-                            }, ichunkaccess);
-                        }
-
-                        this.worldLoadListener.a(chunkcoordintpair, chunkstatus);
-                        return completablefuture1;
-                    } else {
-                        return this.b(playerchunk, chunkstatus);
-                    }
-                }
-            }, this.mainInvokingExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainInvokingExecutor); // Paper - optimize chunk status progression without jumping through thread pool - ensure main
-        }
+        return entry.getListenerFor(step).asVanilla();
+        // Titanium end - tic-tacs
     }
 
     private CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> f(ChunkCoordIntPair chunkcoordintpair) {
@@ -1358,11 +1446,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void c(ChunkCoordIntPair chunkcoordintpair) {
-        this.executor.a(SystemUtils.a(() -> {
-            this.chunkDistanceManager.b(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.a(ChunkStatus.FEATURES), chunkcoordintpair);
-        }, () -> {
-            return "release light ticket " + chunkcoordintpair;
-        }));
+        this.mainThreadExecutor.send(() -> {
+            this.ticketManager.removeTicketWithLevel(ChunkTicketType.LIGHT, chunkcoordintpair, ChunkLevelTracker.LIGHT_TICKET_LEVEL, chunkcoordintpair);
+        });
     }
 
     private ChunkStatus a(ChunkStatus chunkstatus, int i) {
@@ -1668,7 +1754,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected PlayerChunkMap.a e() {
-        return this.chunkDistanceManager;
+        return this.ticketManager; // Titanium - tic-tacs
     }
 
     protected Iterable<PlayerChunk> f() {
@@ -2598,19 +2684,19 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
         @Override
         protected boolean a(long i) {
-            return PlayerChunkMap.this.unloadQueue.contains(i);
+            return this.map.primary().getEntry(i); // Titanium - tic-tacs
         }
 
         @Nullable
         @Override
         protected PlayerChunk b(long i) {
-            return PlayerChunkMap.this.getUpdatingChunk(i);
+            return this.map.visible().getEntry(i); // Titanium - tic-tacs
         }
 
         @Nullable
         @Override
         protected PlayerChunk a(long i, int j, @Nullable PlayerChunk playerchunk, int k) {
-            return PlayerChunkMap.this.a(i, j, playerchunk, k);
+            return this.levelTracker.setLevel(i, j, (ChunkEntry) playerchunk, k); // Titanium - tic-tacs
         }
     }
 }
