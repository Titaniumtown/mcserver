From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Wed, 3 Mar 2021 12:02:28 -0500
Subject: [PATCH] Async Entity Ticking

Based off of: https://github.com/PaperMC/Paper/pull/2671 by Bloodrayne1995

diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index cdda74564ced196ae577a64782236c2bfe36e433..7aa78e48d45b8026b12f8b2d425fb5932a56bfd9 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -27,10 +27,13 @@ public final class EntityList implements Iterable<Entity> {
     }
 
     public boolean contains(final Entity entity) {
+        synchronized (this.entityToIndex) {
         return this.entityToIndex.containsKey(entity.getId());
+        }
     }
 
     public boolean remove(final Entity entity) {
+        synchronized (this.entityToIndex) {
         final int index = this.entityToIndex.remove(entity.getId());
         if (index == Integer.MIN_VALUE) {
             return false;
@@ -45,12 +48,13 @@ public final class EntityList implements Iterable<Entity> {
         }
         this.entities[index] = end;
         this.entities[endIndex] = null;
-
+        }
         return true;
     }
 
     public boolean add(final Entity entity) {
         final int count = this.count;
+        synchronized (this.entityToIndex) {
         final int currIndex = this.entityToIndex.putIfAbsent(entity.getId(), count);
 
         if (currIndex != Integer.MIN_VALUE) {
@@ -66,7 +70,7 @@ public final class EntityList implements Iterable<Entity> {
 
         list[count] = entity;
         this.count = count + 1;
-
+        }
         return true;
     }
 
@@ -86,7 +90,9 @@ public final class EntityList implements Iterable<Entity> {
     }
 
     public void clear() {
+        synchronized (this.entityToIndex) {
         this.entityToIndex.clear();
+        }
         Arrays.fill(this.entities, 0, this.count, null);
         this.count = 0;
     }
diff --git a/src/main/java/com/tuinity/tuinity/util/TickThread.java b/src/main/java/com/tuinity/tuinity/util/TickThread.java
index 08ed243259f052165c6f75aed1d1d65a14219715..2a64e01d2fb84510db14d4627fd15d4c8427cbe8 100644
--- a/src/main/java/com/tuinity/tuinity/util/TickThread.java
+++ b/src/main/java/com/tuinity/tuinity/util/TickThread.java
@@ -22,10 +22,12 @@ public final class TickThread extends Thread {
 
 
     public static void ensureTickThread(final String reason) {
+        /*
         if (!Bukkit.isPrimaryThread()) {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
index 180c724b40228f11ed0c9869779cf466e8e97ebe..b938b2edb80d2f29ef5b77157b31f5a1db438b98 100644
--- a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
+++ b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
@@ -158,11 +158,15 @@ public class EntityTrackerEngine {
     }
 
     private TrackedEntityList getOrCreateList(int x, int y, int z) {
+        synchronized (this.sections) {
         return this.sections.computeIfAbsent(encode(x, y, z), TrackedEntityList::new);
+        }
     }
 
     private TrackedEntityList getList(int x, int y, int z) {
+        synchronized (this.sections) {
         return this.sections.get(encode(x, y, z));
+        }
     }
 
     private static long encode(int x, int y, int z) {
@@ -184,14 +188,17 @@ public class EntityTrackerEngine {
         }
 
         public void addListener(NearbyEntityListener listener) {
+            synchronized (this.entities) {
             for (EntityLiving entity : this.entities) {
                 listener.onEntityEnteredRange(entity);
             }
 
             this.listeners.add(listener);
+            }
         }
 
         public void removeListener(NearbyEntityListener listener) {
+            synchronized (this.entities) {
             if (this.listeners.remove(listener)) {
                 for (EntityLiving entity : this.entities) {
                     listener.onEntityLeftRange(entity);
@@ -199,17 +206,21 @@ public class EntityTrackerEngine {
 
                 this.checkEmpty();
             }
+            }
         }
 
         public boolean addTrackedEntity(EntityLiving entity) {
+            synchronized (this.entities) {
             for (NearbyEntityListener listener : this.listeners) {
                 listener.onEntityEnteredRange(entity);
             }
 
             return this.entities.add(entity);
+            }
         }
 
         public boolean removeTrackedEntity(EntityLiving entity) {
+            synchronized (this.entities) {
             boolean ret = this.entities.remove(entity);
 
             if (ret) {
@@ -221,11 +232,16 @@ public class EntityTrackerEngine {
             }
 
             return ret;
+            }
         }
 
         private void checkEmpty() {
+            synchronized (this.entities) {
             if (this.entities.isEmpty() && this.listeners.isEmpty()) {
+                synchronized (EntityTrackerEngine.this.sections) {
                 EntityTrackerEngine.this.sections.remove(this.key);
+                }
+            }
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index e00445c7ac452f42e2c5e50efd3044c4f2e90ff1..170087c6ad3e9b26a94d90278197269df692a4f4 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -10,6 +10,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import org.yatopiamc.yatopia.server.ticking.AsyncTickManager;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
@@ -100,6 +101,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     private double fakeTime; // Purpur
 
 
+    private AsyncTickManager aTickManager = null; // Yatopia - async entity ticking
     // CraftBukkit start
     private int tickPosition;
     public final Convertable.ConversionSession convertable;
@@ -490,6 +492,10 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
         this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
         this.fakeTime = this.worldDataServer.getDayTime(); // Purpur
+        // Yatopia start - Async entity Ticking
+        this.aTickManager = new AsyncTickManager(this);
+        this.aTickManager.prepareManager();
+        // Yatopia end
     }
 
     // Tuinity start - optimise collision
@@ -979,6 +985,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             }
 
             this.tickingEntities = true;
+            synchronized (this.entitiesForIteration) {
             com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator = this.entitiesForIteration.iterator(); // Tuinity
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
@@ -1050,7 +1057,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 gameprofilerfiller.enter("remove");
                 if (entity.dead) {
                     this.removeEntityFromChunk(entity);
+                    synchronized (this.entitiesById) {
                     this.entitiesById.remove(entity.getId()); // Tuinity
+                    }
                     this.unregisterEntity(entity);
                 } else if (entity.inChunk && entity.valid) { // Tuinity start - optimise notify()
                     if (this.getChunkProvider().isInEntityTickingChunk(entity)) {
@@ -1066,6 +1075,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             timings.entityTick.stopTiming(); // Spigot
 
             objectiterator.finishedIterating(); // Tuinity
+            }
+            if (org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntities) this.aTickManager.startTick(); // Yatopia - Async entity ticking
             this.tickingEntities = false;
             // Paper start
             for (java.lang.Runnable run : this.afterEntityTickingTasks) {
@@ -1418,8 +1429,14 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 gameprofilerfiller.c("tickNonPassenger");
                 if (isActive) { // Paper - EAR 2
                     TimingHistory.activatedEntityTicks++; // Paper
+                // Yatopia - Async entity ticking
+                if (!org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntities) {
                 entity.tick();
                 entity.postTick(); // CraftBukkit
+                } else {
+                    this.aTickManager.queueEntity(entity);
+                }
+                // Yatopia end
                 } else { entity.inactiveTick(); } // Paper - EAR 2
                 gameprofilerfiller.exit();
             }
@@ -1625,6 +1642,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     public List<Entity> a(@Nullable EntityTypes<?> entitytypes, Predicate<? super Entity> predicate) {
         List<Entity> list = Lists.newArrayList();
         ChunkProviderServer chunkproviderserver = this.getChunkProvider();
+        synchronized (this.entitiesById) {
         ObjectIterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1634,12 +1652,13 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 list.add(entity);
             }
         }
-
+        }
         return list;
     }
 
     public List<EntityEnderDragon> g() {
         List<EntityEnderDragon> list = Lists.newArrayList();
+        synchronized (this.entitiesById) {
         ObjectIterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1649,6 +1668,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 list.add((EntityEnderDragon) entity);
             }
         }
+        }
 
         return list;
     }
@@ -1915,8 +1935,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                         continue;
                     }
                     // Paper end
-
+                    synchronized (this.entitiesById) {
                     this.entitiesById.remove(entity.getId());
+                    }
                     this.unregisterEntity(entity);
 
                     if (entity.dead) iterator.remove(); // Paper - don't save dead entities during unload
@@ -1934,12 +1955,16 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
     public void unregisterEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+        synchronized (this.entitiesForIteration) {
         this.entitiesForIteration.remove(entity); // Tuinity
+        }
         // Paper start - fix entity registration issues
         if (entity instanceof EntityComplexPart) {
             // Usually this is a no-op for complex parts, and ID's should be removed, but go ahead and remove it anyways
             // Dragon parts are handled special in register. they don't receive a valid = true or register by UUID etc.
+            synchronized (this.entitiesById) {
             this.entitiesById.remove(entity.getId(), entity);
+            }
             return;
         }
         if (!entity.valid) {
@@ -2108,6 +2133,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
         // Paper start - don't double enqueue entity registration
         //noinspection ObjectEquality
+        synchronized (this.entitiesById) {
         if (this.entitiesById.get(entity.getId()) == entity) {
             LOGGER.error(entity + " was already registered!");
             new Throwable().printStackTrace();
@@ -2121,7 +2147,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             }
         } else {
             entity.isQueuedForRegister = false; // Paper
+            synchronized (this.entitiesById) {
             this.entitiesById.put(entity.getId(), entity);
+            synchronized (this.entitiesForIteration) {
             this.entitiesForIteration.add(entity); // Tuinity
             if (entity instanceof EntityEnderDragon) {
                 EntityComplexPart[] aentitycomplexpart = ((EntityEnderDragon) entity).eJ();
@@ -2134,6 +2162,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                     this.entitiesForIteration.add(entitycomplexpart); // Tuinity
                 }
             }
+            }
+            }
 
             if (DEBUG_ENTITIES) {
                 entity.addedToWorldStack = getAddToWorldStackTrace(entity);
@@ -2177,6 +2207,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             entity.shouldBeRemoved = false; // Paper - shouldn't be removed after being re-added
             new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entity.getBukkitEntity()).callEvent(); // Paper - fire while valid
         }
+        }
 
     }
 
@@ -2185,7 +2216,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException("Removing entity while ticking!")));
         } else {
             this.removeEntityFromChunk(entity);
+            synchronized (this.entitiesById) {
             this.entitiesById.remove(entity.getId());
+            }
             this.unregisterEntity(entity);
             entity.shouldBeRemoved = true; // Paper
         }
@@ -2483,7 +2516,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     @Nullable
     @Override
     public Entity getEntity(int i) {
+        synchronized (this.entitiesById) {
         return (Entity) this.entitiesById.get(i);
+        }
     }
 
     @Nullable
@@ -2776,8 +2811,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                     bufferedwriter.write(String.format("spawn_count.%s: %d\n", ((EnumCreatureType) it_unimi_dsi_fastutil_objects_object2intmap_entry.getKey()).b(), it_unimi_dsi_fastutil_objects_object2intmap_entry.getIntValue()));
                 }
             }
-
+            synchronized (this.entitiesById) {
             bufferedwriter.write(String.format("entities: %d\n", this.entitiesById.size()));
+            }
             bufferedwriter.write(String.format("block_entities: %d\n", this.tileEntityListTick.size())); // Paper - remove unused list
             bufferedwriter.write(String.format("block_ticks: %d\n", this.getBlockTickList().a()));
             bufferedwriter.write(String.format("fluid_ticks: %d\n", this.getFluidTickList().a()));
@@ -2856,7 +2892,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         Throwable throwable9 = null;
 
         try {
+            synchronized (this.entitiesById) {
             a((Writer) bufferedwriter3, (Iterable) this.entitiesById.values());
+            }
         } catch (Throwable throwable10) {
             throwable9 = throwable10;
             throw throwable10;
@@ -2949,7 +2987,9 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     }
 
     public Iterable<Entity> A() {
+        synchronized (this.entitiesById) {
         return Iterables.unmodifiableIterable(this.entitiesById.values());
+        }
     }
 
     public String toString() {
@@ -2982,11 +3022,13 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
     @VisibleForTesting
     public String F() {
+        synchronized (this.entitiesById) {
         return String.format("players: %s, entities: %d [%s], block_entities: %d [%s], block_ticks: %d, fluid_ticks: %d, chunk_source: %s", this.players.size(), this.entitiesById.size(), a(this.entitiesById.values(), (entity) -> { // CraftBukkit - decompile error
             return IRegistry.ENTITY_TYPE.getKey(entity.getEntityType());
         }), this.tileEntityListTick.size(), a(this.tileEntityListTick, (tileentity) -> { // CraftBukkit - decompile error
             return IRegistry.BLOCK_ENTITY_TYPE.getKey(tileentity.getTileType());
         }), this.getBlockTickList().a(), this.getFluidTickList().a(), this.P());
+        }
     }
 
     private static <T> String a(Collection<T> collection, Function<T, MinecraftKey> function) {
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..c0d0e69711e0db496085cc07a6a926036bbcfae2 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -5,7 +5,7 @@ import net.minecraft.server.MinecraftServer;
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
     public static boolean shuttingDown = false; // Paper
 
     public static void catchOp(String reason)
diff --git a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
index cb6ddf318ed07f05e32f8149e7b8be37bb6f1cf1..f9dab2bb49cf5dc6bf52183d79a228e1573ddb1c 100644
--- a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
@@ -304,4 +304,13 @@ public class YatopiaConfig {
         regionFileIOThreadPoolSize = getInt("settings.threads.regionfile", -1);
         Preconditions.checkArgument(regionFileIOThreadPoolSize == -1 || regionFileIOThreadPoolSize > 0, "Invalid settings.threads.regionfile in yatopia.yml");
     }
+
+    public static boolean asyncEntities = false;
+    public static int asyncEntitiestickTasksCount = 1;
+    public static boolean asyncEntityDebug = false;
+    private static void asyncentityTicking() {
+        asyncEntities = getBoolean("settings.async-entity.enabled", asyncEntities);
+        asyncEntitiestickTasksCount = getInt("settings.async-entity.count-task", asyncEntitiestickTasksCount);
+        asyncEntityDebug = getBoolean("settings.async-entity.debug", asyncEntityDebug);
+    }
 }
diff --git a/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickManager.java b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..00521050220d9e7b65c4bf0b7082d7dd880d3105
--- /dev/null
+++ b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickManager.java
@@ -0,0 +1,48 @@
+package org.yatopiamc.yatopia.server.ticking;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.WorldServer;
+import java.util.ArrayList;
+
+
+public class AsyncTickManager {
+
+    private WorldServer targetWorld = null;
+
+    private ArrayList<AsyncTickTask> tasks = new ArrayList<>();
+
+    private int current_task = 0;
+
+    private int max_task = 1;
+
+    public AsyncTickManager(WorldServer world) {
+        targetWorld = world;
+    }
+
+    public void prepareManager() {
+        max_task = org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntitiestickTasksCount;
+
+        if (max_task <= 0) {
+            max_task = 1;
+        }
+
+        for (int i = 0; i < max_task; i++) {
+            tasks.add(new AsyncTickTask(targetWorld));
+        }
+    }
+
+    public void queueEntity(Entity entity) {
+        if (current_task >= max_task) {
+            current_task = 0;
+        }
+
+        tasks.get(current_task).addEntity(entity);
+        current_task++;
+    }
+
+    public void startTick() {
+        for (AsyncTickTask task:tasks) {
+            task.startTick();
+        }
+    }
+}
diff --git a/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickTask.java b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..db70a6ed701ff78b2a7d892a6c0ac6379b9fed79
--- /dev/null
+++ b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncTickTask.java
@@ -0,0 +1,75 @@
+package org.yatopiamc.yatopia.server.ticking;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.WorldServer;
+import org.bukkit.Server;
+import org.bukkit.Bukkit;
+import java.util.function.Consumer;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+public class AsyncTickTask implements Runnable {
+
+    private CopyOnWriteArrayList<Entity> target_entities = new CopyOnWriteArrayList<>();
+
+    private WorldServer targetWorld = null;
+
+    public AsyncTickTask(WorldServer world) {
+        targetWorld = world;
+    }
+
+    public void addEntity(Entity entity){
+        // synchronized (target_entities) {
+            target_entities.add(entity);
+        // }
+    }
+
+    public void startTick() {
+        Thread a = new Thread(this);
+        a.setName("AsyncEntityTask: (" + targetWorld.getWorld().getName()+")");
+        a.start();
+    }
+
+
+    @Override
+    public void run() {
+        if (org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntityDebug) {
+            if (Bukkit.isPrimaryThread()) {
+                System.out.println("Entity ticking on the main thread.");
+            }
+            else {
+                System.out.println("Entity ticking off the main thread.");
+            }
+        }
+        synchronized(target_entities) {
+            for (Entity entity:target_entities) {
+                if (entity == null) {
+                    continue;
+                }
+                this.a((entity1) -> {
+                    ++entity.ticksLived;
+                    entity.tick();
+                    entity.postTick();
+                }, entity);
+                if (entity.dead) {
+                    // TODO: Queue to remove
+                    targetWorld.removeEntity(entity);
+                }
+            }
+            // Clear entities for next tick
+            target_entities.clear();
+        }
+    }
+
+    public void a(Consumer<Entity> consumer, Entity entity) {
+        try {
+            consumer.accept(entity);
+        } catch (Throwable throwable) {
+            String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX() + "," + entity.locY() + "," + entity.locZ();
+            System.err.println(msg);
+            throwable.printStackTrace();
+            targetWorld.getServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable)));
+            entity.dead = true;
+            return;
+        }
+    }
+}
