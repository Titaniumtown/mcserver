From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Wed, 3 Mar 2021 12:02:28 -0500
Subject: [PATCH] Async Entity Ticking

Based off of: https://github.com/PaperMC/Paper/pull/2671 by Bloodrayne1995

diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index cdda74564ced196ae577a64782236c2bfe36e433..b8f6c238d08ba18ca6e63030aa88cfcecb8142a3 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -5,6 +5,7 @@ import net.minecraft.server.Entity;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
+import java.util.Collections;
 
 // list with O(1) remove & contains
 /**
diff --git a/src/main/java/com/tuinity/tuinity/util/TickThread.java b/src/main/java/com/tuinity/tuinity/util/TickThread.java
index 08ed243259f052165c6f75aed1d1d65a14219715..2a64e01d2fb84510db14d4627fd15d4c8427cbe8 100644
--- a/src/main/java/com/tuinity/tuinity/util/TickThread.java
+++ b/src/main/java/com/tuinity/tuinity/util/TickThread.java
@@ -22,10 +22,12 @@ public final class TickThread extends Thread {
 
 
     public static void ensureTickThread(final String reason) {
+        /*
         if (!Bukkit.isPrimaryThread()) {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
index 180c724b40228f11ed0c9869779cf466e8e97ebe..e1d83a5d85d54bb1551081f88605767170d1718b 100644
--- a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
+++ b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
@@ -12,6 +12,8 @@ import net.minecraft.server.StructureBoundingBox;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.Lock;
 
 /**
  * Tracks the entities within a world and provides notifications to listeners when a tracked entity enters or leaves a
@@ -21,11 +23,13 @@ import java.util.Set;
 public class EntityTrackerEngine {
     private final Long2ObjectOpenHashMap<TrackedEntityList> sections;
     private final Reference2ReferenceOpenHashMap<NearbyEntityListener, List<TrackedEntityList>> sectionsByEntity;
+    public final Lock entityTrackerEngineLock;
 
 
     public EntityTrackerEngine() {
         this.sections = new Long2ObjectOpenHashMap<>();
         this.sectionsByEntity = new Reference2ReferenceOpenHashMap<>();
+        this.entityTrackerEngineLock = new ReentrantLock();
     }
 
     /**
@@ -87,8 +91,9 @@ public class EntityTrackerEngine {
                 }
             }
         }
-
+        synchronized (this.sectionsByEntity) {
         this.sectionsByEntity.put(listener, all);
+        }
     }
 
     private void removeListener(NearbyEntityListener listener) {
@@ -97,7 +102,7 @@ public class EntityTrackerEngine {
         if (r == 0) {
             return;
         }
-
+        synchronized (this.sectionsByEntity) {
         List<TrackedEntityList> all = this.sectionsByEntity.remove(listener);
 
         if (all != null) {
@@ -107,6 +112,7 @@ public class EntityTrackerEngine {
         } else {
             throw new IllegalArgumentException("Entity listener not tracked:" + listener.toString());
         }
+        }
     }
 
     // Faster implementation which avoids removing from/adding to every list twice on an entity move event
@@ -158,11 +164,15 @@ public class EntityTrackerEngine {
     }
 
     private TrackedEntityList getOrCreateList(int x, int y, int z) {
+        synchronized (this.sections) { // Yatopia
         return this.sections.computeIfAbsent(encode(x, y, z), TrackedEntityList::new);
+        } // Yatopia
     }
 
     private TrackedEntityList getList(int x, int y, int z) {
+        synchronized (this.sections) { // Yatopia
         return this.sections.get(encode(x, y, z));
+        } // Yatopia
     }
 
     private static long encode(int x, int y, int z) {
@@ -184,14 +194,17 @@ public class EntityTrackerEngine {
         }
 
         public void addListener(NearbyEntityListener listener) {
+            synchronized (this.entities) { // Yatopia
             for (EntityLiving entity : this.entities) {
                 listener.onEntityEnteredRange(entity);
             }
 
             this.listeners.add(listener);
+            } // Yatopia
         }
 
         public void removeListener(NearbyEntityListener listener) {
+            synchronized (this.entities) { // Yatopia
             if (this.listeners.remove(listener)) {
                 for (EntityLiving entity : this.entities) {
                     listener.onEntityLeftRange(entity);
@@ -199,17 +212,21 @@ public class EntityTrackerEngine {
 
                 this.checkEmpty();
             }
+            } // Yatopia
         }
 
         public boolean addTrackedEntity(EntityLiving entity) {
+            synchronized (this.entities) { // Yatopia
             for (NearbyEntityListener listener : this.listeners) {
                 listener.onEntityEnteredRange(entity);
             }
 
             return this.entities.add(entity);
+            } // Yatopia
         }
 
         public boolean removeTrackedEntity(EntityLiving entity) {
+            synchronized (this.entities) { // Yatopia
             boolean ret = this.entities.remove(entity);
 
             if (ret) {
@@ -221,12 +238,17 @@ public class EntityTrackerEngine {
             }
 
             return ret;
+            } // Yatopia
         }
 
         private void checkEmpty() {
+            synchronized (this.entities) { // Yatopia
             if (this.entities.isEmpty() && this.listeners.isEmpty()) {
+                synchronized (EntityTrackerEngine.this.sections) { // Yatopia
                 EntityTrackerEngine.this.sections.remove(this.key);
+                } // Yatopia
             }
+            } // Yatopia
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 04acf3b9052986c0ad305350133644031d240b9b..49a2b5b44c9a9d7d317ae519f984f26f1c4256d1 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -814,6 +814,9 @@ public class Chunk implements IChunkAccess {
         if (!this.entitySlices[i].remove(entity)) { // Tuinity - optimise hard colliding entities // Tuinity - entities by class // Tuinity
             return;
         }
+
+        this.world.getEntityTracker().entityTrackerEngineLock.lock();
+        try {
         // Yatopia start - Port lithium
         if (entity instanceof EntityLiving) {
             this.world.getEntityTracker().onEntityAdded(entity.chunkX, entity.chunkY, entity.chunkZ, (EntityLiving) entity);
@@ -833,6 +836,9 @@ public class Chunk implements IChunkAccess {
             this.world.getEntityTracker().onEntityRemoved(entity.chunkX, entity.chunkY, entity.chunkZ, (EntityLiving) entity);
         }
         // Yatopia end
+        } finally {
+            this.world.getEntityTracker().entityTrackerEngineLock.unlock();
+        }
     }
 
     public final int getHighestBlockY(HeightMap.Type heightmap_type, int i, int j) { return this.getHighestBlock(heightmap_type, i, j) + 1; } // Paper - sort of an obfhelper, but without -1
diff --git a/src/main/java/net/minecraft/server/CombatTracker.java b/src/main/java/net/minecraft/server/CombatTracker.java
index a8054a599e3eb502e7bbce903b5683987f95fb66..f96fce1e7bf8aa68fe03cdfefa8600d8653ce88e 100644
--- a/src/main/java/net/minecraft/server/CombatTracker.java
+++ b/src/main/java/net/minecraft/server/CombatTracker.java
@@ -5,10 +5,11 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.Nullable;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public class CombatTracker {
 
-    private final List<CombatEntry> a = Lists.newArrayList();
+    private final CopyOnWriteArrayList<CombatEntry> a = new CopyOnWriteArrayList<>();
     private final EntityLiving b;
     private int c;
     private int d;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c46c3e8aaeb7496a4cfedae68181cf6e09b75acd..85ae1a0faf336412876d303e7897ce65c358a462 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -68,6 +68,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import org.yatopiamc.yatopia.server.ticking.AsyncEntityManager;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
 
@@ -808,6 +809,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             worldserver = (WorldServer) iterator.next();
             if (worldserver != null) {
                 try {
+                    worldserver.asyncentitymanager.shutdownExecutors(); // Yatopia
                     worldserver.close();
                 } catch (IOException ioexception) {
                     MinecraftServer.LOGGER.error("Exception closing the level", ioexception);
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index e00445c7ac452f42e2c5e50efd3044c4f2e90ff1..320939cfbe23f7b92d081547ca8f15211eaa107b 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -10,6 +10,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import org.yatopiamc.yatopia.server.ticking.AsyncEntityManager;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
@@ -59,9 +60,12 @@ import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Tuinity
 import net.gegy1000.tictacs.NonBlockingWorldAccess;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.Lock;
 
 public class WorldServer extends World implements GeneratorAccessSeed, NonBlockingWorldAccess {
 
+    public final Lock entityLock;
     public static final BlockPosition a = new BlockPosition(100, 50, 0);
     private static final Logger LOGGER = LogManager.getLogger();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2, true); // Tuinity - make removing entities while ticking safe
@@ -100,6 +104,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     private double fakeTime; // Purpur
 
 
+    public AsyncEntityManager asyncentitymanager = null; // Yatopia - Async entity ticking
     // CraftBukkit start
     private int tickPosition;
     public final Convertable.ConversionSession convertable;
@@ -490,6 +495,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
         this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
         this.fakeTime = this.worldDataServer.getDayTime(); // Purpur
+        this.asyncentitymanager = new AsyncEntityManager(); // Yatopia - Async entity Ticking
+        this.entityLock = new ReentrantLock();
     }
 
     // Tuinity start - optimise collision
@@ -1049,9 +1056,12 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 gameprofilerfiller.exit();
                 gameprofilerfiller.enter("remove");
                 if (entity.dead) {
+                    /*
                     this.removeEntityFromChunk(entity);
                     this.entitiesById.remove(entity.getId()); // Tuinity
                     this.unregisterEntity(entity);
+                    */
+                    this.removeEntity(entity);
                 } else if (entity.inChunk && entity.valid) { // Tuinity start - optimise notify()
                     if (this.getChunkProvider().isInEntityTickingChunk(entity)) {
                         this.updateNavigatorsInRegion(entity);
@@ -1066,6 +1076,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             timings.entityTick.stopTiming(); // Spigot
 
             objectiterator.finishedIterating(); // Tuinity
+            if (org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntities) this.asyncentitymanager.startTick(); // Yatopia - Async entity ticking
             this.tickingEntities = false;
             // Paper start
             for (java.lang.Runnable run : this.afterEntityTickingTasks) {
@@ -1405,6 +1416,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             entity.lastPitch = entity.pitch;
             if (entity.inChunk) {
                 ++entity.ticksLived;
+                // Yatopia start - Async entity ticking
                 GameProfilerFiller gameprofilerfiller = this.getMethodProfiler();
 
                 // Airplane start - create debug lambda once, todo do we even WANT the method profiler?
@@ -1416,12 +1428,24 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 gameprofilerfiller.a(entity.getEntityType().getEntityName);
                 // Airplane end
                 gameprofilerfiller.c("tickNonPassenger");
-                if (isActive) { // Paper - EAR 2
-                    TimingHistory.activatedEntityTicks++; // Paper
-                entity.tick();
-                entity.postTick(); // CraftBukkit
-                } else { entity.inactiveTick(); } // Paper - EAR 2
+                if (org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntities && !(entity instanceof EntityHuman)) {
+                    if (isActive) {
+                        TimingHistory.activatedEntityTicks++;
+                        this.asyncentitymanager.queueEntity(entity);
+                    } else {
+                        this.asyncentitymanager.queueEntityInactive(entity);
+                    }
+                } else {
+                if (isActive) {
+                    TimingHistory.activatedEntityTicks++;
+                    entity.tick();
+                    entity.postTick();
+                } else {
+                    entity.inactiveTick(); // Paper - EAR 2
+                }
                 gameprofilerfiller.exit();
+                }
+                // Yatopia end
             }
 
             this.chunkCheck(entity);
@@ -1816,7 +1840,12 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         } else {
             // Paper start
             if (entity1.dead) {
+                this.entityLock.lock();
+                try {
                 unregisterEntity(entity1); // remove the existing entity
+                } finally {
+                    this.entityLock.unlock();
+                }
                 return false;
             }
             // Paper end
@@ -1895,13 +1924,17 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 Entity entity = (Entity) iterator.next();
 
                 if (entity instanceof EntityLiving) { // Yatopia start - Port lithium
-
                     int chunkX = MathHelper.floor(entity.locX()) >> 4;
                     int chunkY = MathHelper.clamp(MathHelper.floor(entity.locY()) >> 4, 0, 15);
                     int chunkZ = MathHelper.floor(entity.locZ()) >> 4;
 
                     EntityTrackerEngine tracker = this.getEntityTracker();
+                    tracker.entityTrackerEngineLock.lock();
+                    try {
                     tracker.onEntityRemoved(chunkX, chunkY, chunkZ, (EntityLiving) entity);
+                    } finally {
+                        tracker.entityTrackerEngineLock.unlock();
+                    }
                 } // Yatopia End
 
                 if (!(entity instanceof EntityPlayer)) {
@@ -1915,9 +1948,13 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                         continue;
                     }
                     // Paper end
-
+                    this.entityLock.lock();
+                    try {
                     this.entitiesById.remove(entity.getId());
                     this.unregisterEntity(entity);
+                    } finally {
+                        this.entityLock.unlock();
+                    }
 
                     if (entity.dead) iterator.remove(); // Paper - don't save dead entities during unload
                 }
@@ -2108,6 +2145,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
         // Paper start - don't double enqueue entity registration
         //noinspection ObjectEquality
+        this.entityLock.lock();
+        try {
         if (this.entitiesById.get(entity.getId()) == entity) {
             LOGGER.error(entity + " was already registered!");
             new Throwable().printStackTrace();
@@ -2177,18 +2216,28 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             entity.shouldBeRemoved = false; // Paper - shouldn't be removed after being re-added
             new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entity.getBukkitEntity()).callEvent(); // Paper - fire while valid
         }
+        } finally {
+            this.entityLock.unlock();
+        }
 
     }
 
     public void removeEntity(Entity entity) {
+        /*
         if (false && this.tickingEntities) {  // Tuinity
             throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException("Removing entity while ticking!")));
         } else {
+        */
+        this.entityLock.lock();
+        try {
             this.removeEntityFromChunk(entity);
             this.entitiesById.remove(entity.getId());
             this.unregisterEntity(entity);
             entity.shouldBeRemoved = true; // Paper
+        } finally {
+            this.entityLock.unlock();
         }
+        // }
     }
 
     private void removeEntityFromChunk(Entity entity) {
@@ -2197,7 +2246,6 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         if (ichunkaccess != null) { // Paper
             ((Chunk) ichunkaccess).b(entity);
         }
-
     }
 
     public void removePlayer(EntityPlayer entityplayer) {
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..c0d0e69711e0db496085cc07a6a926036bbcfae2 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -5,7 +5,7 @@ import net.minecraft.server.MinecraftServer;
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
     public static boolean shuttingDown = false; // Paper
 
     public static void catchOp(String reason)
diff --git a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
index cb6ddf318ed07f05e32f8149e7b8be37bb6f1cf1..af7d363467730c6f03387b621aba5d647e9f6e1b 100644
--- a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
@@ -304,4 +304,13 @@ public class YatopiaConfig {
         regionFileIOThreadPoolSize = getInt("settings.threads.regionfile", -1);
         Preconditions.checkArgument(regionFileIOThreadPoolSize == -1 || regionFileIOThreadPoolSize > 0, "Invalid settings.threads.regionfile in yatopia.yml");
     }
+
+    public static boolean asyncEntities = false;
+    public static int asyncEntityThreads = 2;
+    public static boolean asyncEntityDebug = false;
+    private static void asyncentityTicking() {
+        asyncEntities = getBoolean("settings.async-entity.enabled", asyncEntities);
+        asyncEntityThreads = getInt("settings.async-entity.threads", asyncEntityThreads);
+        asyncEntityDebug = getBoolean("settings.async-entity.debug", asyncEntityDebug);
+    }
 }
diff --git a/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd6439eeb5f4e717cbe6fce8b9941e410f3b1866
--- /dev/null
+++ b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java
@@ -0,0 +1,63 @@
+package org.yatopiamc.yatopia.server.ticking;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.WorldServer;
+import java.util.ArrayList;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.bukkit.Server;
+import org.bukkit.Bukkit;
+import co.aikar.timings.TimingHistory;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+public class AsyncEntityManager {
+
+    public ExecutorService entityTickExecutor = Executors.newFixedThreadPool(org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntityThreads);
+
+    private CopyOnWriteArrayList<Entity> targetEntitiesTick = new CopyOnWriteArrayList<>();
+    private CopyOnWriteArrayList<Entity> targetEntitiesInactive = new CopyOnWriteArrayList<>();
+
+    public AsyncEntityManager() {}
+
+    public void queueEntity(Entity entity) {
+        // synchronized(targetEntitiesTick) {
+            targetEntitiesTick.add(entity);
+        // }
+    }
+
+    public void queueEntityInactive(Entity entity) {
+        // synchronized(targetEntitiesInactive) {
+            targetEntitiesInactive.add(entity);
+        // }
+    }
+
+    public void startTick() {
+        targetEntitiesTick.stream().forEach(entity -> {
+            entityTickExecutor.execute(() -> {
+            TimingHistory.activatedEntityTicks++;
+            entity.tick();
+            entity.postTick();
+            });
+        });
+        targetEntitiesInactive.stream().forEach(entity -> {
+            entityTickExecutor.execute(() -> {
+                entity.inactiveTick();
+            });
+        });
+        targetEntitiesTick.clear();
+        targetEntitiesInactive.clear();
+    }
+
+    public void shutdownExecutors() {
+        entityTickExecutor.shutdown();
+        while (!entityTickExecutor.isTerminated()) {
+            try {
+                entityTickExecutor.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+
+}
