From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Fri, 8 Jan 2021 00:46:36 -0500
Subject: [PATCH] tic-tacs


diff --git a/src/main/java/me/titaniumtown/TitaniumConfig.java b/src/main/java/me/titaniumtown/TitaniumConfig.java
index 4737daae4b0acd65dbbc5e56134885c50ce36e64..a688e42e13350fa5192f7e0a742914bfc91329ea 100644
--- a/src/main/java/me/titaniumtown/TitaniumConfig.java
+++ b/src/main/java/me/titaniumtown/TitaniumConfig.java
@@ -14,6 +14,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.regex.Pattern;
 
+import net.minecraft.server.MathHelper;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 import org.bukkit.command.Command;
@@ -183,4 +184,15 @@ public class TitaniumConfig {
     public static double replace2 = WborderSize/2; // replacement for 3.0E7D
     public static int replace3 = biggestInt + 16; // replacement for 30000000
 
+    public static int ticTacThreadCount = MathHelper.clamp(Runtime.getRuntime().availableProcessors() / 2, 1, 2);
+    public static int ticTacMaxViewDistance = 32;
+    public static int ticTacFeatureGenerationRadius = 2;
+    public static boolean ticTacDebug = false;
+    private static void ticTacFeature() {
+        ticTacThreadCount = getInt("tic-tac.thread-count", ticTacThreadCount);
+        ticTacMaxViewDistance = getInt("tic-tac.max-view-distance", ticTacMaxViewDistance);
+        ticTacFeatureGenerationRadius = getInt("tic-tac.feature-gen-radius", ticTacFeatureGenerationRadius);
+        ticTacDebug = getBoolean("tic-tac.debug", ticTacDebug);
+    }
+
 }
diff --git a/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java b/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..06dfcdcb216f38ddbf24d86fc39ade05321c126b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncChunkAccess.java
@@ -0,0 +1,18 @@
+package net.gegy1000.tictacs;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.server.IChunkAccess;
+
+import java.util.concurrent.CompletableFuture;
+public interface AsyncChunkAccess {
+    IChunkAccess getExistingChunk(int x, int z, ChunkStep step);
+
+    IChunkAccess getAnyExistingChunk(int x, int z);
+
+    CompletableFuture<IChunkAccess> getOrCreateChunkAsync(int x, int z, ChunkStep step);
+
+    boolean shouldChunkExist(int x, int z, ChunkStep step);
+
+    default boolean shouldChunkExist(int x, int z) {
+        return this.shouldChunkExist(x, z, ChunkStep.FULL);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java b/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java
new file mode 100644
index 0000000000000000000000000000000000000000..9209f7e0dae80cbac43ad080a34404ed39c9ad71
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncChunkIo.java
@@ -0,0 +1,9 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.NBTTagCompound;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface AsyncChunkIo {
+    CompletableFuture<NBTTagCompound> getNbtAsync(ChunkCoordIntPair pos);
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java b/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java
new file mode 100644
index 0000000000000000000000000000000000000000..f341232ecd3c3729dfbb41e9e670a01892723862
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AsyncRegionStorageIo.java
@@ -0,0 +1,9 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.ChunkCoordIntPair;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+
+public interface AsyncRegionStorageIo {
+    CompletableFuture<Void> loadDataAtAsync(ChunkCoordIntPair pos, Executor mainThreadExecutor);
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/AtomicPool.java b/src/main/java/net/gegy1000/tictacs/AtomicPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..bdc37a6dacacec30d7af6a4c820a9ca690fbda95
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/AtomicPool.java
@@ -0,0 +1,55 @@
+package net.gegy1000.tictacs;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.Supplier;
+public final class AtomicPool<T> {
+    private final int capacity;
+
+    private final AtomicReferenceArray<T> array;
+    private final AtomicInteger pointer = new AtomicInteger(-1);
+
+    private final Supplier<T> supplier;
+
+    public AtomicPool(int capacity, Supplier<T> supplier) {
+        this.capacity = capacity;
+        this.array = new AtomicReferenceArray<>(capacity);
+        this.supplier = supplier;
+    }
+
+    public T acquire() {
+        while (true) {
+            int pointer = this.pointer.get();
+
+            // we've fallen outside the pool: allocate a new entry
+            if (pointer < 0) {
+                return this.supplier.get();
+            }
+
+            if (this.pointer.compareAndSet(pointer, pointer - 1)) {
+                T value = this.array.getAndSet(pointer, null);
+                if (value == null) {
+                    // this value hasn't been set yet: try again
+                    continue;
+                }
+                return value;
+            }
+        }
+    }
+
+    public void release(T object) {
+        while (true) {
+            int pointer = this.pointer.get();
+            int newPointer = pointer + 1;
+
+            // the pool is full, we don't need to return this object
+            if (newPointer >= this.capacity) {
+                return;
+            }
+
+            if (this.pointer.compareAndSet(pointer, newPointer)) {
+                this.array.set(newPointer, object);
+                return;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java b/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c0d2997682a4fe351fbe4400a1903afb31c7046
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/NonBlockingWorldAccess.java
@@ -0,0 +1,30 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Fluid;
+import net.minecraft.server.FluidTypes;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.IWorldReader;
+
+public interface NonBlockingWorldAccess extends IWorldReader {
+    default IBlockData getBlockStateIfLoaded(BlockPosition pos) {
+        int x = pos.getX() >> 4;
+        int z = pos.getZ() >> 4;
+        IChunkAccess chunk = this.getChunkIfLoadedImmediately(x, z);
+        if (chunk != null) {
+            return getType(pos);
+        }
+        return Blocks.AIR.getBlockData();
+    }
+
+    default Fluid getFluidStateIfLoaded(BlockPosition pos) {
+        int x = pos.getX() >> 4;
+        int z = pos.getZ() >> 4;
+        IChunkAccess chunk = this.getChunkIfLoadedImmediately(x, z);
+        if (chunk != null) {
+            return this.getFluid(pos);
+        }
+        return FluidTypes.EMPTY.h();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java b/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd32e7e8b358f83838e7ff190a6503424978d50c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/OwnThreadActor.java
@@ -0,0 +1,102 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.PairedQueue;
+import net.minecraft.server.ThreadedMailbox;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+public final class OwnThreadActor<T> extends ThreadedMailbox<T> {
+    private static final Logger LOGGER = LogManager.getLogger(OwnThreadActor.class);
+    private static final Map<String, OwnThreadActor<Runnable>> ACTORS = new HashMap<>();
+
+    private final Object lock = new Object();
+
+    private final AtomicInteger refCount = new AtomicInteger();
+    private volatile boolean active = true;
+
+    private OwnThreadActor(PairedQueue<? super T, ? extends Runnable> queue, String name) {
+        super(queue, task -> {}, name);
+    }
+
+    public static OwnThreadActor<Runnable> create(String name) {
+        OwnThreadActor<Runnable> actor;
+        synchronized (ACTORS) {
+            // merge actors by the same name
+            actor = ACTORS.computeIfAbsent(name, OwnThreadActor::startActor);
+        }
+
+        actor.acquireRef();
+
+        return actor;
+    }
+
+    private static OwnThreadActor<Runnable> startActor(String name) {
+        PairedQueue.c<Runnable> queue = new PairedQueue.c<>(new ArrayDeque<>());
+        OwnThreadActor<Runnable> actor = new OwnThreadActor<>(queue, name);
+
+        Thread thread = new Thread(actor);
+        thread.setName(name + "-actor");
+        thread.setDaemon(true);
+        thread.start();
+
+        return actor;
+    }
+
+    @Override
+    public void run() {
+        try {
+            while (this.active) {
+                Runnable task;
+                synchronized (this.lock) {
+                    while ((task = this.a.a()) == null) {
+                        if (!this.active) return;
+                        this.lock.wait();
+                    }
+                }
+
+                task.run();
+            }
+        } catch (InterruptedException e) {
+            LOGGER.error("Actor thread interrupted", e);
+        }
+    }
+
+    @Override
+    public void a(T message) {
+        synchronized (this.lock) {
+            this.a.a(message);
+            this.lock.notify();
+        }
+    }
+
+    private void acquireRef() {
+        this.refCount.getAndIncrement();
+    }
+
+    private boolean releaseRef() {
+        return this.refCount.decrementAndGet() <= 0;
+    }
+
+    private void stop() {
+        synchronized (this.lock) {
+            this.active = false;
+            this.lock.notify();
+        }
+
+        synchronized (ACTORS) {
+            ACTORS.remove(this.bj());
+        }
+    }
+
+    @Override
+    public void close() {
+        super.close();
+
+        if (this.releaseRef()) {
+            this.stop();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java b/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cd661e98a24421cad8c64169b44db7484534b84
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/PoiStorageAccess.java
@@ -0,0 +1,7 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkSection;
+
+public interface PoiStorageAccess {
+    void initSectionWithPois(ChunkCoordIntPair pos, ChunkSection section);
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/QueuingConnection.java b/src/main/java/net/gegy1000/tictacs/QueuingConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4a08889b6778474d628d79ced2816712e3d6cfa
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/QueuingConnection.java
@@ -0,0 +1,22 @@
+package net.gegy1000.tictacs;
+
+import io.netty.util.concurrent.GenericFutureListener;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PlayerConnection;
+
+import java.util.concurrent.Future;
+public interface QueuingConnection {
+    static void enqueueSend(PlayerConnection network, Packet<?> packet) {
+        ((QueuingConnection) network).enqueueSend(packet);
+    }
+
+    static void enqueueSend(PlayerConnection network, Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> callback) {
+        ((QueuingConnection) network).enqueueSend(packet, callback);
+    }
+
+    default void enqueueSend(Packet<?> packet) {
+        this.enqueueSend(packet, null);
+    }
+
+    void enqueueSend(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> callback);
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/TicTacs.java b/src/main/java/net/gegy1000/tictacs/TicTacs.java
new file mode 100644
index 0000000000000000000000000000000000000000..53590d003d4022bcc865522f5f5c6011de9278f5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/TicTacs.java
@@ -0,0 +1,26 @@
+package net.gegy1000.tictacs;
+
+import com.google.common.reflect.Reflection;
+// import net.fabricmc.api.ModInitializer;
+// import net.fabricmc.loader.api.FabricLoader;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgradeFuture;
+// import net.gegy1000.tictacs.config.TicTacsConfig;
+// import net.minecraft.util.Identifier;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class TicTacs {
+    public static final String ID = "tic_tacs";
+    public static final Logger LOGGER = LogManager.getLogger(ID);
+
+    public static final boolean DEBUG = false;
+
+    // @Override
+    // public void onInitialize() {
+    //     TicTacsConfig.get();
+
+    //     // due to a classloader bug in multithreaded environments, we need to load the class before multiple threads
+    //     // try to load it concurrently
+    //     Reflection.initialize(ChunkUpgradeFuture.class);
+    // }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/VoidActor.java b/src/main/java/net/gegy1000/tictacs/VoidActor.java
new file mode 100644
index 0000000000000000000000000000000000000000..196f5df35ad6f617d4f24066c20395e762f40ddc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/VoidActor.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs;
+import net.minecraft.server.PairedQueue;
+import net.minecraft.server.ThreadedMailbox;
+
+import javax.annotation.Nullable;
+public final class VoidActor extends ThreadedMailbox<Runnable> {
+    public VoidActor(String name) {
+        super(new VoidQueue(), runnable -> {}, name);
+    }
+
+    @Override
+    public void run() {
+    }
+
+    @Override
+    public void a(Runnable message) {
+    }
+
+    @Override
+    public void close() {
+    }
+
+    private static class VoidQueue implements PairedQueue<Runnable, Runnable> {
+
+        @Nullable
+        @Override
+        public Runnable a() {
+            return null;
+        }
+
+        @Override
+        public boolean a(Runnable message) {
+            return false;
+        }
+
+        @Override
+        public boolean b() {
+            return true;
+        }
+
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java b/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java
new file mode 100644
index 0000000000000000000000000000000000000000..c772a0f30320d90918868e0615c0f798b2c5f14b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/LinkedWaiter.java
@@ -0,0 +1,83 @@
+package net.gegy1000.tictacs.async;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+import javax.annotation.Nullable;
+
+public class LinkedWaiter {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+
+    private static final long WAKER_OFFSET;
+    private static final long NEXT_OFFSET;
+
+    static {
+        try {
+            WAKER_OFFSET = UNSAFE.objectFieldOffset(LinkedWaiter.class.getDeclaredField("waker"));
+            NEXT_OFFSET = UNSAFE.objectFieldOffset(LinkedWaiter.class.getDeclaredField("next"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get waiter field offsets", e);
+        }
+    }
+
+    private volatile Waker waker;
+    private volatile LinkedWaiter next = this.closed();
+
+    final void setWaker(Waker waker) {
+        this.waker = waker;
+    }
+
+    final boolean tryLink(LinkedWaiter next) {
+        return UNSAFE.compareAndSwapObject(this, NEXT_OFFSET, this.open(), next);
+    }
+
+    final boolean tryOpenLink() {
+        return UNSAFE.compareAndSwapObject(this, NEXT_OFFSET, this.closed(), this.open());
+    }
+
+    final void setLink(LinkedWaiter next) {
+        this.next = next;
+    }
+
+    @Nullable
+    final LinkedWaiter unlinkAndClose() {
+        return (LinkedWaiter) UNSAFE.getAndSetObject(this, NEXT_OFFSET, this.closed());
+    }
+
+    void wake() {
+        LinkedWaiter waiter = this;
+        while (waiter != null) {
+            waiter = waiter.wakeSelf();
+        }
+    }
+
+    @Nullable
+    LinkedWaiter wakeSelf() {
+        LinkedWaiter next = this.unlinkAndClose();
+        Waker waker = (Waker) UNSAFE.getAndSetObject(this, WAKER_OFFSET, null);
+
+        if (waker != null) {
+            waker.wake();
+        }
+
+        return next;
+    }
+
+    public final void invalidateWaker() {
+        this.waker = null;
+    }
+
+    final boolean isClosed(LinkedWaiter waiter) {
+        return waiter == this.closed();
+    }
+
+    private LinkedWaiter open() {
+        return null;
+    }
+
+    private LinkedWaiter closed() {
+        return this;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java b/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..533685566dadd8886f7cad05609894c7d38d28a5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/WaiterQueue.java
@@ -0,0 +1,101 @@
+package net.gegy1000.tictacs.async;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class WaiterQueue extends LinkedWaiter {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+
+    private static final long TAIL_OFFSET;
+
+    static {
+        try {
+            TAIL_OFFSET = UNSAFE.objectFieldOffset(WaiterQueue.class.getDeclaredField("tail"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get waiter field offsets", e);
+        }
+    }
+
+    private volatile LinkedWaiter tail = this;
+
+    public WaiterQueue() {
+        this.tryOpenLink();
+    }
+
+    public void registerWaiter(LinkedWaiter waiter, Waker waker) {
+        // initialize the waker on the waiter object
+        waiter.setWaker(waker);
+
+        // try to open the link on this waiter object
+        // if this fails, we must be already linked into the queue
+        if (!waiter.tryOpenLink()) {
+            return;
+        }
+
+        while (true) {
+            LinkedWaiter tail = this.tail;
+
+            // by linking the tail, the tail is essentially locked until the tail reference is swapped
+            if (tail.tryLink(waiter)) {
+                // swap the tail reference: if we fail, we must've been woken up already. we can accept
+                // ignoring the error because we know this node is enqueued to be awoken
+                UNSAFE.compareAndSwapObject(this, TAIL_OFFSET, tail, waiter);
+
+                return;
+            }
+        }
+    }
+
+    public void wake(int count) {
+        // unlink the waiter chain from the head
+        LinkedWaiter waiter = this.unlinkAndClose();
+
+        // if the head is closed, we must be in the progress of being woken up. let's not interfere
+        if (this.isClosed(waiter)) {
+            return;
+        }
+
+        if (waiter == null) {
+            this.clearAndOpen();
+            return;
+        }
+
+        for (int i = 0; i < count; i++) {
+            LinkedWaiter nextWaiter = waiter.wakeSelf();
+            if (nextWaiter == null) {
+                // no waiters left: we removed the tail element
+                this.clearAndOpen();
+                return;
+            }
+
+            waiter = nextWaiter;
+        }
+
+        this.setLink(waiter);
+    }
+
+    @Override
+    public void wake() {
+        // unlink the waiter chain from the head
+        LinkedWaiter waiter = this.unlinkAndClose();
+
+        // if the head is closed, we must be in the progress of being woken up. let's not interfere
+        if (this.isClosed(waiter)) {
+            return;
+        }
+
+        this.clearAndOpen();
+
+        if (waiter != null) {
+            waiter.wake();
+        }
+    }
+
+    private void clearAndOpen() {
+        // update the tail reference before opening the link again
+        this.tail = this;
+        this.tryOpenLink();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..67838bd0cbbc1c85829919c5a87b5ed39e8877be
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/JoinLock.java
@@ -0,0 +1,79 @@
+package net.gegy1000.tictacs.async.lock;
+
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.justnow.Waker;
+public final class JoinLock implements Lock {
+    private final Lock[] locks;
+
+    public JoinLock(Lock... locks) {
+        this.locks = locks;
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        for (int i = 0; i < this.locks.length; i++) {
+            Lock lock = this.locks[i];
+            if (lock != null && !lock.tryAcquire()) {
+                this.releaseUpTo(i);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        for (int i = 0; i < this.locks.length; i++) {
+            Lock lock = this.locks[i];
+            if (lock == null) {
+                continue;
+            }
+
+            PollLock poll = lock.tryPollLock(waiter, waker);
+            if (poll != PollLock.ACQUIRED) {
+                this.releaseUpTo(i);
+                return poll;
+            }
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        for (Lock lock : this.locks) {
+            if (lock != null && !lock.canAcquire()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void release() {
+        for (Lock lock : this.locks) {
+            if (lock != null) {
+                lock.release();
+            }
+        }
+    }
+
+    private void releaseUpTo(int endIndex) {
+        for (int i = 0; i < endIndex; i++) {
+            Lock lock = this.locks[i];
+            if (lock != null) {
+                lock.release();
+            }
+        }
+    }
+
+    @Override
+    public String toString() {
+        if (this.canAcquire()) {
+            return "JoinLock(FREE)";
+        } else {
+            return "JoinLock(ACQUIRED)";
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java b/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java
new file mode 100644
index 0000000000000000000000000000000000000000..58784e6f243aa11e11a8d012f30829c37372543d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Lock.java
@@ -0,0 +1,53 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+
+import javax.annotation.Nullable;
+
+public interface Lock {
+    Future<Unit> READY_FUTURE = Future.ready(Unit.INSTANCE);
+
+    boolean tryAcquire();
+
+    boolean canAcquire();
+
+    void release();
+
+    PollLock tryPollLock(LinkedWaiter waiter, Waker waker);
+
+    default Future<Unit> acquireAsync() {
+        // try acquire now to avoid the allocation: this is technically bad future behaviour, but we'll allow it
+        if (this.tryAcquire()) {
+            return READY_FUTURE;
+        }
+
+        return new AcquireFuture(this);
+    }
+
+    final class AcquireFuture extends LinkedWaiter implements Future<Unit> {
+        final Lock lock;
+
+        public AcquireFuture(Lock lock) {
+            this.lock = lock;
+        }
+
+        @Nullable
+        @Override
+        public Unit poll(Waker waker) {
+            while (true) {
+                // invalidate our waker if it is queued
+                this.invalidateWaker();
+
+                PollLock poll = this.lock.tryPollLock(this, waker);
+                if (poll == PollLock.ACQUIRED) {
+                    return Unit.INSTANCE;
+                } else if (poll == PollLock.PENDING) {
+                    return null;
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java b/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java
new file mode 100644
index 0000000000000000000000000000000000000000..48abfdc7b96714af86e5cb2033a35f689441dfd4
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Mutex.java
@@ -0,0 +1,64 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class Mutex implements Lock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    private static final int FREE = 0;
+    private static final int ACQUIRED = 1;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(Mutex.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get state field offsets", e);
+        }
+    }
+
+    private volatile int state = FREE;
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    @Override
+    public boolean tryAcquire() {
+        return UNSAFE.compareAndSwapInt(this, STATE_OFFSET, FREE, ACQUIRED);
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        if (!this.tryAcquire()) {
+            this.waiters.registerWaiter(waiter, waker);
+            return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return this.state == FREE;
+    }
+
+    @Override
+    public void release() {
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, ACQUIRED, FREE)) {
+            throw new IllegalStateException("lock not acquired");
+        }
+        this.waiters.wake();
+    }
+
+    @Override
+    public String toString() {
+        if (this.canAcquire()) {
+            return "Mutex(FREE)";
+        } else {
+            return "Mutex(ACQUIRED)";
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..31052ac15361ad34e6045bb1471129a4a746ebcb
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/NullLock.java
@@ -0,0 +1,30 @@
+package net.gegy1000.tictacs.async.lock;
+
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.justnow.Waker;
+public final class NullLock implements Lock {
+    public static final Lock INSTANCE = new NullLock();
+
+    private NullLock() {
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        return true;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return true;
+    }
+
+    @Override
+    public void release() {
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        return PollLock.ACQUIRED;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3581c5460b1d2cd564324bb539126c23046eeb3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/PollLock.java
@@ -0,0 +1,7 @@
+package net.gegy1000.tictacs.async.lock;
+
+public enum PollLock {
+    PENDING,
+    ACQUIRED,
+    RETRY
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java b/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..9970fe2835ee49c0d1e1db32ca7cd5d88c6aa0f5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/RwLock.java
@@ -0,0 +1,167 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class RwLock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(RwLock.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get state field offsets", e);
+        }
+    }
+
+    private static final int FREE = 0;
+    private static final int WRITING = -1;
+
+    private final Read read = new Read();
+    private final Write write = new Write();
+
+    private volatile int state = FREE;
+
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    public Lock read() {
+        return this.read;
+    }
+
+    public Lock write() {
+        return this.write;
+    }
+
+    boolean tryAcquireRead() {
+        while (true) {
+            int state = this.state;
+            if (state == WRITING) {
+                return false;
+            }
+
+            if (UNSAFE.compareAndSwapInt(this, STATE_OFFSET, state, state + 1)) {
+                return true;
+            }
+        }
+    }
+
+    boolean canAcquireRead() {
+        return this.state != WRITING;
+    }
+
+    boolean tryAcquireWrite() {
+        return UNSAFE.compareAndSwapInt(this, STATE_OFFSET, FREE, WRITING);
+    }
+
+    boolean canAcquireWrite() {
+        return this.state == FREE;
+    }
+
+    void releaseWrite() {
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, WRITING, FREE)) {
+            throw new IllegalStateException("write lock not acquired");
+        }
+
+        this.waiters.wake();
+    }
+
+    void releaseRead() {
+        int readCount = UNSAFE.getAndAddInt(this, STATE_OFFSET, -1) - 1;
+        if (readCount < 0) {
+            throw new IllegalStateException("read lock not acquired");
+        }
+
+        if (readCount == FREE) {
+            this.waiters.wake();
+        }
+    }
+
+    @Override
+    public String toString() {
+        int state = this.state;
+        if (state == FREE) {
+            return "RwLock(FREE)";
+        } else if (state == WRITING) {
+            return "RwLock(WRITING)";
+        } else {
+            return "RwLock(READING=" + state + ")";
+        }
+    }
+
+    private final class Read implements Lock {
+        @Override
+        public boolean tryAcquire() {
+            return RwLock.this.tryAcquireRead();
+        }
+
+        @Override
+        public boolean canAcquire() {
+            return RwLock.this.canAcquireRead();
+        }
+
+        @Override
+        public void release() {
+            RwLock.this.releaseRead();
+        }
+
+        @Override
+        public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+            if (!this.tryAcquire()) {
+                RwLock.this.waiters.registerWaiter(waiter, waker);
+                return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+            }
+
+            return PollLock.ACQUIRED;
+        }
+
+        @Override
+        public String toString() {
+            if (this.canAcquire()) {
+                return "RwLock.Read(FREE)";
+            } else {
+                return "RwLock.Read(LOCKED)";
+            }
+        }
+    }
+
+    private final class Write implements Lock {
+        @Override
+        public boolean tryAcquire() {
+            return RwLock.this.tryAcquireWrite();
+        }
+
+        @Override
+        public boolean canAcquire() {
+            return RwLock.this.canAcquireWrite();
+        }
+
+        @Override
+        public void release() {
+            RwLock.this.releaseWrite();
+        }
+
+        @Override
+        public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+            if (!this.tryAcquire()) {
+                RwLock.this.waiters.registerWaiter(waiter, waker);
+                return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+            }
+
+            return PollLock.ACQUIRED;
+        }
+
+        @Override
+        public String toString() {
+            if (this.canAcquire()) {
+                return "RwLock.Write(FREE)";
+            } else {
+                return "RwLock.Write(LOCKED)";
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java b/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ee439f7d5ab62a27e64e6ce58fff1b7da445f07
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/lock/Semaphore.java
@@ -0,0 +1,78 @@
+package net.gegy1000.tictacs.async.lock;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class Semaphore implements Lock {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long COUNT_OFFSET;
+
+    static {
+        try {
+            COUNT_OFFSET = UNSAFE.objectFieldOffset(Semaphore.class.getDeclaredField("count"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("Failed to get count field offsets", e);
+        }
+    }
+
+    private final int maximum;
+    private volatile int count = 0;
+
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    public Semaphore(int maximum) {
+        this.maximum = maximum;
+    }
+
+    private boolean canAcquire(int count) {
+        return count < this.maximum;
+    }
+
+    @Override
+    public boolean tryAcquire() {
+        while (true) {
+            int count = this.count;
+            if (!this.canAcquire(count)) {
+                return false;
+            }
+
+            if (UNSAFE.compareAndSwapInt(this, COUNT_OFFSET, count, count + 1)) {
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public PollLock tryPollLock(LinkedWaiter waiter, Waker waker) {
+        if (!this.tryAcquire()) {
+            this.waiters.registerWaiter(waiter, waker);
+            return this.canAcquire() ? PollLock.RETRY : PollLock.PENDING;
+        }
+
+        return PollLock.ACQUIRED;
+    }
+
+    @Override
+    public boolean canAcquire() {
+        return this.canAcquire(this.count);
+    }
+
+    @Override
+    public void release() {
+        int count = UNSAFE.getAndAddInt(this, COUNT_OFFSET, -1);
+        if (count <= 0) {
+            throw new IllegalStateException("semaphore not acquired");
+        }
+
+        int newCount = count - 1;
+
+        int available = this.maximum - newCount;
+        if (available > 0) {
+            this.waiters.wake(available);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a98b109eec5539cc376dd480d0d321d8f70e309
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkExecutor.java
@@ -0,0 +1,53 @@
+package net.gegy1000.tictacs.async.worker;
+
+import me.titaniumtown.TitaniumConfig;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.justnow.future.Future;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class ChunkExecutor implements TaskSpawner, TaskQueue, AutoCloseable {
+    public static final ChunkExecutor INSTANCE = new ChunkExecutor();
+
+    private static final Logger LOGGER = LogManager.getLogger("worldgen-worker");
+
+    private final LevelPrioritisedQueue<ChunkTask<?>> queue = new LevelPrioritisedQueue<>(ChunkLevelTracker.MAX_LEVEL);
+
+    private ChunkExecutor() {
+        for (int i = 0; i < TitaniumConfig.ticTacThreadCount; i++) {
+            Thread thread = new Thread(this::run);
+            thread.setName("worldgen-worker-" + (i + 1));
+            thread.setDaemon(true);
+            thread.start();
+        }
+    }
+
+    @Override
+    public <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future) {
+        ChunkTask<T> task = new ChunkTask<>(entry, future, this);
+        this.queue.enqueue(task, entry.getTicketLevel());
+        return task;
+    }
+
+    @Override
+    public <T> void enqueue(ChunkTask<T> task) {
+        this.queue.enqueue(task, task.getLevel());
+    }
+
+    public void run() {
+        try {
+            ChunkTask<?> task;
+            while ((task = this.queue.take()) != null) {
+                task.advance();
+            }
+        } catch (InterruptedException e) {
+            LOGGER.warn("worldgen worker interrupted", e);
+        }
+    }
+
+    @Override
+    public void close() {
+        this.queue.close();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..26c07ed09dc8ea2d269c08823caa573f1a3184f9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkMainThreadExecutor.java
@@ -0,0 +1,66 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.minecraft.server.IAsyncTaskHandler;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class ChunkMainThreadExecutor implements TaskSpawner, TaskQueue, AutoCloseable, Runnable {
+    private static final int BUFFER_SIZE = 16;
+
+    private final IAsyncTaskHandler<Runnable> executor;
+    private final AtomicInteger enqueued = new AtomicInteger(0);
+
+    private final LevelPrioritisedQueue<ChunkTask<?>> queue = new LevelPrioritisedQueue<>(ChunkLevelTracker.MAX_LEVEL);
+
+    public ChunkMainThreadExecutor(IAsyncTaskHandler<Runnable> executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public <T> void enqueue(ChunkTask<T> task) {
+        this.queue.enqueue(task, task.getLevel());
+        this.tryEnqueue();
+    }
+
+    @Override
+    public <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future) {
+        ChunkTask<T> task = new ChunkTask<>(entry, future, this);
+        this.enqueue(task);
+        return task;
+    }
+
+    @Override
+    public void run() {
+        this.enqueued.getAndDecrement();
+
+        ChunkTask<?> task = this.queue.remove();
+        if (task != null) {
+            task.advance();
+
+            // we still have more tasks to process: re-enqueue ourselves to the executor
+            this.tryEnqueue();
+        }
+    }
+
+    private void tryEnqueue() {
+        while (true) {
+            int enqueued = this.enqueued.get();
+            if (enqueued >= BUFFER_SIZE) {
+                return;
+            }
+
+            if (this.enqueued.compareAndSet(enqueued, enqueued + 1)) {
+                this.executor.addTask(this);
+                return;
+            }
+        }
+    }
+
+    @Override
+    public void close() {
+        this.queue.close();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..27bcf8dfff4a2dbf0157bc31fa9212e38134e82a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkTask.java
@@ -0,0 +1,59 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.PlayerChunk;
+
+
+public final class ChunkTask<T> {
+    public final PlayerChunk holder;
+
+    public final Future<T> future;
+    public final ChunkWaker waker = new ChunkWaker(this);
+
+    private volatile TaskQueue queue;
+
+    private volatile boolean complete;
+
+    ChunkTask(PlayerChunk holder, Future<T> future, TaskQueue queue) {
+        this.holder = holder;
+        this.future = future;
+        this.queue = queue;
+    }
+
+    public void moveTo(TaskQueue queue) {
+        this.queue = queue;
+    }
+
+    void advance() {
+        if (this.complete) return;
+
+        try {
+            this.waker.polling();
+            if (this.future.poll(this.waker) != null) {
+                this.complete = true;
+            } else {
+                this.waker.ready();
+            }
+        } catch (RuntimeException e) {
+            this.complete = true;
+
+            MinecraftServer.LOGGER.error("Worker thread exited with unhandled exception", e);
+            throw new Error(e);
+        }
+    }
+
+    void enqueue() {
+        if (this.complete) return;
+
+        this.queue.enqueue(this);
+    }
+
+    public boolean isComplete() {
+        return this.complete;
+    }
+
+    public int getLevel() {
+        return this.holder != null ? this.holder.getTicketLevel() : 0;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a5a14fe5ecf2bc3f911eb1e8a4178d6c8a9a829
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/ChunkWaker.java
@@ -0,0 +1,54 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import io.netty.util.internal.shaded.org.jctools.util.UnsafeAccess;
+import sun.misc.Unsafe;
+
+public final class ChunkWaker implements Waker {
+    // use unsafe for atomic operations without allocating an AtomicReference
+    private static final Unsafe UNSAFE = UnsafeAccess.get();
+    private static final long STATE_OFFSET;
+
+    static {
+        try {
+            STATE_OFFSET = UNSAFE.objectFieldOffset(ChunkWaker.class.getDeclaredField("state"));
+        } catch (NoSuchFieldException e) {
+            throw new Error("failed to get state offset", e);
+        }
+    }
+
+    private static final int WAITING = 0;
+    private static final int POLLING = 1;
+    private static final int AWOKEN = 2;
+
+    private final ChunkTask<?> task;
+
+    private volatile int state = AWOKEN;
+
+    ChunkWaker(ChunkTask<?> task) {
+        this.task = task;
+    }
+
+    @Override
+    public void wake() {
+        int prevState = UNSAFE.getAndSetInt(this, STATE_OFFSET, AWOKEN);
+
+        // only enqueue the task if we're still waiting for a signal
+        if (prevState == WAITING) {
+            this.task.enqueue();
+        }
+    }
+
+    void polling() {
+        this.state = POLLING;
+    }
+
+    void ready() {
+        // we didn't get a result: set state to waiting. we expect state to still be polling, so if that's *not*
+        // the case, we must've been awoken during polling. now that we know this task needs to continue
+        // execution, we can re-enqueue it.
+        if (!UNSAFE.compareAndSwapInt(this, STATE_OFFSET, POLLING, WAITING)) {
+            this.task.enqueue();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java b/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4b86de3fe6c72e01773cd8d2a4aa6a4bca09037
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/LevelPrioritisedQueue.java
@@ -0,0 +1,111 @@
+package net.gegy1000.tictacs.async.worker;
+
+import java.util.LinkedList;
+
+public final class LevelPrioritisedQueue<T> implements AutoCloseable {
+    private final int levelCount;
+    private final Level<T>[] levels;
+    private volatile int minLevel;
+
+    private volatile boolean open = true;
+
+    private final Object lock = new Object();
+
+    @SuppressWarnings("unchecked")
+    public LevelPrioritisedQueue(int levelCount) {
+        this.levelCount = levelCount;
+
+        this.levels = new Level[levelCount];
+        for (int i = 0; i < levelCount; i++) {
+            this.levels[i] = new Level<>();
+        }
+
+        this.minLevel = levelCount;
+    }
+
+    public void enqueue(T task, int level) {
+        if (level >= this.levelCount) {
+            level = this.levelCount - 1;
+        }
+
+        synchronized (this.lock) {
+            this.levels[level].enqueue(task);
+
+            if (level <= this.minLevel) {
+                this.minLevel = level;
+                this.lock.notify();
+            }
+        }
+    }
+
+    public T take() throws InterruptedException {
+        while (this.open) {
+            synchronized (this.lock) {
+                if (this.minLevel < this.levelCount) {
+                    T task = this.tryTakeTask(this.minLevel);
+                    if (task != null) {
+                        return task;
+                    }
+                }
+
+                this.lock.wait();
+            }
+        }
+
+        return null;
+    }
+
+    public T remove() {
+        synchronized (this.lock) {
+            int minLevel = this.minLevel;
+            if (minLevel < this.levelCount) {
+                T task = this.tryTakeTask(minLevel);
+                if (task != null) {
+                    return task;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    private T tryTakeTask(int level) {
+        T task = this.levels[level].take();
+        if (task != null) {
+            this.minLevel = this.findMinLevel(level);
+            return task;
+        }
+        return null;
+    }
+
+    private int findMinLevel(int level) {
+        while (level < this.levelCount && this.levels[level].isEmpty()) {
+            level++;
+        }
+        return level;
+    }
+
+    @Override
+    public void close() {
+        synchronized (this.lock) {
+            this.open = false;
+            this.lock.notifyAll();
+        }
+    }
+
+    static class Level<T> {
+        private final LinkedList<T> queue = new LinkedList<>();
+
+        void enqueue(T task) {
+            this.queue.add(task);
+        }
+
+        T take() {
+            return this.queue.remove();
+        }
+
+        boolean isEmpty() {
+            return this.queue.isEmpty();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java b/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e6afe5cf122713829e6fb05424b35c54cb9fedc
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/TaskQueue.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.async.worker;
+
+public interface TaskQueue {
+    <T> void enqueue(ChunkTask<T> task);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java b/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java
new file mode 100644
index 0000000000000000000000000000000000000000..54742ab8508353c3deab69ca4db64796a531cdf3
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/async/worker/TaskSpawner.java
@@ -0,0 +1,12 @@
+package net.gegy1000.tictacs.async.worker;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+public interface TaskSpawner {
+    <T> ChunkTask<T> spawn(ChunkEntry entry, Future<T> future);
+
+    default <T> ChunkTask<T> spawn(Future<T> future) {
+        return this.spawn(null, future);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..3411db0eb500a0470aed113f9a122433356d9d47
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkAccess.java
@@ -0,0 +1,36 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.minecraft.server.ChunkCoordIntPair;
+
+import javax.annotation.Nullable;
+
+public interface ChunkAccess {
+    void putEntry(ChunkEntry entry);
+
+    ChunkEntry removeEntry(long pos);
+
+    @Nullable
+    ChunkEntry getEntry(long pos);
+
+    @Nullable
+    default ChunkEntry getEntry(int chunkX, int chunkZ) {
+        return this.getEntry(ChunkCoordIntPair.pair(chunkX, chunkZ));
+    }
+
+    @Nullable
+    default ChunkEntry getEntry(ChunkCoordIntPair pos) {
+        return this.getEntry(pos.longKey);
+    }
+
+    default ChunkEntry expectEntry(int chunkX, int chunkZ) {
+        ChunkEntry entry = this.getEntry(chunkX, chunkZ);
+        if (entry == null) {
+            throw new IllegalStateException("expected entry at [" + chunkX + ", " + chunkZ + "]");
+        }
+        return entry;
+    }
+
+    ObjectCollection<ChunkEntry> getEntries();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a342dac89e89a01d7ec3cea4d717b306106e42c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkController.java
@@ -0,0 +1,44 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.tracker.ChunkTracker;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkMapDistance;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.PlayerChunkMap;
+
+public interface ChunkController {
+    default PlayerChunkMap asTacs() {
+        return (PlayerChunkMap) this;
+    }
+
+    ChunkMap getMap();
+
+    ChunkUpgrader getUpgrader();
+
+    ChunkMapDistance getTicketManager();
+
+    ChunkTracker getTracker();
+
+    ChunkListener getChunkAs(ChunkEntry entry, ChunkStep step);
+
+    Future<Unit> getRadiusAs(ChunkCoordIntPair pos, int radius, ChunkStep step);
+
+    Future<IChunkAccess> spawnLoadChunk(ChunkEntry entry);
+
+    void notifyStatus(ChunkCoordIntPair pos, ChunkStatus status);
+
+    <T> void spawnOnMainThread(ChunkEntry entry, Future<T> future);
+
+    default <T> void spawnOnMainThread(Future<T> future) {
+        this.spawnOnMainThread(null, future);
+    }
+
+    void spawnOnMainThread(ChunkEntry entry, Runnable runnable);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab8b4c54fd2264674fb6f4f95af2fceb923c5951
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLevelTracker.java
@@ -0,0 +1,111 @@
+package net.gegy1000.tictacs.chunk;
+
+import me.titaniumtown.TitaniumConfig;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.longs.LongSet;
+
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketPlayOutCustomPayload;
+import net.minecraft.server.Tuple;
+import net.minecraft.server.WorldServer;
+
+import javax.annotation.Nullable;
+import java.util.ArrayDeque;
+import java.util.List;
+import java.util.Queue;
+
+public final class ChunkLevelTracker {
+    public static final int FULL_LEVEL = TitaniumConfig.ticTacMaxViewDistance + 1;
+    public static final int MAX_LEVEL = FULL_LEVEL + ChunkStep.getMaxDistance() + 1;
+
+    public static final int LIGHT_TICKET_LEVEL = FULL_LEVEL + ChunkStep.getDistanceFromFull(ChunkStep.GENERATION);
+
+    private final WorldServer world;
+    private final ChunkController controller;
+
+    // Debug only!
+    private final Queue<Tuple<Long, Integer>> ticketCache = new ArrayDeque<>();
+
+    public ChunkLevelTracker(WorldServer world, ChunkController controller) {
+        this.world = world;
+        this.controller = controller;
+    }
+
+    @Nullable
+    public ChunkEntry setLevel(long pos, int toLevel, @Nullable ChunkEntry entry, int fromLevel) {
+        if (isUnloaded(fromLevel) && isUnloaded(toLevel)) {
+            return entry;
+        }
+
+        if (TitaniumConfig.ticTacDebug) {
+            this.sendDebugLevel(pos, toLevel);
+        }
+
+        if (entry != null) {
+            return this.updateLevel(pos, toLevel, entry);
+        } else {
+            return this.createAtLevel(pos, toLevel);
+        }
+    }
+
+    private ChunkEntry updateLevel(long pos, int toLevel, ChunkEntry entry) {
+        entry.a(toLevel);
+
+        TacsAccessor accessor = (TacsAccessor) this.controller;
+        LongSet unloadedChunks = accessor.getQueuedUnloads();
+
+        if (isUnloaded(toLevel)) {
+            unloadedChunks.add(pos);
+        } else {
+            unloadedChunks.remove(pos);
+        }
+
+        return entry;
+    }
+
+    @Nullable
+    private ChunkEntry createAtLevel(long pos, int toLevel) {
+        if (isUnloaded(toLevel)) {
+            return null;
+        }
+
+        return this.controller.getMap().loadEntry(pos, toLevel);
+    }
+
+    public static boolean isLoaded(int level) {
+        return level <= MAX_LEVEL;
+    }
+
+    public static boolean isUnloaded(int level) {
+        return level > MAX_LEVEL;
+    }
+
+    private void sendDebugLevel(long pos, int toLevel) {
+        List<EntityPlayer> players = this.world.getPlayers();
+
+        if (players.size() > 0) {
+            players.forEach(player -> this.sendDebugChunkTicketData(player, pos, toLevel));
+
+            while (this.ticketCache.size() > 0) {
+                Tuple<Long, Integer> val = this.ticketCache.poll();
+                players.forEach(player -> this.sendDebugChunkTicketData(player, val.a(), val.b()));
+            }
+        } else {
+            this.ticketCache.add(new Tuple<>(pos, toLevel));
+        }
+    }
+
+    private void sendDebugChunkTicketData(EntityHuman player, long pos, int toLevel) {
+        PacketDataSerializer data = new PacketDataSerializer(Unpooled.buffer());
+
+        data.writeLong(pos);
+        data.writeInt(toLevel);
+
+        ((EntityPlayer) player).playerConnection.sendPacket(new PacketPlayOutCustomPayload(new MinecraftKey("tic_tacs", "debug_chunk_tickets"), data));
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c81e901ae8cdeff202785ad5d9445cb3e5566d9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkLockType.java
@@ -0,0 +1,7 @@
+package net.gegy1000.tictacs.chunk;
+
+public enum ChunkLockType {
+    EARLY_GENERATION,
+    LATE_GENERATION,
+    FINALIZATION
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..293513b48018083691c9a41a6fa9bb5b4491e1d0
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMap.java
@@ -0,0 +1,244 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.WorldServer;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class ChunkMap {
+    private final WorldServer world;
+    private final ChunkController controller;
+
+    private final Long2ObjectMap<ChunkEntry> primaryEntries = new Long2ObjectOpenHashMap<>();
+    private volatile Long2ObjectMap<ChunkEntry> visibleEntries = new Long2ObjectOpenHashMap<>();
+    private Long2ObjectMap<ChunkEntry> swapEntries = new Long2ObjectOpenHashMap<>();
+
+    private Long2ObjectMap<ChunkEntry> pendingUpdates = new Long2ObjectOpenHashMap<>();
+
+    private final AtomicInteger flushCount = new AtomicInteger();
+
+    private final ChunkAccess primary = new Primary();
+    private final ChunkAccess visible = new Visible();
+
+    private final ChunkTickingMaps tickingMaps = new ChunkTickingMaps();
+
+    private final WaiterQueue flushWaiters = new WaiterQueue();
+
+    private ChunkMapListener[] listeners = new ChunkMapListener[0];
+
+    public ChunkMap(WorldServer world, ChunkController controller) {
+        this.world = world;
+        this.controller = controller;
+
+        this.addListener(this.tickingMaps);
+    }
+
+    public void addListener(ChunkMapListener listener) {
+        this.listeners = Arrays.copyOf(this.listeners, this.listeners.length + 1);
+        this.listeners[this.listeners.length - 1]  = listener;
+    }
+
+    public ChunkEntry getOrCreateEntry(long pos, int level) {
+        ChunkEntry entry = this.primary.getEntry(pos);
+        if (entry != null) {
+            return entry;
+        } else {
+            return this.loadEntry(pos, level);
+        }
+    }
+
+    public ChunkEntry loadEntry(long pos, int level) {
+        ChunkEntry entry = this.createEntry(pos, level);
+        this.primary.putEntry(entry);
+        return entry;
+    }
+
+    private ChunkEntry createEntry(long pos, int level) {
+        PlayerChunkMap tacs = this.controller.asTacs();
+        ChunkController accessor = this.controller;
+
+        ChunkEntry unloadingEntry = (ChunkEntry) me.minecraft.server.PlayerChunkMap.pendingUnload.remove(pos);
+        if (unloadingEntry != null) {
+            unloadingEntry.setLevel(level);
+            return unloadingEntry;
+        }
+
+        return new ChunkEntry(new ChunkCoordIntPair(pos), level, this.world.e(), accessor.getChunkTaskPrioritySystem(), tacs);
+    }
+
+    public FlushListener awaitFlush() {
+        return new FlushListener(this.flushCount.get());
+    }
+
+    public ChunkAccess primary() {
+        return this.primary;
+    }
+
+    public ChunkAccess visible() {
+        return this.visible;
+    }
+
+    public boolean flushToVisible() {
+        if (!this.pendingUpdates.isEmpty()) {
+            Long2ObjectMap<ChunkEntry> pendingUpdates = this.takePendingUpdates();
+
+            // prepare the new entry map before swapping
+            Long2ObjectMap<ChunkEntry> swapEntries = this.swapEntries;
+            this.applyPendingUpdatesTo(pendingUpdates, swapEntries);
+
+            // swap the entry maps
+            this.swapEntries = this.visibleEntries;
+            this.visibleEntries = swapEntries;
+
+            // now we can safely apply the pending updates to the swap map
+            this.applyPendingUpdatesTo(pendingUpdates, this.swapEntries);
+
+            this.notifyFlush();
+
+            return true;
+        }
+
+        return false;
+    }
+
+    private void applyPendingUpdatesTo(Long2ObjectMap<ChunkEntry> pending, Long2ObjectMap<ChunkEntry> entries) {
+        for (Long2ObjectMap.Entry<ChunkEntry> update : Long2ObjectMaps.fastIterable(pending)) {
+            long pos = update.getLongKey();
+            ChunkEntry entry = update.getValue();
+
+            if (entry != null) {
+                entries.put(pos, entry);
+            } else {
+                entries.remove(pos);
+            }
+        }
+    }
+
+    private Long2ObjectMap<ChunkEntry> takePendingUpdates() {
+        Long2ObjectMap<ChunkEntry> pendingUpdates = this.pendingUpdates;
+        this.pendingUpdates = new Long2ObjectOpenHashMap<>();
+        return pendingUpdates;
+    }
+
+    private void notifyFlush() {
+        this.flushCount.getAndIncrement();
+        this.flushWaiters.wake();
+    }
+
+    public int getEntryCount() {
+        return this.primaryEntries.size();
+    }
+
+    public ChunkTickingMaps getTickingMaps() {
+        return this.tickingMaps;
+    }
+
+    private void onAddChunk(ChunkEntry entry) {
+        for (ChunkMapListener listener : this.listeners) {
+            listener.onAddChunk(entry);
+        }
+    }
+
+    private void onRemoveChunk(ChunkEntry entry) {
+        for (ChunkMapListener listener : this.listeners) {
+            listener.onRemoveChunk(entry);
+        }
+    }
+
+    final class Primary implements ChunkAccess {
+        @Override
+        public void putEntry(ChunkEntry entry) {
+            long pos = entry.location.longKey;
+            ChunkMap.this.primaryEntries.put(pos, entry);
+            ChunkMap.this.pendingUpdates.put(pos, entry);
+            ChunkMap.this.onAddChunk(entry);
+        }
+
+        @Override
+        public ChunkEntry removeEntry(long pos) {
+            ChunkEntry entry = ChunkMap.this.primaryEntries.remove(pos);
+            if (entry != null) {
+                ChunkMap.this.onRemoveChunk(entry);
+                ChunkMap.this.pendingUpdates.put(pos, null);
+            }
+            return entry;
+        }
+
+        @Nullable
+        @Override
+        public ChunkEntry getEntry(long pos) {
+            return ChunkMap.this.primaryEntries.get(pos);
+        }
+
+        @Override
+        public ObjectCollection<ChunkEntry> getEntries() {
+            return ChunkMap.this.primaryEntries.values();
+        }
+    }
+
+    final class Visible implements ChunkAccess {
+        @Override
+        public void putEntry(ChunkEntry entry) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public ChunkEntry removeEntry(long pos) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Nullable
+        @Override
+        public ChunkEntry getEntry(long pos) {
+            return ChunkMap.this.visibleEntries.get(pos);
+        }
+
+        @Override
+        public ObjectCollection<ChunkEntry> getEntries() {
+            return new ObjectArrayList<>(ChunkMap.this.visibleEntries.values());
+        }
+    }
+
+    public class FlushListener extends LinkedWaiter implements Future<Unit> {
+        private final int flushCount;
+
+        FlushListener(int flushCount) {
+            this.flushCount = flushCount;
+        }
+
+        @Nullable
+        @Override
+        public Unit poll(Waker waker) {
+            if (this.isReady()) {
+                return Unit.INSTANCE;
+            }
+
+            ChunkMap.this.flushWaiters.registerWaiter(this, waker);
+
+            if (this.isReady()) {
+                this.invalidateWaker();
+                return Unit.INSTANCE;
+            }
+
+            return null;
+        }
+
+        private boolean isReady() {
+            return ChunkMap.this.flushCount.get() > this.flushCount;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e34877fb446abcc4d383cdf11d9e954d57c473f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkMapListener.java
@@ -0,0 +1,11 @@
+package net.gegy1000.tictacs.chunk;
+
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+public interface ChunkMapListener {
+    default void onAddChunk(ChunkEntry entry) {
+    }
+
+    default void onRemoveChunk(ChunkEntry entry) {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java
new file mode 100644
index 0000000000000000000000000000000000000000..88dcedcaecd32519916aca272cc7397da2ac619c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkNotLoadedException.java
@@ -0,0 +1,8 @@
+package net.gegy1000.tictacs.chunk;
+
+public final class ChunkNotLoadedException extends RuntimeException {
+    public static final ChunkNotLoadedException INSTANCE = new ChunkNotLoadedException();
+
+    private ChunkNotLoadedException() {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java b/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java
new file mode 100644
index 0000000000000000000000000000000000000000..82b5cfe54e4053873317f83735659cb0fe76a7cb
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ChunkTickingMaps.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceSet;
+
+import java.util.Collection;
+
+public final class ChunkTickingMaps implements ChunkMapListener {
+    private final ReferenceSet<ChunkEntry> trackableEntries = new ReferenceOpenHashSet<>();
+    private final ReferenceSet<ChunkEntry> tickableEntries = new ReferenceOpenHashSet<>();
+
+    public void addTrackableChunk(ChunkEntry entry) {
+        this.trackableEntries.add(entry);
+    }
+
+    public void removeTrackableChunk(ChunkEntry entry) {
+        this.trackableEntries.remove(entry);
+    }
+
+    public void addTickableChunk(ChunkEntry entry) {
+        this.tickableEntries.add(entry);
+    }
+
+    public void removeTickableChunk(ChunkEntry entry) {
+        this.tickableEntries.remove(entry);
+    }
+
+    public Collection<ChunkEntry> getTrackableEntries() {
+        return this.trackableEntries;
+    }
+
+    public Collection<ChunkEntry> getTickableEntries() {
+        return this.tickableEntries;
+    }
+
+    @Override
+    public void onRemoveChunk(ChunkEntry entry) {
+        this.tickableEntries.remove(entry);
+        this.trackableEntries.remove(entry);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java b/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ce52105597ba29d4404d8e89eabfebd36b6c1a1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/LossyChunkCache.java
@@ -0,0 +1,68 @@
+package net.gegy1000.tictacs.chunk;
+
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import it.unimi.dsi.fastutil.HashCommon;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.MathHelper;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+
+public final class LossyChunkCache {
+    private static final int COORD_BITS = 30;
+    private static final int COORD_MASK = (1 << COORD_BITS) - 1;
+    private static final int STEP_BITS = 4;
+    private static final int STEP_MASK = (1 << STEP_BITS) - 1;
+
+    private final int mask;
+
+    private final long[] keys;
+    private final IChunkAccess[] values;
+
+    public LossyChunkCache(int capacity) {
+        capacity = MathHelper.c(capacity);
+        this.mask = capacity - 1;
+
+        this.keys = new long[capacity];
+        this.values = new IChunkAccess[capacity];
+    }
+
+    public void clear() {
+        Arrays.fill(this.keys, Long.MIN_VALUE);
+        Arrays.fill(this.values, null);
+    }
+
+    public void put(int x, int z, ChunkStep step, IChunkAccess chunk) {
+        if (chunk == null) {
+            return;
+        }
+
+        long key = key(x, z, step);
+        int index = this.index(key);
+
+        this.keys[index] = key;
+        this.values[index] = chunk;
+    }
+
+    @Nullable
+    public IChunkAccess get(int x, int z, ChunkStep step) {
+        long key = key(x, z, step);
+        int index = this.index(key);
+
+        if (this.keys[index] == key) {
+            return this.values[index];
+        }
+
+        return null;
+    }
+
+    private static long key(int x, int z, ChunkStep step) {
+        return (long) (x & COORD_MASK) << 34
+                | (long) (z & COORD_MASK) << 4
+                | (step.getIndex() & STEP_MASK);
+    }
+
+    private int index(long key) {
+        return (int) HashCommon.mix(key) & this.mask;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..11bcc030aecd6f244ee1c98993da5121fc614c79
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkAccessLock.java
@@ -0,0 +1,50 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+
+import me.titaniumtown.TitaniumConfig;
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.async.lock.Mutex;
+import net.gegy1000.tictacs.async.lock.NullLock;
+import net.gegy1000.tictacs.async.lock.RwLock;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+public final class ChunkAccessLock {
+    private static final ChunkLockType[] RESOURCES = ChunkLockType.values();
+
+    private final Lock[] readLocks;
+    private final Lock[] writeLocks;
+
+    private final Lock upgradeLock;
+
+    public ChunkAccessLock() {
+        this.readLocks = new Lock[RESOURCES.length];
+        this.writeLocks = new Lock[RESOURCES.length];
+
+        if (TitaniumConfig.ticTacThreadCount == 1) {
+            for (int i = 0; i < RESOURCES.length; i++) {
+                this.readLocks[i] = NullLock.INSTANCE;
+                this.writeLocks[i] = NullLock.INSTANCE;
+            }
+        } else {
+            for (int i = 0; i < RESOURCES.length; i++) {
+                RwLock resourceLock = new RwLock();
+
+                this.readLocks[i] = resourceLock.read();
+                this.writeLocks[i] = resourceLock.write();
+            }
+        }
+
+        this.upgradeLock = new Mutex();
+    }
+
+    public Lock upgrade() {
+        return this.upgradeLock;
+    }
+
+    public Lock read(ChunkLockType resource) {
+        return this.readLocks[resource.ordinal()];
+    }
+
+    public Lock write(ChunkLockType resource) {
+        return this.writeLocks[resource.ordinal()];
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c2c39f4d850a62caa150f564be163a1c2fc5965
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntry.java
@@ -0,0 +1,437 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.LightEngine;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PlayerChunk;
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.ProtoChunkExtension;
+import net.minecraft.server.WorldServer;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.LongPredicate;
+import java.util.stream.Stream;
+
+public final class ChunkEntry extends PlayerChunk {
+    private final AtomicReferenceArray<ChunkListener> listeners = new AtomicReferenceArray<>(ChunkStep.STEPS.size());
+
+    private volatile ProtoChunk chunk;
+    private volatile Chunk worldChunk;
+
+    private volatile ChunkStep currentStep;
+    private final AtomicReference<ChunkStep> spawnedStep = new AtomicReference<>();
+    private final AtomicBoolean loading = new AtomicBoolean();
+
+    private final ChunkEntryTrackers trackers = new ChunkEntryTrackers();
+    private final ChunkAccessLock lock = new ChunkAccessLock();
+
+    public ChunkEntry(
+            ChunkCoordIntPair location, int level,
+            LightEngine lighting,
+            c levelUpdateListener,
+            d watchers
+    ) {
+        super(location, level, lighting, levelUpdateListener, watchers);
+    }
+
+    public ChunkAccessLock getLock() {
+        return this.lock;
+    }
+
+    public ChunkListener getListenerFor(ChunkStep step) {
+        while (true) {
+            ChunkListener listener = this.listeners.get(step.getIndex());
+            if (listener != null) {
+                return listener;
+            }
+
+            ChunkListener newListener = new ChunkListener(this, step);
+            if (this.listeners.compareAndSet(step.getIndex(), null, newListener)) {
+                for (ChunkStatus status : step.getStatuses()) {
+                    this.statusFutures.set(status.getStatusIndex(), newListener.asVanilla());
+                }
+
+                return newListener;
+            }
+        }
+    }
+
+    @Nullable
+    public ChunkListener getValidListenerFor(ChunkStep step) {
+        return this.isValidAs(step) ? this.getListenerFor(step) : null;
+    }
+
+    @Nullable
+    public ChunkStep getCurrentStep() {
+        return this.currentStep;
+    }
+
+    public boolean canUpgradeTo(ChunkStep toStep) {
+        return this.isValidAs(toStep) && !this.isAt(toStep);
+    }
+
+    public boolean isValidAs(ChunkStep toStep) {
+        int requiredLevel = ChunkLevelTracker.FULL_LEVEL + ChunkStep.getDistanceFromFull(toStep);
+        return this.getTicketLevel() <= requiredLevel;
+    }
+
+    public ChunkStep getTargetStep() {
+        return getTargetStep(this.getTicketLevel());
+    }
+
+    public static ChunkStep getTargetStep(int level) {
+        int distanceFromFull = level - ChunkLevelTracker.FULL_LEVEL;
+        return ChunkStep.byDistanceFromFull(distanceFromFull);
+    }
+
+    public boolean trySpawnUpgradeTo(ChunkStep toStep) {
+        if (!this.isValidAs(toStep)) {
+            return false;
+        }
+
+        while (true) {
+            ChunkStep fromStep = this.spawnedStep.get();
+            if (fromStep != null && fromStep.greaterOrEqual(toStep)) {
+                return false;
+            }
+
+            if (this.spawnedStep.compareAndSet(fromStep, toStep)) {
+                this.combineSavingFuture(toStep);
+                return true;
+            }
+        }
+    }
+
+    public boolean trySpawnLoad() {
+        return this.loading.compareAndSet(false, true);
+    }
+
+    public boolean isTicking() {
+        Either<Chunk, Failure> ticking = this.getTickingFuture().getNow(null);
+        if (ticking == null) {
+            return false;
+        }
+
+        return !ticking.right().isPresent();
+    }
+
+    public boolean isTickingEntities() {
+        Either<Chunk, Failure> entityTicking = this.getEntityTickingFuture().getNow(null);
+        if (entityTicking == null) {
+            return false;
+        }
+
+        return !entityTicking.right().isPresent();
+    }
+
+    public void onUpdateLevel(PlayerChunkMap tacs) {
+        if (this.getTicketLevel() > this.oldTicketLevel) {
+            this.reduceLevel(this.oldTicketLevel, this.getTicketLevel());
+
+            State level = getChunkState(this.getTicketLevel());
+            State lastLevel = getChunkState(this.oldTicketLevel);
+
+            // TODO: better unify logic that adds & removes from the trackable chunk list
+            if (!level.isAtLeast(State.TICKING) && lastLevel.isAtLeast(State.TICKING)) {
+                ChunkMap map = ((ChunkController) tacs).getMap();
+                map.getTickingMaps().removeTrackableChunk(this);
+            }
+        }
+
+        super.a(tacs);
+    }
+
+    private void reduceLevel(int lastLevel, int level) {
+        boolean wasLoaded = ChunkLevelTracker.isLoaded(lastLevel);
+        if (!wasLoaded) {
+            return;
+        }
+
+        boolean isLoaded = ChunkLevelTracker.isLoaded(level);
+
+        ChunkStep lastStep = getTargetStep(lastLevel);
+        ChunkStep targetStep = getTargetStep(level);
+
+        int startIdx = isLoaded ? targetStep.getIndex() + 1 : 0;
+        int endIdx = lastStep.getIndex();
+
+        if (startIdx > endIdx) {
+            return;
+        }
+
+        for (int i = startIdx; i <= endIdx; i++) {
+            ChunkListener listener = this.listeners.getAndSet(i, null);
+            if (listener != null) {
+                listener.completeErr();
+            }
+        }
+
+        this.downgradeSpawnedStep(targetStep);
+    }
+
+    private void downgradeSpawnedStep(ChunkStep targetStep) {
+        while (true) {
+            ChunkStep spawnedStep = this.spawnedStep.get();
+            if (targetStep != null && !targetStep.lessThan(spawnedStep)) {
+                break;
+            }
+
+            if (this.spawnedStep.compareAndSet(spawnedStep, targetStep)) {
+                break;
+            }
+        }
+    }
+
+    @Nullable
+    public ProtoChunk getProtoChunk() {
+        return this.chunk;
+    }
+
+    @Nullable
+    @Override
+    public Chunk getChunk() {
+        return this.worldChunk;
+    }
+
+    @Nullable
+    public IChunkAccess getIChunk() {
+        Chunk worldChunk = this.worldChunk;
+        if (worldChunk != null) {
+            return worldChunk;
+        }
+        return this.chunk;
+    }
+
+    @Nullable
+    public IChunkAccess getChunkAtLeast(ChunkStep step) {
+        if (this.isAt(step)) {
+            return this.getChunk();
+        } else {
+            return null;
+        }
+    }
+
+    @Nullable
+    public IChunkAccess getChunkForStep(ChunkStep step) {
+        if (!this.isAt(step)) {
+            return null;
+        }
+
+        if (step == ChunkStep.FULL) {
+            return this.worldChunk;
+        } else {
+            return this.chunk;
+        }
+    }
+
+    public boolean isAt(ChunkStep step) {
+        return step.lessOrEqual(this.currentStep);
+    }
+
+    public void completeUpgradeOk(ChunkStep step, IChunkAccess chunk) {
+        ChunkStep lastStep = this.includeStep(step);
+
+        if (chunk instanceof ProtoChunk) {
+            this.chunk = (ProtoChunk) chunk;
+        }
+
+        int startIdx = lastStep != null ? lastStep.getIndex() : 0;
+        int endIdx = step.getIndex();
+
+        for (int idx = startIdx; idx <= endIdx; idx++) {
+            ChunkListener listener = this.listeners.get(idx);
+            if (listener != null) {
+                listener.completeOk();
+            }
+        }
+    }
+
+    public void notifyUpgradeUnloaded(ChunkStep step) {
+        for (int i = step.getIndex(); i < this.listeners.length(); i++) {
+            ChunkListener listener = this.listeners.getAndSet(i, null);
+            if (listener != null) {
+                listener.completeErr();
+            }
+        }
+
+        this.notifyUpgradeCanceled(step);
+    }
+
+    public void notifyUpgradeCanceled(ChunkStep step) {
+        this.downgradeSpawnedStep(step.getPrevious());
+    }
+
+    @Nullable
+    ChunkStep includeStep(ChunkStep step) {
+        ChunkStep currentStep = this.currentStep;
+        if (step.greaterOrEqual(currentStep)) {
+            this.currentStep = step;
+        }
+        return currentStep;
+    }
+
+    void combineSavingFuture(ChunkStep step) {
+        this.a(this.getListenerFor(step).asVanilla());
+    }
+
+    void combineSavingFuture(Chunk chunk) {
+        this.a(CompletableFuture.completedFuture(Either.left(chunk)));
+    }
+
+    public Chunk finalizeChunk(WorldServer world, LongPredicate loadToWorld) {
+        if (this.worldChunk != null) {
+            throw new IllegalStateException("chunk already finalized!");
+        }
+
+        Chunk worldChunk = unwrapWorldChunk(this.chunk);
+        if (worldChunk == null) {
+            worldChunk = this.upgradeToWorldChunk(world, this.chunk);
+        }
+
+        this.worldChunk = worldChunk;
+        this.combineSavingFuture(this.worldChunk);
+
+        worldChunk.a(() -> getChunkState(this.getTicketLevel()));
+        worldChunk.addEntities();
+
+        if (loadToWorld.test(this.location.longKey)) {
+            worldChunk.setLoaded(true);
+            world.a(worldChunk.getTileEntities().values());
+
+            Collection<Entity> invalidEntities = this.tryAddEntitiesToWorld(world, worldChunk);
+            invalidEntities.forEach(worldChunk::removeEntity);
+        }
+
+        worldChunk.B();
+
+        return worldChunk;
+    }
+
+    private Chunk upgradeToWorldChunk(WorldServer world, ProtoChunk protoChunk) {
+        Chunk worldChunk = new Chunk(world, protoChunk);
+        this.chunk = new ProtoChunkExtension(worldChunk);
+
+        return worldChunk;
+    }
+
+    private Collection<Entity> tryAddEntitiesToWorld(WorldServer world, Chunk chunk) {
+        Collection<Entity> invalidEntities = new ArrayList<>();
+
+        for (List<Entity> entitySection : chunk.getEntitySlices()) {
+            for (Entity entity : entitySection) {
+                if (entity instanceof EntityHuman) continue;
+
+                if (!world.addEntity(entity)) {
+                    invalidEntities.add(entity);
+                }
+            }
+        }
+
+        return invalidEntities;
+    }
+
+    @Nullable
+    private static Chunk unwrapWorldChunk(IChunkAccess chunk) {
+        if (chunk instanceof ProtoChunkExtension) {
+            return ((ProtoChunkExtension) chunk).getWrappedChunk();
+        }
+        return null;
+    }
+
+    public ChunkEntryTrackers getTrackers() {
+        return this.trackers;
+    }
+
+    @Override
+    public void a(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        Set<EntityPlayer> trackingPlayers = this.trackers.getTrackingPlayers();
+        if (trackingPlayers.isEmpty()) {
+            return;
+        }
+
+        if (!onlyOnWatchDistanceEdge) {
+            for (EntityPlayer player : trackingPlayers) {
+                QueuingConnection.enqueueSend(player.playerConnection, packet);
+            }
+        } else {
+            // pass through TACS to filter the edge
+            Stream<EntityPlayer> players = this.players.a(this.location, true);
+            players.forEach(player -> QueuingConnection.enqueueSend(player.playerConnection, packet));
+        }
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<IChunkAccess, Failure>> a(ChunkStatus status, PlayerChunkMap tacs) {
+        return tacs.a(this, status);
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<IChunkAccess, Failure>> getStatusFutureUnchecked(ChunkStatus status) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        return this.getListenerFor(step).asVanilla();
+    }
+
+    @Override
+    @Deprecated
+    public CompletableFuture<Either<IChunkAccess, Failure>> b(ChunkStatus status) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        return this.isValidAs(step) ? this.getStatusFutureUnchecked(status) : PlayerChunk.UNLOADED_CHUNK_ACCESS_FUTURE;
+    }
+
+    @Override
+    @Deprecated
+    public void a(PlayerChunkMap tacs) {
+        this.onUpdateLevel(tacs);
+    }
+
+    @Override
+    @Nullable
+    @Deprecated
+    public IChunkAccess f() {
+        return this.getProtoChunk();
+    }
+
+    @Override
+    @Deprecated
+    public void a(ProtoChunkExtension chunk) {
+    }
+
+    // TODO: Ideally we can avoid running this logic here, and instead have it be run when we're trying to start/stop chunk tracking
+    public boolean isChunkTickable() {
+        Set<EntityPlayer> players = this.trackers.getTickableTrackingPlayers();
+        if (players.isEmpty()) {
+            return false;
+        }
+
+        for (EntityPlayer player : players) {
+            if (!player.isSpectator()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4431b8e024c01ce0eb954b6a584fe2304a492a0
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkEntryTrackers.java
@@ -0,0 +1,139 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import net.gegy1000.tictacs.chunk.tracker.ChunkEntityTracker;
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.server.EntityPlayer;
+
+import java.util.Collections;
+import java.util.Set;
+
+public final class ChunkEntryTrackers {
+    private Set<EntityPlayer> trackingPlayers;
+    private Set<EntityPlayer> tickableTrackingPlayers;
+    private Set<ChunkEntityTracker> entities;
+
+    public void addEntity(ChunkEntityTracker tracker) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities == null) {
+            this.entities = entities = new ReferenceOpenHashSet<>();
+        }
+        entities.add(tracker);
+    }
+
+    public boolean removeEntity(ChunkEntityTracker tracker) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null && entities.remove(tracker)) {
+            if (entities.isEmpty()) {
+                this.entities = null;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public boolean addTrackingPlayer(EntityPlayer player) {
+        Set<EntityPlayer> trackingPlayers = this.trackingPlayers;
+        if (trackingPlayers == null) {
+            this.trackingPlayers = trackingPlayers = new ReferenceOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        if (trackingPlayers.add(player)) {
+            this.startTrackingEntities(player);
+            return true;
+        }
+
+        return false;
+    }
+
+    public boolean removeTrackingPlayer(EntityPlayer player) {
+        Set<EntityPlayer> trackingPlayers = this.trackingPlayers;
+        if (trackingPlayers == null) {
+            return false;
+        }
+
+        if (trackingPlayers.remove(player)) {
+            if (trackingPlayers.isEmpty()) {
+                this.trackingPlayers = null;
+            }
+
+            this.stopTrackingEntities(player);
+            return true;
+        }
+
+        return false;
+    }
+
+    public void updateTrackingPlayer(EntityPlayer player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            Set<EntityPlayer> trackingPlayers = this.trackingPlayers;
+            if (trackingPlayers == null || !trackingPlayers.contains(player)) {
+                return;
+            }
+
+            for (ChunkEntityTracker entity : entities) {
+                entity.updateTracker(player);
+            }
+        }
+    }
+
+    private void startTrackingEntities(EntityPlayer player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            for (ChunkEntityTracker tracker : entities) {
+                tracker.updateTrackerWatched(player);
+            }
+        }
+    }
+
+    private void stopTrackingEntities(EntityPlayer player) {
+        Set<ChunkEntityTracker> entities = this.entities;
+        if (entities != null) {
+            for (ChunkEntityTracker tracker : entities) {
+                tracker.updateTrackerUnwatched(player);
+            }
+        }
+    }
+
+    public boolean addTickableTrackingPlayer(EntityPlayer player) {
+        Set<EntityPlayer> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        if (tickableTrackingPlayers == null) {
+            this.tickableTrackingPlayers = tickableTrackingPlayers = new ReferenceOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        return tickableTrackingPlayers.add(player);
+    }
+
+    public boolean removeTickableTrackingPlayer(EntityPlayer player) {
+        Set<EntityPlayer> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        if (tickableTrackingPlayers != null && tickableTrackingPlayers.remove(player)) {
+            if (tickableTrackingPlayers.isEmpty()) {
+                this.tickableTrackingPlayers = null;
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    public Set<EntityPlayer> getTrackingPlayers() {
+        Set<EntityPlayer> trackingPlayers = this.trackingPlayers;
+        return trackingPlayers != null ? trackingPlayers : Collections.emptySet();
+    }
+
+    public Set<EntityPlayer> getTickableTrackingPlayers() {
+        Set<EntityPlayer> tickableTrackingPlayers = this.tickableTrackingPlayers;
+        return tickableTrackingPlayers != null ? tickableTrackingPlayers : Collections.emptySet();
+    }
+
+    public boolean isTrackedBy(EntityPlayer player) {
+        Set<EntityPlayer> trackingPlayers = this.trackingPlayers;
+        return trackingPlayers != null && trackingPlayers.contains(player);
+    }
+
+    public Set<ChunkEntityTracker> getEntities() {
+        Set<ChunkEntityTracker> entities = this.entities;
+        return entities != null ? entities : Collections.emptySet();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3d895702a029e74712d5151925b3ace61289271
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/entry/ChunkListener.java
@@ -0,0 +1,70 @@
+package net.gegy1000.tictacs.chunk.entry;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.chunk.future.SharedListener;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.PlayerChunk;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletableFuture;
+
+public final class ChunkListener extends SharedListener<IChunkAccess> {
+    final ChunkEntry entry;
+    final ChunkStep step;
+
+    volatile boolean err;
+
+    final CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> vanilla;
+
+    ChunkListener(ChunkEntry entry, ChunkStep step) {
+        this.entry = entry;
+        this.step = step;
+
+        IChunkAccess chunk = this.getChunkForStep();
+        if (chunk != null) {
+            this.vanilla = CompletableFuture.completedFuture(Either.left(chunk));
+        } else {
+            this.vanilla = new CompletableFuture<>();
+        }
+    }
+
+    @Nullable
+    @Override
+    protected IChunkAccess get() {
+        if (this.err) {
+            throw ChunkNotLoadedException.INSTANCE;
+        }
+
+        return this.getChunkForStep();
+    }
+
+    public void completeOk() {
+        this.err = false;
+
+        IChunkAccess chunk = this.getChunkForStep();
+        if (chunk == null) {
+            throw new IllegalStateException("cannot complete chunk with null chunk");
+        }
+
+        this.vanilla.complete(Either.left(chunk));
+
+        this.wake();
+    }
+
+    public void completeErr() {
+        this.err = true;
+        this.vanilla.complete(PlayerChunk.UNLOADED_CHUNK_ACCESS);
+
+        this.wake();
+    }
+
+    private IChunkAccess getChunkForStep() {
+        return this.entry.getChunkForStep(this.step);
+    }
+
+    public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> asVanilla() {
+        return this.vanilla;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java b/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java
new file mode 100644
index 0000000000000000000000000000000000000000..978557546e350e6007b75a185b0b9be2c6c96714
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/AwaitAll.java
@@ -0,0 +1,43 @@
+package net.gegy1000.tictacs.chunk.future;
+
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+
+import javax.annotation.Nullable;
+public final class AwaitAll<T> implements Future<Unit> {
+    private final Future<T>[] futures;
+
+    private AwaitAll(Future<T>[] futures) {
+        this.futures = futures;
+    }
+
+    public static <T> AwaitAll<T> of(Future<T>[] futures) {
+        return new AwaitAll<>(futures);
+    }
+
+    @Nullable
+    @Override
+    public Unit poll(Waker waker) {
+        return AwaitAll.poll(waker, this.futures) ? Unit.INSTANCE : null;
+    }
+
+    public static <T> boolean poll(Waker waker, Future<T>[] futures) {
+        boolean ready = true;
+
+        for (int i = 0; i < futures.length; i++) {
+            Future<T> future = futures[i];
+            if (future == null) continue;
+
+            T result = future.poll(waker);
+            if (result != null) {
+                futures[i] = null;
+            } else {
+                ready = false;
+            }
+        }
+
+        return ready;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bee224e340d099ef945e603ebd6e9170054b93a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/ChunkNotLoadedFuture.java
@@ -0,0 +1,26 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import javax.annotation.Nullable;
+
+
+public final class ChunkNotLoadedFuture<T> implements Future<T> {
+    private static final ChunkNotLoadedFuture<?> INSTANCE = new ChunkNotLoadedFuture<>();
+
+    private ChunkNotLoadedFuture() {
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> ChunkNotLoadedFuture<T> get() {
+        return (ChunkNotLoadedFuture<T>) INSTANCE;
+    }
+
+    @Nullable
+    @Override
+    public T poll(Waker waker) {
+        throw ChunkNotLoadedException.INSTANCE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java b/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9c47be49590939161f1249866a55584a389e3e2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/FutureHandle.java
@@ -0,0 +1,27 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import javax.annotation.Nullable;
+
+public final class FutureHandle<T> implements Future<T> {
+    private volatile T value;
+    private volatile Waker waker;
+
+    @Nullable
+    @Override
+    public T poll(Waker waker) {
+        this.waker = waker;
+        return this.value;
+    }
+
+    public void complete(T value) {
+        this.value = value;
+
+        Waker waker = this.waker;
+        if (waker != null) {
+            waker.wake();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java b/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6f518fdf365c891adf27acb3effcaeafe10720f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/JoinAllArray.java
@@ -0,0 +1,41 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import javax.annotation.Nullable;
+
+public final class JoinAllArray<T> implements Future<T[]> {
+    private final Future<T>[] futures;
+    private final T[] results;
+
+    public JoinAllArray(Future<T>[] futures, T[] results) {
+        this.futures = futures;
+        this.results = results;
+    }
+
+    @Nullable
+    @Override
+    public T[] poll(Waker waker) {
+        return JoinAllArray.poll(waker, this.futures, this.results);
+    }
+
+    public static <T> T[] poll(Waker waker, Future<T>[] futures, T[] results) {
+        boolean pending = false;
+
+        for (int i = 0; i < futures.length; i++) {
+            Future<T> future = futures[i];
+            if (future == null) continue;
+
+            T result = future.poll(waker);
+            if (result != null) {
+                futures[i] = null;
+                results[i] = result;
+            } else {
+                pending = true;
+            }
+        }
+
+        return pending ? null : results;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..c81ea93c2c226630dc80a1abb55634287babcef1
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/LazyRunnableFuture.java
@@ -0,0 +1,19 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+
+public final class LazyRunnableFuture implements Future<Unit> {
+    private final Runnable runnable;
+
+    public LazyRunnableFuture(Runnable runnable) {
+        this.runnable = runnable;
+    }
+
+    @Override
+    public Unit poll(Waker waker) {
+        this.runnable.run();
+        return Unit.INSTANCE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java b/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd8e013fe376ca241aefc2d7016cac58be9f490e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/Result.java
@@ -0,0 +1,37 @@
+package net.gegy1000.tictacs.chunk.future;
+
+public final class Result<T> {
+    private static final Object ERROR_VALUE = new Object();
+    private static final Result<?> ERROR = new Result<>(ERROR_VALUE);
+
+    private final Object value;
+
+    private Result(Object value) {
+        this.value = value;
+    }
+
+    public static <T> Result<T> ok(T result) {
+        return new Result<>(result);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> Result<T> error() {
+        return (Result<T>) ERROR;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T get() {
+        if (this.value == ERROR_VALUE) {
+            throw new RuntimeException("result is error");
+        }
+        return (T) this.value;
+    }
+
+    public boolean isOk() {
+        return this.value != ERROR_VALUE;
+    }
+
+    public boolean isError() {
+        return this.value == ERROR_VALUE;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java b/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c0f74f6c6f9fdb4f163d3337023ede9fdc14e1d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/SharedListener.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import net.gegy1000.tictacs.async.LinkedWaiter;
+import net.gegy1000.tictacs.async.WaiterQueue;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import javax.annotation.Nullable;
+
+
+public abstract class SharedListener<T> implements Future<T> {
+    private final WaiterQueue waiters = new WaiterQueue();
+
+    @Nullable
+    protected abstract T get();
+
+    protected final void wake() {
+        this.waiters.wake();
+    }
+
+    @Nullable
+    @Override
+    public final T poll(Waker waker) {
+        T value = this.get();
+        if (value != null) {
+            return value;
+        }
+
+        LinkedWaiter waiter = new LinkedWaiter();
+        this.waiters.registerWaiter(waiter, waker);
+
+        // try get the value again in case one was set before we registered our waker
+        value = this.get();
+        if (value != null) {
+            // if a value was set while we were registering, we can invalidate that waker now
+            waiter.invalidateWaker();
+            return value;
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fb549b20d2e13d662ce0e7cae273ffee6a8404f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/future/VanillaChunkFuture.java
@@ -0,0 +1,64 @@
+package net.gegy1000.tictacs.chunk.future;
+
+import com.mojang.datafixers.util.Either;
+import net.gegy1000.tictacs.AtomicPool;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.PlayerChunk;
+
+import javax.annotation.Nullable;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+public final class VanillaChunkFuture implements Future<IChunkAccess> {
+    private static final AtomicPool<VanillaChunkFuture> POOL = new AtomicPool<>(512, VanillaChunkFuture::new);
+
+    private volatile CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> inner;
+    private volatile boolean listening;
+
+    private VanillaChunkFuture() {
+    }
+
+    public static VanillaChunkFuture of(CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completable) {
+        VanillaChunkFuture future = POOL.acquire();
+        future.init(completable);
+        return future;
+    }
+
+    void init(CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future) {
+        this.inner = future;
+        this.listening = false;
+    }
+
+    @Nullable
+    @Override
+    public IChunkAccess poll(Waker waker) {
+        Either<IChunkAccess, PlayerChunk.Failure> result = this.inner.getNow(null);
+        if (result != null) {
+            Optional<PlayerChunk.Failure> err = result.right();
+            if (err.isPresent()) {
+                throw ChunkNotLoadedException.INSTANCE;
+            }
+
+            IChunkAccess chunk = result.left().get();
+            this.release();
+
+            return chunk;
+        } else if (!this.listening) {
+            this.listening = true;
+            this.inner.handle((r, t) -> {
+                waker.wake();
+                return null;
+            });
+        }
+
+        return null;
+    }
+
+    private void release() {
+        this.inner = null;
+        POOL.release(this);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ececb782e1db672e7bfc9d9c4e1b83ad1c0ad70
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkData.java
@@ -0,0 +1,470 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import com.google.common.base.Preconditions;
+import net.gegy1000.tictacs.PoiStorageAccess;
+import net.gegy1000.tictacs.util.NbtType;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import net.minecraft.server.BiomeBase;
+import net.minecraft.server.BiomeStorage;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkConverter;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkGenerator;
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.DefinedStructureManager;
+import net.minecraft.server.EntityTypes;
+import net.minecraft.server.FluidType;
+import net.minecraft.server.FluidTypes;
+import net.minecraft.server.HeightMap;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.IRegistry;
+import net.minecraft.server.IRegistryCustom;
+import net.minecraft.server.IRegistryWritable;
+import net.minecraft.server.LightEngine;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.NBTTagList;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.ProtoChunkExtension;
+import net.minecraft.server.ProtoChunkTickList;
+import net.minecraft.server.StructureGenerator;
+import net.minecraft.server.StructureStart;
+import net.minecraft.server.TickList;
+import net.minecraft.server.TickListChunk;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.VillagePlace;
+import net.minecraft.server.VillagePlaceType;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldChunkManager;
+import net.minecraft.server.WorldGenStage;
+import net.minecraft.server.WorldServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.function.Consumer;
+import java.util.stream.LongStream;
+
+public final class ChunkData {
+    private static final Logger LOGGER = LogManager.getLogger(ChunkData.class);
+
+    private static final int STARLIGHT_LIGHT_VERSION = 1;
+
+    private final ChunkCoordIntPair pos;
+    private final ChunkStatus status;
+    private final long inhabitedTime;
+    private final ChunkConverter upgradeData;
+
+    @Nullable
+    private final int[] biomeIds;
+
+    private final ChunkSection[] sections;
+    private final boolean[] sectionHasPois;
+
+    private final ChunkLightData lightData;
+    private final boolean lightOn;
+
+    private final Map<HeightMap.Type, long[]> heightmaps;
+
+    private final TickList<Block> blockTickScheduler;
+    private final TickList<FluidType> fluidTickScheduler;
+    private final List<BlockPosition> blocksForPostProcessing;
+
+    private final List<NBTTagCompound> entityTags;
+    private final List<NBTTagCompound> blockEntityTags;
+
+    private final Map<StructureGenerator<?>, NBTTagCompound> structureStarts;
+    private final Map<StructureGenerator<?>, LongSet> structureReferences;
+
+    private final boolean shouldSave;
+
+    @Nullable
+    private final ProtoData protoData;
+
+    private ChunkData(ChunkCoordIntPair pos, ChunkStatus status, long inhabitedTime, ChunkConverter upgradeData, @Nullable int[] biomeIds, ChunkSection[] sections, boolean[] sectionHasPois, ChunkLightData lightData, boolean lightOn, Map<HeightMap.Type, long[]> heightmaps, TickList<Block> blockTickScheduler, TickList<FluidType> fluidTickScheduler, List<BlockPosition> blocksForPostProcessing, List<NBTTagCompound> entityTags, List<NBTTagCompound> blockEntityTags, Map<StructureGenerator<?>, NBTTagCompound> structureStarts, Map<StructureGenerator<?>, LongSet> structureReferences, boolean shouldSave, @Nullable ProtoData protoData) {
+        this.pos = pos;
+        this.status = status;
+        this.inhabitedTime = inhabitedTime;
+        this.upgradeData = upgradeData;
+        this.biomeIds = biomeIds;
+        this.sections = sections;
+        this.sectionHasPois = sectionHasPois;
+        this.lightData = lightData;
+        this.lightOn = lightOn;
+        this.heightmaps = heightmaps;
+        this.blockTickScheduler = blockTickScheduler;
+        this.fluidTickScheduler = fluidTickScheduler;
+        this.blocksForPostProcessing = blocksForPostProcessing;
+        this.entityTags = entityTags;
+        this.blockEntityTags = blockEntityTags;
+        this.structureStarts = structureStarts;
+        this.structureReferences = structureReferences;
+        this.shouldSave = shouldSave;
+        this.protoData = protoData;
+    }
+
+    public static ChunkData deserialize(ChunkCoordIntPair chunkPos, NBTTagCompound tag) {
+        NBTTagCompound levelTag = tag.getCompound("Level");
+
+        ChunkStatus status = ChunkStatus.getStatus(levelTag.getString("Status"));
+
+        ChunkCoordIntPair serializedPos = new ChunkCoordIntPair(levelTag.getInt("xPos"), levelTag.getInt("zPos"));
+        if (!serializedPos.equals(chunkPos)) {
+            LOGGER.error("Chunk file at {} is in the wrong location; relocating. (Expected {}, got {})", chunkPos, chunkPos, serializedPos);
+        }
+
+        int[] biomeIds = levelTag.hasKeyOfType("Biomes", NbtType.INT_ARRAY) ? levelTag.getIntArray("Biomes") : null;
+        ChunkConverter upgradeData = levelTag.hasKeyOfType("ChunkConverter", NbtType.COMPOUND) ? new ChunkConverter(levelTag.getCompound("ChunkConverter")) : ChunkConverter.getEmptyConverter();
+
+        TickList<Block> blockScheduler = new ProtoChunkTickList<>(block -> {
+            return block == null || block.getBlockData().isAir();
+        }, chunkPos, levelTag.getList("ToBeTicked", NbtType.LIST));
+
+        TickList<FluidType> fluidScheduler = new ProtoChunkTickList<>(fluid -> {
+            return fluid == null || fluid == FluidTypes.EMPTY;
+        }, chunkPos, levelTag.getList("LiquidsToBeTicked", NbtType.LIST));
+
+        ChunkSection[] sections = new ChunkSection[16];
+        boolean[] sectionHasPois = new boolean[16];
+
+        ChunkLightData lightData;
+
+        lightData = new StarlightChunkLightData();
+        boolean lightOn = levelTag.getInt("starlight.light_versiom") == STARLIGHT_LIGHT_VERSION;
+
+        NBTTagList sectionsList = levelTag.getList("Sections", NbtType.COMPOUND);
+
+        for (int i = 0; i < sectionsList.size(); i++) {
+            NBTTagCompound sectionTag = sectionsList.getCompound(i);
+            int sectionY = sectionTag.getByte("Y");
+
+            if (sectionTag.hasKeyOfType("Palette", NbtType.LIST) && sectionTag.hasKeyOfType("BlockStates", NbtType.LONG_ARRAY)) {
+                ChunkSection section = new ChunkSection(sectionY << 4);
+
+                NBTTagList palette = sectionTag.getList("Palette", NbtType.COMPOUND);
+                long[] data = sectionTag.getLongArray("BlockStates");
+                section.getBlocks().a(palette, data);
+
+                section.recalcBlockCounts();
+
+                if (!ChunkSection.isEmpty(section)) {
+                    sections[sectionY] = section;
+                    sectionHasPois[sectionY] = section.a(VillagePlaceType.x::contains);
+                }
+            }
+
+            if (lightOn) {
+                lightData.acceptSection(sectionY, sectionTag, status);
+            }
+        }
+
+        ChunkStatus.Type chunkType = status.getType();
+
+        List<NBTTagCompound> entityTags = new ArrayList<>();
+        List<NBTTagCompound> blockEntityTags = new ArrayList<>();
+
+        NBTTagList entitiesList = levelTag.getList("Entities", NbtType.COMPOUND);
+        for (int i = 0; i < entitiesList.size(); i++) {
+            entityTags.add(entitiesList.getCompound(i));
+        }
+
+        NBTTagList blockEntitiesList = levelTag.getList("TileEntities", NbtType.COMPOUND);
+        for (int i = 0; i < blockEntitiesList.size(); i++) {
+            blockEntityTags.add(blockEntitiesList.getCompound(i));
+        }
+
+        if (chunkType == ChunkStatus.Type.LEVELCHUNK) {
+            if (levelTag.hasKeyOfType("TileTicks", NbtType.LIST)) {
+                blockScheduler = TickListChunk.a(levelTag.getList("TileTicks", NbtType.COMPOUND), IRegistry.BLOCK::getKey, IRegistry.BLOCK::get);
+            }
+
+            if (levelTag.hasKeyOfType("LiquidTicks", NbtType.LIST)) {
+                fluidScheduler = TickListChunk.a(levelTag.getList("LiquidTicks", NbtType.COMPOUND), IRegistry.FLUID::getKey, IRegistry.FLUID::get);
+            }
+        }
+
+        NBTTagCompound heightmapsTag = levelTag.getCompound("HeightMaps");
+
+        Map<HeightMap.Type, long[]> heightmaps = new EnumMap<>(HeightMap.Type.class);
+        for (HeightMap.Type type : status.heightMaps) {
+            String name = type.getName();
+            if (heightmapsTag.hasKeyOfType(name, NbtType.LONG_ARRAY)) {
+                heightmaps.put(type, heightmapsTag.getLongArray(name));
+            }
+        }
+
+        NBTTagCompound structuresTag = levelTag.getCompound("Structures");
+        Map<StructureGenerator<?>, NBTTagCompound> structureStarts = deserializeStructureStarts(structuresTag);
+        Map<StructureGenerator<?>, LongSet> structureReferences = deserializeStructureReferences(chunkPos, structuresTag);
+
+        List<BlockPosition> blocksForPostProcessing = new ArrayList<>();
+
+        NBTTagList postProcessingList = levelTag.getList("PostProcessing", NbtType.LIST);
+        for (int sectionY = 0; sectionY < postProcessingList.size(); sectionY++) {
+            NBTTagList queueList = postProcessingList.b(sectionY);
+            for (int i = 0; i < queueList.size(); i++) {
+                BlockPosition pos = ProtoChunk.a(queueList.d(sectionY), sectionY, chunkPos);
+                blocksForPostProcessing.add(pos);
+            }
+        }
+
+        ProtoData protoData = null;
+        if (chunkType == ChunkStatus.Type.PROTOCHUNK) {
+            protoData = deserializeProtoData(chunkPos, levelTag, status, sections, lightOn);
+        }
+
+        long inhabitedTime = levelTag.getLong("InhabitedTime");
+        boolean shouldSave = levelTag.getBoolean("shouldSave");
+
+        return new ChunkData(chunkPos, status, inhabitedTime, upgradeData, biomeIds, sections, sectionHasPois, lightData, lightOn, heightmaps, blockScheduler, fluidScheduler, blocksForPostProcessing, entityTags, blockEntityTags, structureStarts, structureReferences, shouldSave, protoData);
+    }
+
+    private static Map<StructureGenerator<?>, NBTTagCompound> deserializeStructureStarts(NBTTagCompound tag) {
+        Map<StructureGenerator<?>, NBTTagCompound> starts = new Object2ObjectOpenHashMap<>();
+
+        NBTTagCompound startsTag = tag.getCompound("Starts");
+
+        for (String key : startsTag.getKeys()) {
+            StructureGenerator<?> feature = StructureGenerator.a.get(key.toLowerCase(Locale.ROOT));
+            if (feature == null) {
+                LOGGER.error("Unknown structure start: {}", key);
+                continue;
+            }
+
+            starts.put(feature, startsTag.getCompound(key));
+        }
+
+        return starts;
+    }
+
+    private static Map<StructureGenerator<?>, LongSet> deserializeStructureReferences(ChunkCoordIntPair pos, NBTTagCompound tag) {
+        Map<StructureGenerator<?>, LongSet> references = new Object2ObjectOpenHashMap<>();
+        NBTTagCompound referencesTag = tag.getCompound("References");
+
+        for (String key : referencesTag.getKeys()) {
+            StructureGenerator<?> feature = StructureGenerator.a.get(key.toLowerCase(Locale.ROOT));
+
+            LongStream referenceStream = Arrays.stream(referencesTag.getLongArray(key)).filter(reference -> {
+                ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(reference);
+                if (chunkPos.a(pos) > 8) {
+                    LOGGER.warn("Found invalid structure reference [{} @ {}] for chunk {}", key, chunkPos, pos);
+                    return false;
+                }
+                return true;
+            });
+
+            references.put(feature, new LongOpenHashSet(referenceStream.toArray()));
+        }
+
+        return references;
+    }
+
+    private static ProtoData deserializeProtoData(ChunkCoordIntPair chunkPos, NBTTagCompound levelTag, ChunkStatus status, ChunkSection[] sections, boolean lightOn) {
+        List<BlockPosition> lightSources = new ArrayList<>();
+
+        NBTTagList lightSectionList = levelTag.getList("Lights", NbtType.LIST);
+        for (int sectionY = 0; sectionY < lightSectionList.size(); sectionY++) {
+            NBTTagList lightList = lightSectionList.b(sectionY);
+            for (int i = 0; i < lightList.size(); i++) {
+                lightSources.add(ProtoChunk.a(lightList.d(i), sectionY, chunkPos));
+            }
+        }
+
+        Map<WorldGenStage.Features, BitSet> carvingMasks = new EnumMap<>(WorldGenStage.Features.class);
+
+        NBTTagCompound carvingMasksTag = levelTag.getCompound("CarvingMasks");
+        for (String key : carvingMasksTag.getKeys()) {
+            WorldGenStage.Features carver = WorldGenStage.Features.valueOf(key);
+            carvingMasks.put(carver, BitSet.valueOf(carvingMasksTag.getByteArray(key)));
+        }
+
+        if (!lightOn && status.b(ChunkStatus.LIGHT)) {
+            for (BlockPosition pos : BlockPosition.b(0, 0, 0, 15, 255, 15)) {
+                ChunkSection section = sections[pos.getY() >> 4];
+                if (section == null) {
+                    continue;
+                }
+
+                IBlockData state = section.getType(pos.getX(), pos.getY() & 15, pos.getZ());
+                if (state.getEmittedLight() != 0) {
+                    lightSources.add(new BlockPosition(chunkPos.d() + pos.getX(), pos.getY(), chunkPos.e() + pos.getZ()));
+                }
+            }
+        }
+
+        return new ProtoData(lightSources, carvingMasks);
+    }
+
+    public IChunkAccess createChunk(WorldServer world, DefinedStructureManager structures, VillagePlace poi) {
+        IRegistryCustom registryManager = world.r();
+        ChunkProviderServer chunkManager = world.getChunkProvider();
+        ChunkGenerator chunkGenerator = chunkManager.getChunkGenerator();
+        LightEngine lightingProvider = chunkManager.getLightEngine();
+        WorldChunkManager biomeSource = chunkGenerator.getWorldChunkManager();
+
+        BiomeStorage biomes = null;
+        if (this.biomeIds != null || this.status.isAtLeastStatus(ChunkStatus.BIOMES)) {
+            IRegistryWritable<BiomeBase> biomeRegistry = registryManager.b(IRegistry.ay);
+            biomes = new BiomeStorage(biomeRegistry, this.pos, biomeSource, this.biomeIds);
+        }
+
+        this.lightData.applyToWorld(this.pos, world);
+
+        ChunkStatus.Type chunkType = this.status.getType();
+
+        IChunkAccess chunk;
+        ProtoChunk protoChunk;
+
+        if (chunkType == ChunkStatus.Type.LEVELCHUNK) {
+            Chunk worldChunk = this.createWorldChunk(world, biomes);
+            chunk = worldChunk;
+            protoChunk = new ProtoChunkExtension(worldChunk);
+        } else {
+            protoChunk = this.createProtoChunk(lightingProvider, biomes, world);
+            chunk = protoChunk;
+        }
+
+        for (int sectionY = 0; sectionY < this.sectionHasPois.length; sectionY++) {
+            if (this.sectionHasPois[sectionY]) {
+                ((PoiStorageAccess) poi).initSectionWithPois(this.pos, this.sections[sectionY]);
+            }
+        }
+
+        this.populateStructures(chunk, structures, world.getSeed());
+        this.populateHeightMaps(chunk);
+
+        if (this.shouldSave) {
+            chunk.setNeedsSaving(true);
+        }
+
+        for (BlockPosition pos : this.blocksForPostProcessing) {
+            chunk.a(ProtoChunk.l(pos), pos.getY() >> 4);
+        }
+
+        protoChunk.b(this.lightOn);
+
+        this.lightData.applyToChunk(protoChunk);
+
+        return protoChunk;
+    }
+
+    private void populateHeightMaps(IChunkAccess chunk) {
+        if (!this.status.isAtLeastStatus(ChunkStatus.NOISE)) {
+            return;
+        }
+
+        EnumSet<HeightMap.Type> missingHeightMaps = EnumSet.noneOf(HeightMap.Type.class);
+        for (HeightMap.Type type : this.status.heightMaps) {
+            long[] heightmap = this.heightmaps.get(type);
+            if (heightmap != null) {
+                chunk.a(type, heightmap);
+            } else {
+                missingHeightMaps.add(type);
+            }
+        }
+
+        if (!missingHeightMaps.isEmpty()) {
+            HeightMap.a(chunk, missingHeightMaps);
+        }
+    }
+
+    private void populateStructures(IChunkAccess chunk, DefinedStructureManager structures, long worldSeed) {
+        Map<StructureGenerator<?>, StructureStart<?>> structureStarts = new Object2ObjectOpenHashMap<>();
+        for (Map.Entry<StructureGenerator<?>, NBTTagCompound> entry : this.structureStarts.entrySet()) {
+            StructureStart<?> start = StructureGenerator.a(structures, entry.getValue(), worldSeed);
+            if (start != null) {
+                structureStarts.put(entry.getKey(), start);
+            }
+        }
+
+        chunk.a(structureStarts);
+        //chunk.setStructureReferences(this.structureReferences);
+    }
+
+    private Chunk createWorldChunk(WorldServer world, BiomeStorage biomes) {
+        List<NBTTagCompound> entityTags = this.entityTags;
+        List<NBTTagCompound> blockEntityTags = this.blockEntityTags;
+        Consumer<Chunk> loadToWorld = worldChunk -> addEntitiesToWorldChunk(worldChunk, entityTags, blockEntityTags);
+
+        return new Chunk(world, this.pos, biomes, this.upgradeData, this.blockTickScheduler, this.fluidTickScheduler, this.inhabitedTime, this.sections, loadToWorld);
+    }
+
+    private ProtoChunk createProtoChunk(LightEngine lightingProvider, BiomeStorage biomes, WorldServer worldServer) {
+        ProtoChunk chunk = new ProtoChunk(this.pos, this.upgradeData, this.sections, (ProtoChunkTickList<Block>) this.blockTickScheduler, (ProtoChunkTickList<FluidType>) this.fluidTickScheduler, worldServer);
+
+        chunk.a(biomes);
+        chunk.setInhabitedTime(this.inhabitedTime);
+        chunk.a(this.status);
+
+        if (this.status.isAtLeastStatus(ChunkStatus.FEATURES)) {
+            chunk.a(lightingProvider);
+        }
+
+        for (NBTTagCompound tag : this.entityTags) {
+            chunk.b(tag);
+        }
+
+        for (NBTTagCompound tag : this.blockEntityTags) {
+            chunk.a(tag);
+        }
+
+        Preconditions.checkNotNull(this.protoData, "loaded no proto data for ProtoChunk");
+
+        for (BlockPosition pos : this.protoData.lightSources) {
+            chunk.k(pos);
+        }
+
+        for (Map.Entry<WorldGenStage.Features, BitSet> entry : this.protoData.carvingMasks.entrySet()) {
+            chunk.a(entry.getKey(), entry.getValue());
+        }
+
+        return chunk;
+    }
+
+    private static void addEntitiesToWorldChunk(Chunk chunk, List<NBTTagCompound> entityTags, List<NBTTagCompound> blockEntityTags) {
+        World world = chunk.getWorld();
+        for (NBTTagCompound tag : entityTags) {
+            EntityTypes.a(tag, world, (entity) -> {
+                chunk.a(entity);
+                return entity;
+            });
+            chunk.d(true);
+        }
+
+        for (NBTTagCompound tag : blockEntityTags) {
+            if (!tag.getBoolean("keepPacked")) {
+                BlockPosition pos = new BlockPosition(tag.getInt("x"), tag.getInt("y"), tag.getInt("z"));
+                TileEntity entity = TileEntity.create(chunk.getBlockData(pos), tag);
+                if (entity != null) {
+                    chunk.a(entity);
+                }
+            } else {
+                chunk.a(tag);
+            }
+        }
+    }
+
+    private static class ProtoData {
+        final List<BlockPosition> lightSources;
+        final Map<WorldGenStage.Features, BitSet> carvingMasks;
+
+        ProtoData(List<BlockPosition> lightSources, Map<WorldGenStage.Features, BitSet> carvingMasks) {
+            this.lightSources = lightSources;
+            this.carvingMasks = carvingMasks;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d056f18994d2e6a0d30ca3498d4a8af68f6c1a8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/ChunkLightData.java
@@ -0,0 +1,15 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.WorldServer;
+
+public interface ChunkLightData {
+    void acceptSection(int sectionY, NBTTagCompound sectionTag, ChunkStatus status);
+
+    void applyToWorld(ChunkCoordIntPair chunkPos, WorldServer world);
+
+    void applyToChunk(ProtoChunk chunk);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java b/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java
new file mode 100644
index 0000000000000000000000000000000000000000..69331e8ca65bcf44d90304f65cf23b8478f749eb
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/io/StarlightChunkLightData.java
@@ -0,0 +1,42 @@
+package net.gegy1000.tictacs.chunk.io;
+
+import com.tuinity.tuinity.chunk.light.SWMRNibbleArray;
+import com.tuinity.tuinity.chunk.light.StarLightEngine;
+import net.gegy1000.tictacs.util.NbtType;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.WorldServer;
+
+public final class StarlightChunkLightData implements ChunkLightData {
+    private final SWMRNibbleArray[] blockLightSections = StarLightEngine.getFilledEmptyLight();
+    private final SWMRNibbleArray[] skyLightSections = StarLightEngine.getFilledEmptyLight();
+
+    @Override
+    public void acceptSection(int y, NBTTagCompound sectionTag, ChunkStatus status) {
+        if (!status.isAtLeastStatus(ChunkStatus.LIGHT)) {
+            return;
+        }
+
+        if (sectionTag.hasKeyOfType("BlockLight", NbtType.BYTE_ARRAY)) {
+            this.blockLightSections[y + 1] = new SWMRNibbleArray(sectionTag.getByteArray("BlockLight").clone());
+        }
+
+        if (sectionTag.hasKeyOfType("SkyLight", NbtType.BYTE_ARRAY)) {
+            this.skyLightSections[y + 1] = new SWMRNibbleArray(sectionTag.getByteArray("SkyLight").clone());
+        } else if (sectionTag.getBoolean("starlight.skylight_uninit")) {
+            this.skyLightSections[y + 1] = new SWMRNibbleArray();
+        }
+    }
+
+    @Override
+    public void applyToWorld(ChunkCoordIntPair chunkPos, WorldServer world) {
+    }
+
+    @Override
+    public void applyToChunk(ProtoChunk chunk) {
+        chunk.setBlockNibbles(this.blockLightSections);
+        chunk.setSkyNibbles(this.skyLightSections);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b9392beff5ed1dadda994e65ad2ca7318eafeb9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirement.java
@@ -0,0 +1,47 @@
+package net.gegy1000.tictacs.chunk.step;
+
+public final class ChunkRequirement {
+    public final ChunkStep step;
+    public final boolean read;
+    public final boolean write;
+
+    ChunkRequirement(ChunkStep step, boolean read, boolean write) {
+        this.step = step;
+        this.read = read;
+        this.write = write;
+    }
+
+    public static ChunkRequirement write(ChunkStep step) {
+        return new ChunkRequirement(step, true, true);
+    }
+
+    public static ChunkRequirement read(ChunkStep step) {
+        return new ChunkRequirement(step, true, false);
+    }
+
+    public static ChunkRequirement require(ChunkStep step) {
+        return new ChunkRequirement(step, false, false);
+    }
+
+    public static ChunkRequirement merge(ChunkRequirement a, ChunkRequirement b) {
+        if (a == null) return b;
+        if (b == null) return a;
+
+        ChunkStep step = ChunkStep.max(a.step, b.step);
+        boolean read = a.read || b.read;
+        boolean write = a.write || b.write;
+
+        return new ChunkRequirement(step, read, write);
+    }
+
+    @Override
+    public String toString() {
+        if (this.write) {
+            return "ChunkRequirement{write@" + this.step + "}";
+        } else if (this.read) {
+            return "ChunkRequirement{read@" + this.step + "}";
+        } else {
+            return "ChunkRequirement@" + this.step;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java
new file mode 100644
index 0000000000000000000000000000000000000000..5afcdefe08169836317fc87061d04c6d1aa89f2e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkRequirements.java
@@ -0,0 +1,65 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+
+public final class ChunkRequirements {
+    private ChunkRequirement[] byDistance = new ChunkRequirement[0];
+    private int radius;
+
+    private ChunkRequirements() {
+    }
+
+    public static ChunkRequirements none() {
+        return new ChunkRequirements();
+    }
+
+    public static ChunkRequirements from(ChunkStep step) {
+        return new ChunkRequirements().write(step, 0);
+    }
+
+    public ChunkRequirements read(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.read(step), radius);
+    }
+
+    public ChunkRequirements write(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.write(step), radius);
+    }
+
+    public ChunkRequirements require(ChunkStep step, int radius) {
+        return this.add(ChunkRequirement.require(step), radius);
+    }
+
+    public ChunkRequirements add(ChunkRequirement requirement, int radius) {
+        this.ensureRadius(radius);
+
+        for (int i = 0; i <= radius; i++) {
+            ChunkRequirement existing = this.byDistance[i];
+            this.byDistance[i] = ChunkRequirement.merge(existing, requirement);
+        }
+
+        return this;
+    }
+
+    private void ensureRadius(int radius) {
+        if (this.byDistance.length <= radius) {
+            this.byDistance = Arrays.copyOf(this.byDistance, radius + 1);
+            this.radius = Math.max(this.byDistance.length - 1, 0);
+        }
+    }
+
+    @Nullable
+    public ChunkRequirement byDistance(int distance) {
+        distance = Math.max(distance, 0);
+
+        if (distance >= this.byDistance.length) {
+            return null;
+        }
+
+        return this.byDistance[distance];
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e3042210437e79f9906403ed1aeb876ba3695da
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStep.java
@@ -0,0 +1,448 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import me.titaniumtown.TitaniumConfig;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+import net.gegy1000.tictacs.chunk.future.FutureHandle;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import it.unimi.dsi.fastutil.longs.LongSet;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkGenerator;
+import net.minecraft.server.ChunkMapDistance;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.GeneratorSettings;
+import net.minecraft.server.HeightMap;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.IRegistry;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.RegionLimitedWorldAccess;
+import net.minecraft.server.StructureManager;
+import net.minecraft.server.TicketType;
+import net.minecraft.server.WorldGenStage;
+import net.minecraft.server.WorldServer;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+
+// TODO: separate loading chunk steps and generation chunk steps
+//       allow arbitrary tasks to be attached to steps
+public final class ChunkStep {
+    private static final EnumSet<HeightMap.Type> REQUIRED_FEATURE_HEIGHTMAPS = EnumSet.of(
+            HeightMap.Type.MOTION_BLOCKING,
+            HeightMap.Type.MOTION_BLOCKING_NO_LEAVES,
+            HeightMap.Type.OCEAN_FLOOR,
+            HeightMap.Type.WORLD_SURFACE
+    );
+
+    public static final List<ChunkStep> STEPS = new ArrayList<>();
+
+    public static final ChunkStep EMPTY = new ChunkStep("empty")
+            .includes(ChunkStatus.EMPTY)
+            .locks(ChunkLockType.EARLY_GENERATION)
+            .requires(ChunkRequirements.none());
+
+    public static final ChunkStep STRUCTURE_STARTS = new ChunkStep("structure_starts")
+            .includes(ChunkStatus.STRUCTURE_STARTS)
+            .locks(ChunkLockType.EARLY_GENERATION)
+            .requires(ChunkRequirements.from(ChunkStep.EMPTY))
+            .upgradeSync(ChunkStep::addStructureStarts);
+
+    public static final ChunkStep SURFACE = new ChunkStep("surface")
+            .includes(
+                    ChunkStatus.STRUCTURE_REFERENCES, ChunkStatus.BIOMES,
+                    ChunkStatus.NOISE, ChunkStatus.SURFACE,
+                    ChunkStatus.CARVERS, ChunkStatus.LIQUID_CARVERS
+            )
+            .locks(ChunkLockType.LATE_GENERATION)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.STRUCTURE_STARTS)
+                            .read(ChunkStep.STRUCTURE_STARTS, 8)
+            )
+            .upgradeSync(ChunkStep::generateSurface);
+
+    public static final ChunkStep FEATURES = new ChunkStep("features")
+            .includes(ChunkStatus.FEATURES)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.SURFACE)
+                            // Feature gen radius is controlled by the config, it's usually 2 but can be higher.
+                            .write(ChunkStep.SURFACE, TitaniumConfig.ticTacFeatureGenerationRadius)
+                            .read(ChunkStep.STRUCTURE_STARTS, 8)
+            )
+            .locks(ChunkLockType.LATE_GENERATION)
+            .upgradeAsync(ChunkStep::addFeatures)
+            .loadAsync(ChunkStep::loadFeatures);
+
+    public static final ChunkStep LIGHTING = new ChunkStep("lighting")
+            .includes(ChunkStatus.LIGHT)
+            .requires(
+                    ChunkRequirements.from(ChunkStep.FEATURES)
+                            .read(ChunkStep.FEATURES, 1)
+                            .require(ChunkStep.FEATURES, 1 + TitaniumConfig.ticTacFeatureGenerationRadius)
+            )
+            .locks(ChunkLockType.FINALIZATION)
+            .acquire(ChunkStep::acquireLight)
+            .release(ChunkStep::releaseLight)
+            .upgradeAsync(ctx -> ChunkStep.lightChunk(ctx, false))
+            .loadAsync(ctx -> ChunkStep.lightChunk(ctx, true));
+
+    public static final ChunkStep FULL = new ChunkStep("full")
+            .includes(ChunkStatus.SPAWN, ChunkStatus.HEIGHTMAPS, ChunkStatus.FULL)
+            .requires(ChunkRequirements.from(ChunkStep.LIGHTING))
+            .locks(ChunkLockType.FINALIZATION)
+            .upgradeAsync(ctx -> {
+                ChunkStep.addEntities(ctx);
+                return ChunkStep.makeFull(ctx);
+            })
+            .loadAsync(ChunkStep::makeFull);
+
+    public static final ChunkStep GENERATION = ChunkStep.LIGHTING.getPrevious();
+    public static final ChunkStep MIN_WITH_LOAD_TASK = ChunkStep.LIGHTING;
+
+    private static final ChunkStep[] STATUS_TO_STEP;
+
+    private static final int[] STEP_TO_RADIUS;
+
+    private static final int MAX_DISTANCE;
+    private static final int[] STEP_TO_DISTANCE;
+    private static final ChunkStep[] DISTANCE_TO_STEP;
+
+    private final int index;
+    private final String name;
+    private ChunkStatus[] statuses = new ChunkStatus[0];
+    private ChunkLockType lock;
+    private ChunkRequirements requirements = ChunkRequirements.none();
+
+    private AsyncTask upgradeTask = AsyncTask.noop();
+    private AsyncTask loadTask = AsyncTask.noop();
+    private Acquire acquireTask;
+    private Release releaseTask;
+
+    ChunkStep(String name) {
+        int index = STEPS.size();
+        STEPS.add(this);
+
+        this.index = index;
+        this.name = name;
+    }
+
+    ChunkStep includes(ChunkStatus... statuses) {
+        this.statuses = statuses;
+        return this;
+    }
+
+    ChunkStep locks(ChunkLockType lock) {
+        this.lock = lock;
+        return this;
+    }
+
+    ChunkStep requires(ChunkRequirements requirements) {
+        this.requirements = requirements;
+        return this;
+    }
+
+    ChunkStep upgradeAsync(AsyncTask task) {
+        this.upgradeTask = task;
+        return this;
+    }
+
+    ChunkStep upgradeSync(SyncTask task) {
+        this.upgradeTask = AsyncTask.from(task);
+        return this;
+    }
+
+    ChunkStep loadAsync(AsyncTask task) {
+        this.loadTask = task;
+        return this;
+    }
+
+    ChunkStep acquire(Acquire acquire) {
+        this.acquireTask = acquire;
+        return this;
+    }
+
+    ChunkStep release(Release task) {
+        this.releaseTask = task;
+        return this;
+    }
+
+    public Future<IChunkAccess> runUpgrade(ChunkStepContext ctx) {
+        return this.upgradeTask.run(ctx);
+    }
+
+    public Future<IChunkAccess> runLoad(ChunkStepContext ctx) {
+        return this.loadTask.run(ctx);
+    }
+
+    public ChunkRequirements getRequirements() {
+        return this.requirements;
+    }
+
+    public ChunkLockType getLock() {
+        return this.lock;
+    }
+
+    @Nullable
+    public Acquire getAcquireTask() {
+        return this.acquireTask;
+    }
+
+    @Nullable
+    public Release getReleaseTask() {
+        return this.releaseTask;
+    }
+
+    public ChunkStatus[] getStatuses() {
+        return this.statuses;
+    }
+
+    public ChunkStatus getMaximumStatus() {
+        return this.statuses[this.statuses.length - 1];
+    }
+
+    public int getIndex() {
+        return this.index;
+    }
+
+    public boolean greaterOrEqual(ChunkStep step) {
+        return step == null || this.index >= step.index;
+    }
+
+    public boolean lessOrEqual(ChunkStep step) {
+        return step != null && this.index <= step.index;
+    }
+
+    public boolean greaterThan(ChunkStep step) {
+        return step == null || this.index > step.index;
+    }
+
+    public boolean lessThan(ChunkStep step) {
+        return step != null && this.index < step.index;
+    }
+
+    @Override
+    public String toString() {
+        return this.name;
+    }
+
+    @Nullable
+    public ChunkStep getPrevious() {
+        return byIndex(this.index - 1);
+    }
+
+    @Nullable
+    public ChunkStep getNext() {
+        return byIndex(this.index + 1);
+    }
+
+    public static ChunkStep min(ChunkStep a, ChunkStep b) {
+        if (a == null || b == null) return null;
+
+        return a.index < b.index ? a : b;
+    }
+
+    public static ChunkStep max(ChunkStep a, ChunkStep b) {
+        if (a == null) return b;
+        if (b == null) return a;
+
+        return a.index > b.index ? a : b;
+    }
+
+    @Nullable
+    public static ChunkStep byIndex(int index) {
+        if (index < 0 || index >= STEPS.size()) {
+            return null;
+        }
+        return STEPS.get(index);
+    }
+
+    public static ChunkStep byStatus(ChunkStatus status) {
+        return STATUS_TO_STEP[status.getStatusIndex()];
+    }
+
+    public static ChunkStep byFullStatus(ChunkStatus status) {
+        ChunkStep step = byStatus(status);
+        if (status == step.getMaximumStatus()) {
+            return step;
+        } else {
+            return step.getPrevious();
+        }
+    }
+
+    public static int getRequiredRadius(ChunkStep step) {
+        return STEP_TO_RADIUS[step.getIndex()];
+    }
+
+    public static int getDistanceFromFull(ChunkStep step) {
+        return STEP_TO_DISTANCE[step.getIndex()];
+    }
+
+    public static ChunkStep byDistanceFromFull(int distance) {
+        if (distance < 0) return FULL;
+        if (distance >= DISTANCE_TO_STEP.length) return EMPTY;
+
+        return DISTANCE_TO_STEP[distance];
+    }
+
+    public static int getMaxDistance() {
+        return MAX_DISTANCE;
+    }
+
+    static {
+        // initialize status -> step mapping
+        List<ChunkStatus> statuses = ChunkStatus.a();
+        STATUS_TO_STEP = new ChunkStep[statuses.size()];
+
+        for (ChunkStep step : STEPS) {
+            for (ChunkStatus status : step.statuses) {
+                STATUS_TO_STEP[status.getStatusIndex()] = step;
+            }
+        }
+
+        StepKernelResolver.Results results = new StepKernelResolver(STEPS).resolve();
+
+        MAX_DISTANCE = results.maxDistance;
+        STEP_TO_RADIUS = results.stepToRadius;
+        DISTANCE_TO_STEP = results.distanceToStep;
+        STEP_TO_DISTANCE = results.stepToDistance;
+    }
+
+    private static IChunkAccess addStructureStarts(ChunkStepContext ctx) {
+        WorldServer world = ctx.world;
+        GeneratorSettings options = world.getServer().getServer().getDedicatedServerProperties().generatorSettings;
+        if (options.shouldGenerateMapFeatures()) {
+            ctx.generator.createStructures(world.r(), world.getStructureManager(), ctx.chunk, ctx.structures, world.getSeed());
+        }
+        return ctx.chunk;
+    }
+
+    private static IChunkAccess generateSurface(ChunkStepContext ctx) {
+        ChunkGenerator generator = ctx.generator;
+        WorldServer world = ctx.world;
+        IChunkAccess chunk = ctx.chunk;
+
+        RegionLimitedWorldAccess region = ctx.asRegion();
+        StructureManager structureAccessor = ctx.asStructureAccessor();
+
+        generator.buildNoise(region, structureAccessor, chunk);
+        trySetStatus(chunk, ChunkStatus.STRUCTURE_REFERENCES);
+
+        generator.createBiomes(world.r().b(IRegistry.ay), chunk);
+        trySetStatus(chunk, ChunkStatus.BIOMES);
+
+        generator.buildNoise(region, structureAccessor, chunk);
+        trySetStatus(chunk, ChunkStatus.NOISE);
+
+        generator.buildBase(region, chunk);
+        trySetStatus(chunk, ChunkStatus.SURFACE);
+
+        generator.doCarving(world.getSeed(), world.d(), chunk, WorldGenStage.Features.AIR);
+        trySetStatus(chunk, ChunkStatus.CARVERS);
+
+        generator.doCarving(world.getSeed(), world.d(), chunk, WorldGenStage.Features.LIQUID);
+        trySetStatus(chunk, ChunkStatus.LIQUID_CARVERS);
+
+        return chunk;
+    }
+
+    private static Future<IChunkAccess> addFeatures(ChunkStepContext ctx) {
+        ProtoChunk proto = (ProtoChunk) ctx.chunk;
+        proto.a(ctx.lighting);
+
+        HeightMap.a(ctx.chunk, REQUIRED_FEATURE_HEIGHTMAPS);
+
+        RegionLimitedWorldAccess region = ctx.asRegion();
+        ctx.generator.addDecorations(region, ctx.world.getStructureManager().a(region));
+
+        return Future.ready(ctx.chunk);
+    }
+
+    private static Future<IChunkAccess> loadFeatures(ChunkStepContext ctx) {
+        return Future.ready(ctx.chunk);
+    }
+
+    private static Future<IChunkAccess> lightChunk(ChunkStepContext ctx, boolean load) {
+        trySetStatus(ctx.chunk, ChunkStatus.LIGHT);
+
+        ChunkMapDistance ticketManager = ctx.controller.getTicketManager();
+
+        FutureHandle<IChunkAccess> handle = new FutureHandle<>();
+
+        ChunkCoordIntPair pos = ctx.entry.location;
+        ctx.controller.spawnOnMainThread(ctx.entry, () -> {
+            ticketManager.a(TicketType.LIGHT, pos, ChunkLevelTracker.LIGHT_TICKET_LEVEL, pos);
+
+            ctx.lighting.a(ctx.chunk, load && ctx.chunk.r()).thenAccept(handle::complete);
+        });
+
+        return handle;
+    }
+
+    private static Future<Unit> acquireLight(ChunkController controller) {
+        return controller.getUpgrader().lightingThrottler.acquireAsync();
+    }
+
+    private static void releaseLight(ChunkController controller) {
+        controller.getUpgrader().lightingThrottler.release();
+    }
+
+    private static void addEntities(ChunkStepContext ctx) {
+        RegionLimitedWorldAccess region = ctx.asRegion();
+        ctx.generator.addMobs(region);
+    }
+
+    private static Future<IChunkAccess> makeFull(ChunkStepContext ctx) {
+        FutureHandle<IChunkAccess> handle = new FutureHandle<>();
+
+        ctx.controller.spawnOnMainThread(ctx.entry, () -> {
+            LongSet loadedChunks = ((TacsAccessor) ctx.controller).getLoadedChunks();
+
+            Chunk worldChunk = ctx.entry.finalizeChunk(ctx.world, loadedChunks::add);
+            handle.complete(worldChunk);
+        });
+
+        return handle;
+    }
+
+    public static void trySetStatus(IChunkAccess chunk, ChunkStatus status) {
+        if (chunk instanceof ProtoChunk) {
+            ProtoChunk protoChunk = (ProtoChunk) chunk;
+            if (!protoChunk.getChunkStatus().isAtLeastStatus(status)) {
+                protoChunk.a(status);
+            }
+        }
+    }
+
+    public interface AsyncTask {
+        static AsyncTask noop() {
+            return ctx -> Future.ready(ctx.chunk);
+        }
+
+        static AsyncTask from(SyncTask task) {
+            return ctx -> Future.ready(task.run(ctx));
+        }
+
+        Future<IChunkAccess> run(ChunkStepContext ctx);
+    }
+
+    public interface SyncTask {
+        static SyncTask noop() {
+            return ctx -> ctx.chunk;
+        }
+
+        IChunkAccess run(ChunkStepContext ctx);
+    }
+
+    public interface Acquire {
+        Future<Unit> acquire(ChunkController controller);
+    }
+
+    public interface Release {
+        void release(ChunkController controller);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..1487487ac2eff52323bace57295c34e494605647
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/ChunkStepContext.java
@@ -0,0 +1,54 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.ChunkGenerator;
+import net.minecraft.server.DefinedStructureManager;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.LightEngineThreaded;
+import net.minecraft.server.RegionLimitedWorldAccess;
+import net.minecraft.server.StructureManager;
+import net.minecraft.server.WorldServer;
+
+import java.util.List;
+
+public final class ChunkStepContext {
+    public final ChunkController controller;
+    public final ChunkEntry entry;
+    public final WorldServer world;
+    public final ChunkGenerator generator;
+    public final DefinedStructureManager structures;
+    public final LightEngineThreaded lighting;
+    public final IChunkAccess chunk;
+    public final List<IChunkAccess> chunks;
+
+    private RegionLimitedWorldAccess region;
+    private StructureManager structureAccessor;
+
+    public ChunkStepContext(ChunkController controller, ChunkEntry entry, WorldServer world, ChunkGenerator generator,
+                            DefinedStructureManager structures, LightEngineThreaded lighting, IChunkAccess chunk, List<IChunkAccess> chunks) {
+        this.controller = controller;
+        this.entry = entry;
+        this.world = world;
+        this.generator = generator;
+        this.structures = structures;
+        this.lighting = lighting;
+        this.chunk = chunk;
+        this.chunks = chunks;
+    }
+
+    public RegionLimitedWorldAccess asRegion() {
+        if (this.region == null) {
+            this.region = new RegionLimitedWorldAccess(this.world, this.chunks);
+        }
+        return this.region;
+    }
+
+    public StructureManager asStructureAccessor() {
+        if (this.structureAccessor == null) {
+            RegionLimitedWorldAccess region = this.asRegion();
+            this.structureAccessor = this.world.getStructureManager().a(region);
+        }
+        return this.structureAccessor;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java b/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..40dcb56a07bb2923251b06dc1f0aba357d052511
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/step/StepKernelResolver.java
@@ -0,0 +1,95 @@
+package net.gegy1000.tictacs.chunk.step;
+
+import java.util.List;
+
+public final class StepKernelResolver {
+    private final List<ChunkStep> steps;
+
+    StepKernelResolver(List<ChunkStep> steps) {
+        this.steps = steps;
+    }
+
+    public static int effectiveRadiusFor(ChunkStep step, ChunkStep minimum) {
+        ChunkRequirements requirements = step.getRequirements();
+
+        int radius = requirements.getRadius();
+
+        int effectiveRadius = radius;
+
+        for (int distance = 0; distance <= radius; distance++) {
+            ChunkRequirement requirement = requirements.byDistance(distance);
+            if (requirement != null && (minimum == null || requirement.step.greaterThan(minimum))) {
+                int childRadius = effectiveRadiusFor(requirement.step, minimum);
+                if (childRadius >= 0) {
+                    effectiveRadius = Math.max(effectiveRadius, distance + childRadius);
+                }
+            }
+        }
+
+        return effectiveRadius;
+    }
+
+    private void resolveRadii(Results results) {
+        results.stepToRadius = new int[this.steps.size()];
+
+        for (ChunkStep step : this.steps) {
+            int radius = effectiveRadiusFor(step, null);
+            results.stepToRadius[step.getIndex()] = radius;
+
+            results.maxDistance = Math.max(radius, results.maxDistance);
+        }
+    }
+
+    private void tryAddStepAt(ChunkStep step, int distance, Results results) {
+        ChunkRequirements requirements = step.getRequirements();
+
+        ChunkStep existingStep = results.distanceToStep[distance];
+        if (existingStep == null || step.greaterThan(existingStep)) {
+            results.distanceToStep[distance] = step;
+        }
+
+        int radius = requirements.getRadius();
+        for (int offset = 0; offset <= radius; offset++) {
+            ChunkRequirement requirement = requirements.byDistance(offset);
+            if (requirement != null) {
+                this.tryAddStepAt(requirement.step, distance + offset, results);
+            }
+        }
+    }
+
+    private void resolveDistances(Results results) {
+        results.distanceToStep = new ChunkStep[results.maxDistance + 1];
+
+        ChunkStep lastStep = this.steps.get(this.steps.size() - 1);
+        this.tryAddStepAt(lastStep, 0, results);
+
+        results.stepToDistance = new int[this.steps.size()];
+
+        int distance = 0;
+        for (int i = this.steps.size() - 1; i >= 0; i--) {
+            ChunkStep step = this.steps.get(i);
+
+            while (distance + 1 <= results.maxDistance && step.lessOrEqual(results.distanceToStep[distance + 1])) {
+                distance++;
+            }
+
+            results.stepToDistance[i] = distance;
+        }
+    }
+
+    public Results resolve() {
+        Results results = new Results();
+
+        this.resolveRadii(results);
+        this.resolveDistances(results);
+
+        return results;
+    }
+
+    static final class Results {
+        public int maxDistance;
+        public int[] stepToRadius;
+        public ChunkStep[] distanceToStep;
+        public int[] stepToDistance;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java b/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2ace53a59b0f9701caed60a2e7060720d105792
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ticket/PlayerTicketManager.java
@@ -0,0 +1,200 @@
+package net.gegy1000.tictacs.chunk.ticket;
+
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.future.AwaitAll;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import it.unimi.dsi.fastutil.longs.LongArrayList;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongList;
+import it.unimi.dsi.fastutil.longs.LongLists;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkMapDistance;
+import net.minecraft.server.TicketType;
+
+// TODO: ideally we overwrite generation tickets with player tickets
+public final class PlayerTicketManager implements TicketTracker {
+    private final ChunkController controller;
+    private final ChunkStep step;
+    private final TicketType<ChunkCoordIntPair> ticketType;
+    private final int ticketLevel;
+    private final int levelStep;
+
+    private final int levelCount;
+    private final LongSet[] queues;
+    private final int[] waitingCounts;
+
+    private int currentLevel;
+
+    private final LongList addedChunks = new LongArrayList();
+
+    public PlayerTicketManager(ChunkController controller, ChunkStep step, int radius, TicketType<ChunkCoordIntPair> ticketType, int levelStep) {
+        this.controller = controller;
+        this.step = step;
+        this.ticketType = ticketType;
+        this.levelStep = levelStep;
+
+        this.ticketLevel = ChunkLevelTracker.FULL_LEVEL + ChunkStep.getDistanceFromFull(step) - radius;
+
+        this.levelCount = (ChunkLevelTracker.FULL_LEVEL + levelStep - 1) / levelStep;
+        this.queues = new LongSet[this.levelCount];
+        this.waitingCounts = new int[this.levelCount];
+
+        for (int i = 0; i < this.levelCount; i++) {
+            this.queues[i] = new LongOpenHashSet();
+        }
+    }
+
+    public LongList collectTickets() {
+        ChunkMapDistance ticketManager = this.controller.getTicketManager();
+
+        while (true) {
+            int currentLevel = this.currentLevel;
+            if (currentLevel >= this.levelCount) {
+                return LongLists.EMPTY_LIST;
+            }
+
+            LongSet queue = this.queues[currentLevel];
+
+            // once this level is totally completed, we can advance to the next level
+            if (queue.isEmpty() && this.waitingCounts[currentLevel] <= 0) {
+                this.currentLevel = this.getNextLevel(currentLevel);
+                continue;
+            }
+
+            if (!queue.isEmpty()) {
+                LongList addedChunks = this.addedChunks;
+                addedChunks.clear();
+
+                addedChunks.addAll(queue);
+                queue.clear();
+
+                LongIterator iterator = addedChunks.iterator();
+                while (iterator.hasNext()) {
+                    ChunkCoordIntPair pos = new ChunkCoordIntPair(iterator.nextLong());
+                    ticketManager.a(this.ticketType, pos, this.ticketLevel, pos);
+                }
+
+                return addedChunks;
+            }
+
+            return LongLists.EMPTY_LIST;
+        }
+    }
+
+    public void waitForChunks(LongList chunks) {
+        if (chunks.isEmpty()) {
+            return;
+        }
+
+        int count = chunks.size();
+
+        int currentLevel = this.currentLevel;
+        this.waitingCounts[currentLevel] += count;
+
+        Future<Unit> future = this.awaitAllChunks(chunks);
+        this.controller.spawnOnMainThread(future.map(unit -> {
+            int waitingCount = this.waitingCounts[currentLevel];
+            this.waitingCounts[currentLevel] = Math.max(waitingCount - count, 0);
+            return unit;
+        }));
+
+        chunks.clear();
+    }
+
+    private Future<Unit> awaitAllChunks(LongList entries) {
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+        ChunkAccess chunks = this.controller.getMap().visible();
+
+        ChunkListener[] listeners = new ChunkListener[entries.size()];
+
+        for (int i = 0; i < entries.size(); i++) {
+            long pos = entries.getLong(i);
+            ChunkEntry entry = chunks.getEntry(pos);
+            if (entry == null) {
+                throw new IllegalStateException("missing entry added by player ticket");
+            }
+
+            upgrader.spawnUpgradeTo(entry, this.step);
+            listeners[i] = entry.getListenerFor(this.step);
+        }
+
+        return AwaitAll.of(listeners);
+    }
+
+    @Override
+    public void enqueueTicket(long pos, int distance) {
+        int level = distance / this.levelStep;
+        if (level >= this.levelCount) {
+            return;
+        }
+
+        this.queues[level].add(pos);
+        if (level < this.currentLevel) {
+            this.currentLevel = level;
+        }
+    }
+
+    @Override
+    public void removeTicket(long pos) {
+        this.removeChunkTicket(pos);
+
+        for (int i = this.currentLevel; i < this.levelCount; i++) {
+            LongSet queue = this.queues[i];
+            if (queue.remove(pos)) {
+                if (queue.isEmpty()) {
+                    this.removeLevel(i);
+                }
+                return;
+            }
+        }
+    }
+
+    private void removeChunkTicket(long posKey) {
+        ChunkCoordIntPair pos = new ChunkCoordIntPair(posKey);
+        this.controller.getTicketManager().b(this.ticketType, pos, this.ticketLevel, pos);
+    }
+
+    @Override
+    public void moveTicket(long pos, int fromDistance, int toDistance) {
+        int fromLevel = fromDistance / this.levelStep;
+        if (fromLevel >= this.levelCount) {
+            return;
+        }
+
+        LongSet fromQueue = this.queues[fromLevel];
+        if (!fromQueue.remove(pos)) {
+            return;
+        }
+
+        this.enqueueTicket(pos, toDistance);
+
+        if (fromQueue.isEmpty()) {
+            this.removeLevel(fromLevel);
+        }
+    }
+
+    private void removeLevel(int level) {
+        this.waitingCounts[level] = 0;
+        if (level == this.currentLevel) {
+            this.currentLevel = this.getNextLevel(this.currentLevel);
+        }
+    }
+
+    private int getNextLevel(int fromLevel) {
+        for (int i = fromLevel; i < this.levelCount; i++) {
+            if (!this.queues[i].isEmpty()) {
+                return i;
+            }
+        }
+        return this.levelCount;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..015d6e964251735ac97c985792dadef0cbba665f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/ticket/TicketTracker.java
@@ -0,0 +1,9 @@
+package net.gegy1000.tictacs.chunk.ticket;
+
+public interface TicketTracker {
+    void enqueueTicket(long pos, int distance);
+
+    void removeTicket(long pos);
+
+    void moveTicket(long pos, int fromDistance, int toDistance);
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7422dcd62a7afeb852e5d476bfcac602a87cdd2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTracker.java
@@ -0,0 +1,229 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntryTrackers;
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.EntityTrackerEntry;
+import net.minecraft.server.EntityTypes;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Packet;
+import net.minecraft.server.WorldServer;
+
+import java.util.Set;
+
+public final class ChunkEntityTracker {
+    private final EntityTrackerEntry entry;
+    private final int maxTrackDistance;
+
+    private Set<EntityPlayer> trackingPlayers;
+
+    private ChunkEntry chunkEntry;
+    private long chunkPos;
+
+    public ChunkEntityTracker(Entity entity) {
+        EntityTypes<?> type = entity.getEntityType();
+        int tickInterval = type.bn;
+        boolean updateVelocity = type.isDeltaTracking();
+
+        this.entry = new EntityTrackerEntry((WorldServer) entity.world, entity, tickInterval, updateVelocity, this::sendToTracking, new ObjectOpenHashSet<>());
+        this.maxTrackDistance = type.bm;
+    }
+
+    public Entity getEntity() {
+        return this.entry.tracker;
+    }
+
+    public boolean tick(ChunkController controller) {
+        boolean moved = false;
+
+        long chunkPos = chunkForEntity(this.entry.tracker);
+        if (chunkPos != this.chunkPos || this.chunkEntry == null) {
+            ChunkAccess chunks = controller.getMap().primary();
+
+            ChunkEntry fromChunkEntry = this.chunkEntry;
+            ChunkEntry toChunkEntry = chunks.getEntry(chunkPos);
+
+            this.chunkEntry = toChunkEntry;
+            this.chunkPos = chunkPos;
+
+            this.moveChunk(fromChunkEntry, toChunkEntry);
+            moved = true;
+        }
+
+        this.entry.tick();
+
+        return moved;
+    }
+
+    void remove() {
+        if (this.chunkEntry != null) {
+            this.chunkEntry.getTrackers().removeEntity(this);
+            this.chunkEntry = null;
+        }
+
+        if (this.trackingPlayers != null) {
+            for (EntityPlayer player : this.trackingPlayers) {
+                this.entry.a(player);
+            }
+            this.trackingPlayers = null;
+        }
+    }
+
+    private void moveChunk(ChunkEntry from, ChunkEntry to) {
+        if (from != null) {
+            this.moveFromChunk(from);
+        }
+
+        if (to != null) {
+            this.moveToChunk(to);
+        }
+    }
+
+    private void moveFromChunk(ChunkEntry from) {
+        ChunkEntryTrackers trackers = from.getTrackers();
+        for (EntityPlayer player : trackers.getTrackingPlayers()) {
+            this.updateTrackerUnwatched(player);
+        }
+
+        trackers.removeEntity(this);
+    }
+
+    private void moveToChunk(ChunkEntry to) {
+        ChunkEntryTrackers trackers = to.getTrackers();
+        for (EntityPlayer player : trackers.getTrackingPlayers()) {
+            this.updateTrackerWatched(player);
+        }
+
+        trackers.addEntity(this);
+    }
+
+    public void updateTracker(EntityPlayer player) {
+        boolean isTracked = this.isTrackedBy(player);
+        boolean canTrack = this.canBeTrackedBy(player);
+
+        if (isTracked != canTrack) {
+            if (canTrack) {
+                this.startTracking(player);
+            } else {
+                this.stopTracking(player);
+            }
+        }
+    }
+
+    public void updateTrackerWatched(EntityPlayer player) {
+        if (!this.isTrackedBy(player) && this.canBeTrackedBy(player)) {
+            this.startTracking(player);
+        }
+    }
+
+    public void updateTrackerUnwatched(EntityPlayer player) {
+        if (this.isTrackedBy(player) && !this.canBeTrackedBy(player)) {
+            this.stopTracking(player);
+        }
+    }
+
+    private void startTracking(EntityPlayer player) {
+        if (this.trackingPlayers == null) {
+            this.trackingPlayers = new ObjectOpenHashSet<>(2, Hash.DEFAULT_LOAD_FACTOR);
+        }
+
+        if (this.trackingPlayers.add(player)) {
+            this.entry.b(player);
+        }
+    }
+
+    private void stopTracking(EntityPlayer player) {
+        if (this.trackingPlayers != null && this.trackingPlayers.remove(player)) {
+            if (this.trackingPlayers.isEmpty()) {
+                this.trackingPlayers = null;
+            }
+
+            this.entry.a(player);
+        }
+    }
+
+    private boolean isTrackedBy(EntityPlayer player) {
+        return this.trackingPlayers != null && this.trackingPlayers.contains(player);
+    }
+
+    private boolean canBeTrackedBy(EntityPlayer player) {
+        if (player == this.entry.tracker) {
+            return false;
+        } else if (player.attachedToPlayer) {
+            return true;
+        }
+
+        if (this.chunkEntry == null || !this.chunkEntry.getTrackers().isTrackedBy(player)) {
+            return false;
+        }
+        int chunkX = ChunkCoordIntPair.getX(this.chunkPos);
+        int chunkZ = ChunkCoordIntPair.getZ(this.chunkPos);
+
+        int distance = ChunkTracker.getChunkDistance(player, chunkX, chunkZ);
+        return distance < this.getEffectiveTrackDistance();
+    }
+
+    public void sendToTrackingAndSelf(Packet<?> packet) {
+        this.sendToTracking(packet);
+        this.sendToSelf(packet);
+    }
+
+    public void sendToTracking(Packet<?> packet) {
+        if (this.trackingPlayers == null) {
+            return;
+        }
+
+        if (this.entry.tracker instanceof EntityPlayer) {
+            for (EntityPlayer player : this.trackingPlayers) {
+                player.playerConnection.sendPacket(packet);
+            }
+        } else {
+            // entity tracker updates are lower priority than players so it should be fine to queue them
+            for (EntityPlayer player : this.trackingPlayers) {
+                QueuingConnection.enqueueSend(player.playerConnection, packet);
+            }
+        }
+    }
+
+    private void sendToSelf(Packet<?> packet) {
+        if (this.entry.tracker instanceof EntityPlayer) {
+            EntityPlayer player = (EntityPlayer) this.entry.tracker;
+            QueuingConnection.enqueueSend(player.playerConnection, packet);
+        }
+    }
+
+    private int getEffectiveTrackDistance() {
+        Entity entity = this.entry.tracker;
+        if (!entity.getPassengers().isEmpty()) {
+            return this.adjustTrackDistance(this.maxTrackDistance);
+        }
+
+        int maxDistance = this.maxTrackDistance;
+        for (Entity passenger : entity.getAllPassengers()) {
+            maxDistance = Math.max(maxDistance, passenger.getEntityType().bm);
+        }
+
+        return this.adjustTrackDistance(maxDistance);
+    }
+
+    private int adjustTrackDistance(int initialDistance) {
+        return this.entry.b.getMinecraftServer().b(initialDistance);
+    }
+
+    private static long chunkForEntity(Entity entity) {
+        if (!entity.inChunk) {
+            int x = MathHelper.floor(entity.locX()) >> 4;
+            int z = MathHelper.floor(entity.locZ()) >> 4;
+            return ChunkCoordIntPair.pair(x, z);
+        }
+
+        return ChunkCoordIntPair.pair(entity.chunkX, entity.chunkZ);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java
new file mode 100644
index 0000000000000000000000000000000000000000..e28a02ac60eec13317d71d22a0631b0a154867a2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkEntityTrackers.java
@@ -0,0 +1,63 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.chunk.ChunkController;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.Packet;
+
+public final class ChunkEntityTrackers {
+    private final ChunkController controller;
+    private final Int2ObjectMap<ChunkEntityTracker> entities = new Int2ObjectOpenHashMap<>();
+
+    public ChunkEntityTrackers(ChunkController controller) {
+        this.controller = controller;
+    }
+
+    public void tick() {
+        for (ChunkEntityTracker tracker : this.entities.values()) {
+            tracker.tick(this.controller);
+        }
+    }
+
+    public void add(Entity entity) {
+        if (this.entities.containsKey(entity.getId())) {
+            return;
+        }
+
+        ChunkEntityTracker tracker = new ChunkEntityTracker(entity);
+        tracker.tick(this.controller);
+
+        this.entities.put(entity.getId(), tracker);
+
+        if (entity instanceof EntityPlayer) {
+            this.controller.getTracker().addPlayer((EntityPlayer) entity);
+        }
+    }
+
+    public void remove(Entity entity) {
+        ChunkEntityTracker tracker = this.entities.remove(entity.getId());
+        if (tracker != null) {
+            tracker.remove();
+
+            if (entity instanceof EntityPlayer) {
+                this.controller.getTracker().removePlayer((EntityPlayer) entity);
+            }
+        }
+    }
+
+    public void sendToTracking(Entity entity, Packet<?> packet) {
+        ChunkEntityTracker tracker = this.entities.get(entity.getId());
+        if (tracker != null) {
+            tracker.sendToTracking(packet);
+        }
+    }
+
+    public void sendToTrackingAndSelf(Entity entity, Packet<?> packet) {
+        ChunkEntityTracker tracker = this.entities.get(entity.getId());
+        if (tracker != null) {
+            tracker.sendToTrackingAndSelf(packet);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a4afe5588ac1089bc13346bc99b77382bab2114
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPackets.java
@@ -0,0 +1,91 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.QueuingConnection;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.LightEngine;
+import net.minecraft.server.PacketPlayOutAttachEntity;
+import net.minecraft.server.PacketPlayOutLightUpdate;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.PacketPlayOutMount;
+import net.minecraft.server.PacketPlayOutViewCentre;
+import net.minecraft.server.SectionPosition;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ChunkPackets {
+    public static Data dataFor(Chunk chunk) {
+        return new Data(chunk);
+    }
+
+    public static Entities entitiesFor(ChunkEntry entry) {
+        Entities entities = new Entities();
+        for (ChunkEntityTracker tracker : entry.getTrackers().getEntities()) {
+            entities.addEntity(tracker.getEntity());
+        }
+
+        return entities;
+    }
+
+    public static void sendPlayerChunkPos(EntityPlayer player) {
+        SectionPosition pos = player.O();
+        QueuingConnection.enqueueSend(player.playerConnection, new PacketPlayOutViewCentre(pos.a(), pos.c()));
+    }
+
+    public static class Data {
+        private final Chunk chunk;
+
+        private PacketPlayOutMapChunk dataPacket;
+        private PacketPlayOutLightUpdate lightPacket;
+
+        Data(Chunk chunk) {
+            this.chunk = chunk;
+        }
+
+        public void sendTo(EntityPlayer player) {
+            ChunkCoordIntPair chunkPos = this.chunk.getPos();
+
+            if (this.dataPacket == null) {
+                LightEngine lighting = this.chunk.getWorld().e();
+
+                this.dataPacket = new PacketPlayOutMapChunk(this.chunk, 0xFFFF, chunk.world.chunkPacketBlockController.shouldModify(player, chunk, 65535));
+                this.lightPacket = new PacketPlayOutLightUpdate(chunkPos, lighting, true);
+            }
+
+            player.a(chunkPos, this.dataPacket, this.lightPacket);
+        }
+    }
+
+    public static class Entities {
+        private final List<EntityInsentient> leashedEntities = new ArrayList<>();
+        private final List<Entity> entitiesWithPassengers = new ArrayList<>();
+
+        Entities() {
+        }
+
+        public void addEntity(Entity entity) {
+            if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
+                this.leashedEntities.add((EntityInsentient) entity);
+            }
+
+            if (!entity.getPassengers().isEmpty()) {
+                this.entitiesWithPassengers.add(entity);
+            }
+        }
+
+        public void sendTo(EntityPlayer player) {
+            for (EntityInsentient entity : this.leashedEntities) {
+                QueuingConnection.enqueueSend(player.playerConnection, new PacketPlayOutAttachEntity(entity, entity.getLeashHolder()));
+            }
+
+            for (Entity entity : this.entitiesWithPassengers) {
+                QueuingConnection.enqueueSend(player.playerConnection, new PacketPlayOutMount(entity));
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebd1f6795c816b5cbd66e5e2f6cfb6821e3761f9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkPlayerWatchers.java
@@ -0,0 +1,75 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ReferenceSet;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.GameRules;
+import net.minecraft.server.WorldServer;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+public final class ChunkPlayerWatchers implements Iterable<EntityPlayer> {
+    private final WorldServer world;
+
+    private final ReferenceSet<EntityPlayer> players = new ReferenceOpenHashSet<>();
+    private final ReferenceSet<EntityPlayer> loadingPlayers = new ReferenceOpenHashSet<>();
+
+    public ChunkPlayerWatchers(WorldServer world) {
+        this.world = world;
+    }
+
+    public void addPlayer(EntityPlayer player) {
+        this.players.add(player);
+        if (this.shouldLoadChunks(player)) {
+            this.loadingPlayers.add(player);
+        }
+    }
+
+    public void removePlayer(EntityPlayer player) {
+        if (this.players.remove(player)) {
+            this.loadingPlayers.remove(player);
+        }
+    }
+
+    public void setLoadingEnabled(EntityPlayer player, boolean enabled) {
+        if (!this.players.contains(player)) {
+            return;
+        }
+
+        if (enabled) {
+            this.loadingPlayers.add(player);
+        } else {
+            this.loadingPlayers.remove(player);
+        }
+    }
+
+    public boolean containsPlayer(EntityPlayer player) {
+        return this.players.contains(player);
+    }
+
+    public boolean isLoadingEnabled(EntityPlayer player) {
+        return this.loadingPlayers.contains(player);
+    }
+
+    public boolean shouldLoadChunks(EntityPlayer player) {
+        return !player.isSpectator() || this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
+    }
+
+    public boolean isEmpty() {
+        return this.players.isEmpty();
+    }
+
+    public Collection<EntityPlayer> getPlayers() {
+        return this.players;
+    }
+
+    public Collection<EntityPlayer> getLoadingPlayers() {
+        return this.loadingPlayers;
+    }
+
+    @Override
+    public Iterator<EntityPlayer> iterator() {
+        return this.players.iterator();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java
new file mode 100644
index 0000000000000000000000000000000000000000..f71adf76201be9d28bef58538e6662e92a3c709d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackView.java
@@ -0,0 +1,136 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+
+import net.minecraft.server.ChunkCoordIntPair;
+
+import java.util.function.LongConsumer;
+
+final class ChunkTrackView {
+    int minX;
+    int minZ;
+    int maxX;
+    int maxZ;
+
+    ChunkTrackView() {
+    }
+
+    public static ChunkTrackView withRadius(int x, int z, int radius) {
+        ChunkTrackView view = new ChunkTrackView();
+        view.setWithRadius(x, z, radius);
+
+        return view;
+    }
+
+    public void set(int minX, int minZ, int maxX, int maxZ) {
+        this.minX = minX;
+        this.minZ = minZ;
+        this.maxX = maxX;
+        this.maxZ = maxZ;
+    }
+
+    public void setWithRadius(int x, int z, int radius) {
+        this.set(x - radius, z - radius, x + radius, z + radius);
+    }
+
+    public void forEach(LongConsumer consumer) {
+        forEach(
+                this.minX, this.minZ,
+                this.maxX, this.maxZ,
+                consumer
+        );
+    }
+
+    public void forEachDifference(ChunkTrackView other, LongConsumer consumer) {
+        if (this.equals(other)) {
+            return;
+        }
+
+        if (!this.intersects(other)) {
+            this.forEach(consumer);
+            return;
+        }
+
+        boolean tl = !other.contains(this.minX, this.minZ);
+        boolean tr = !other.contains(this.maxX, this.minZ);
+        boolean bl = !other.contains(this.minX, this.maxZ);
+        boolean br = !other.contains(this.maxX, this.maxZ);
+
+        // corners
+        if (tl) forEach(this.minX, this.minZ, other.minX - 1, other.minZ - 1, consumer);
+        if (tr) forEach(other.maxX + 1, this.minZ, this.maxX, other.minZ - 1, consumer);
+        if (bl) forEach(this.minX, other.maxZ + 1, other.minX - 1, this.maxZ, consumer);
+        if (br) forEach(other.maxX + 1, other.maxZ + 1, this.maxX, this.maxZ, consumer);
+
+        // edges
+        if (tl || tr) {
+            forEach(
+                    Math.max(other.minX - 1, this.minX), this.minZ,
+                    Math.min(other.maxX + 1, this.maxX), other.minZ - 1,
+                    consumer
+            );
+        }
+
+        if (bl || br) {
+            forEach(
+                    Math.max(other.minX - 1, this.minX), other.maxZ + 1,
+                    Math.min(other.maxX + 1, this.maxX), this.maxZ,
+                    consumer
+            );
+        }
+
+        if (tl || bl) {
+            forEach(
+                    this.minX, Math.max(other.minZ - 1, this.minZ),
+                    other.minX - 1, Math.min(other.maxZ + 1, this.maxZ),
+                    consumer
+            );
+        }
+
+        if (tr || br) {
+            forEach(
+                    other.maxX + 1, Math.max(other.minZ - 1, this.minZ),
+                    this.maxX, Math.min(other.maxZ + 1, this.maxZ),
+                    consumer
+            );
+        }
+    }
+
+    public void forEachIntersection(ChunkTrackView other, LongConsumer consumer) {
+        int minX = Math.max(this.minX, other.minX);
+        int maxX = Math.min(this.maxX, other.maxX);
+        int minZ = Math.max(this.minZ, other.minZ);
+        int maxZ = Math.min(this.maxZ, other.maxZ);
+        if (minX > maxX || minZ > maxZ) {
+            return;
+        }
+
+        forEach(minX, minZ, maxX, maxZ, consumer);
+    }
+
+    public void forEachUnion(ChunkTrackView other, LongConsumer consumer) {
+        this.forEachDifference(other, consumer);
+        other.forEachDifference(this, consumer);
+
+        this.forEachIntersection(other, consumer);
+    }
+
+    public boolean contains(int x, int z) {
+        return x >= this.minX && z >= this.minZ && x <= this.maxX && z <= this.maxZ;
+    }
+
+    public boolean intersects(ChunkTrackView view) {
+        return this.minX <= view.maxX && this.maxX >= view.minX && this.minZ <= view.maxZ && this.maxZ >= view.minZ;
+    }
+
+    private static void forEach(int minX, int minZ, int maxX, int maxZ, LongConsumer consumer) {
+        for (int z = minZ; z <= maxZ; z++) {
+            for (int x = minX; x <= maxX; x++) {
+                consumer.accept(ChunkCoordIntPair.pair(x, z));
+            }
+        }
+    }
+
+    public boolean equals(ChunkTrackView other) {
+        return this.minX == other.minX && this.minZ == other.minZ && this.maxX == other.maxX && this.maxZ == other.maxZ;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d7522aa058076d409fb46726319ef0eb049e10e
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTrackWatcher.java
@@ -0,0 +1,67 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.SectionPosition;
+
+import javax.annotation.Nullable;
+
+
+public final class ChunkTrackWatcher {
+    private Function startTracking;
+    private Function stopTracking;
+    private Function updateTracking;
+
+    private int radius;
+
+    public ChunkTrackWatcher(int radius) {
+        this.radius = radius;
+    }
+
+    public void setStartTracking(Function startTracking) {
+        this.startTracking = startTracking;
+    }
+
+    public void setStopTracking(Function stopTracking) {
+        this.stopTracking = stopTracking;
+    }
+
+    public void setUpdateTracking(Function updateTracking) {
+        this.updateTracking = updateTracking;
+    }
+
+    public void setRadius(int radius) {
+        this.radius = radius;
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+
+    public ChunkTrackView viewAt(int x, int z) {
+        return ChunkTrackView.withRadius(x, z, this.radius);
+    }
+
+    public ChunkTrackView viewAt(SectionPosition pos) {
+        return this.viewAt(pos.getX(), pos.getZ());
+    }
+
+    @Nullable
+    public Function getStartTracking() {
+        return this.startTracking;
+    }
+
+    @Nullable
+    public Function getStopTracking() {
+        return this.stopTracking;
+    }
+
+    @Nullable
+    public Function getUpdateTracking() {
+        return this.updateTracking;
+    }
+
+    public interface Function {
+        void accept(EntityPlayer player, long pos, ChunkEntry entry);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..60b1fc02af583dbdd2bc729776b70a1f9b09668f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/tracker/ChunkTracker.java
@@ -0,0 +1,331 @@
+package net.gegy1000.tictacs.chunk.tracker;
+
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.ChunkMapListener;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntryTrackers;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.ChunkMapDistance;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.SectionPosition;
+import net.minecraft.server.WorldServer;
+
+import java.util.Set;
+
+public final class ChunkTracker implements ChunkMapListener {
+    public static final int CHUNK_TICKING_DISTANCE = 8;
+
+    private final ChunkController controller;
+
+    private final ChunkPlayerWatchers players;
+    private final ChunkEntityTrackers entities;
+
+    private final ChunkTrackWatcher playerTracker;
+    private final ChunkTrackWatcher[] trackWatchers;
+
+    private int viewDistance;
+
+    public ChunkTracker(WorldServer world, ChunkController controller) {
+        this.controller = controller;
+        this.players = new ChunkPlayerWatchers(world);
+        this.entities = new ChunkEntityTrackers(controller);
+
+        this.playerTracker = new ChunkTrackWatcher(3);
+        this.playerTracker.setStartTracking(this::startTrackingChunk);
+        this.playerTracker.setStopTracking(this::stopTrackingChunk);
+        this.playerTracker.setUpdateTracking((player, pos, entry) -> {
+            entry.getTrackers().updateTrackingPlayer(player);
+        });
+
+        ChunkTrackWatcher tickingTracker = new ChunkTrackWatcher(CHUNK_TICKING_DISTANCE);
+        tickingTracker.setStartTracking(this::startTrackingChunkTickable);
+        tickingTracker.setStopTracking(this::stopTrackingChunkTickable);
+
+        this.trackWatchers = new ChunkTrackWatcher[] {
+                this.playerTracker,
+                tickingTracker
+        };
+    }
+
+    public static int getChunkDistance(EntityPlayer player, int chunkX, int chunkZ) {
+        SectionPosition playerChunk = player.O();
+        int deltaX = playerChunk.getX() - chunkX;
+        int deltaZ = playerChunk.getZ() - chunkZ;
+
+        return Math.max(Math.abs(deltaX), Math.abs(deltaZ));
+    }
+
+    public void setViewDistance(int viewDistance) {
+        int lastViewDistance = this.viewDistance;
+        this.viewDistance = viewDistance;
+
+        this.playerTracker.setRadius(viewDistance);
+
+        for (EntityPlayer player : this.players) {
+            SectionPosition chunkPos = player.O();
+            int chunkX = chunkPos.getX();
+            int chunkZ = chunkPos.getZ();
+
+            ChunkTrackView view = ChunkTrackView.withRadius(chunkX, chunkZ, viewDistance);
+            ChunkTrackView lastView = ChunkTrackView.withRadius(chunkX, chunkZ, lastViewDistance);
+
+            this.updatePlayerTracker(player, this.playerTracker, view, lastView);
+        }
+    }
+
+    public void tick() {
+        this.entities.tick();
+
+        for (EntityPlayer player : this.players) {
+            this.tickPlayer(player);
+        }
+    }
+
+    private void tickPlayer(EntityPlayer player) {
+        SectionPosition lastSectionPos = player.O();
+        SectionPosition sectionPos = SectionPosition.a(player);
+
+        if (!lastSectionPos.equals(sectionPos)) {
+            player.a(sectionPos);
+
+            if (lastSectionPos.getX() != sectionPos.getX() || lastSectionPos.getZ() != sectionPos.getZ()) {
+                ChunkPackets.sendPlayerChunkPos(player);
+            }
+        }
+
+        this.updatePlayerTickets(player, lastSectionPos, sectionPos);
+        this.updatePlayerTrackers(player, lastSectionPos, sectionPos);
+    }
+
+    private void updatePlayerTickets(EntityPlayer player, SectionPosition lastSectionPos, SectionPosition sectionPos) {
+        boolean lastLoadingEnabled = this.players.isLoadingEnabled(player);
+        boolean loadingEnabled = this.players.shouldLoadChunks(player);
+
+        ChunkMapDistance ticketManager = this.controller.getTicketManager();
+        if (lastSectionPos.getX() != sectionPos.getX() || lastSectionPos.getZ() != sectionPos.getZ()) {
+            if (lastLoadingEnabled) {
+                ticketManager.b(lastSectionPos, player);
+            }
+            if (loadingEnabled) {
+                ticketManager.a(sectionPos, player);
+            }
+        }
+
+        if (lastLoadingEnabled != loadingEnabled) {
+            this.players.setLoadingEnabled(player, loadingEnabled);
+
+            if (loadingEnabled) {
+                ticketManager.b(sectionPos, player);
+            } else {
+                ticketManager.a(lastSectionPos, player);
+            }
+        }
+    }
+
+    private void updatePlayerTrackers(EntityPlayer player, SectionPosition lastSectionPos, SectionPosition sectionPos) {
+        int chunkX = sectionPos.getX();
+        int chunkZ = sectionPos.getZ();
+        int lastChunkX = lastSectionPos.getX();
+        int lastChunkZ = lastSectionPos.getZ();
+
+        if (chunkX == lastChunkX && chunkZ == lastChunkZ) {
+            return;
+        }
+
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackView view = tracker.viewAt(chunkX, chunkZ);
+            ChunkTrackView lastView = tracker.viewAt(lastChunkX, lastChunkZ);
+
+            this.updatePlayerTracker(player, tracker, view, lastView);
+        }
+    }
+
+    private void updatePlayerTracker(EntityPlayer player, ChunkTrackWatcher tracker, ChunkTrackView view, ChunkTrackView lastView) {
+        ChunkAccess chunks = this.controller.getMap().primary();
+
+        ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+        if (startTracking != null) {
+            view.forEachDifference(lastView, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    startTracking.accept(player, pos, entry);
+                }
+            });
+        }
+
+        ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+        if (stopTracking != null) {
+            lastView.forEachDifference(view, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    stopTracking.accept(player, pos, entry);
+                }
+            });
+        }
+
+        ChunkTrackWatcher.Function updateTracking = tracker.getUpdateTracking();
+        if (updateTracking != null) {
+            view.forEachIntersection(lastView, pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    updateTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    private void startTrackingChunk(EntityPlayer player, long pos, ChunkEntry entry) {
+        if (entry.getTrackers().addTrackingPlayer(player)) {
+            Chunk chunk = entry.getChunk();
+            if (chunk != null) {
+                ChunkPackets.Data dataPackets = ChunkPackets.dataFor(chunk);
+                dataPackets.sendTo(player);
+
+                ChunkPackets.Entities entities = ChunkPackets.entitiesFor(entry);
+                entities.sendTo(player);
+            }
+        }
+    }
+
+    private void stopTrackingChunk(EntityPlayer player, long pos, ChunkEntry entry) {
+        if (entry.getTrackers().removeTrackingPlayer(player)) {
+            player.a(new ChunkCoordIntPair(pos));
+        }
+    }
+
+    private void startTrackingChunkTickable(EntityPlayer player, long pos, ChunkEntry entry) {
+        ChunkEntryTrackers trackers = entry.getTrackers();
+
+        if (trackers.getTickableTrackingPlayers().isEmpty()) {
+            ChunkMap map = this.controller.getMap();
+            map.getTickingMaps().addTickableChunk(entry);
+        }
+
+        trackers.addTickableTrackingPlayer(player);
+    }
+
+    private void stopTrackingChunkTickable(EntityPlayer player, long pos, ChunkEntry entry) {
+        ChunkEntryTrackers trackers = entry.getTrackers();
+        trackers.removeTickableTrackingPlayer(player);
+
+        if (trackers.getTickableTrackingPlayers().isEmpty()) {
+            ChunkMap map = this.controller.getMap();
+            map.getTickingMaps().removeTickableChunk(entry);
+        }
+    }
+
+    public void addPlayer(EntityPlayer player) {
+        this.players.addPlayer(player);
+
+        SectionPosition sectionPos = SectionPosition.a(player);
+        player.a(sectionPos);
+        ChunkPackets.sendPlayerChunkPos(player);
+
+        boolean loadChunks = this.players.shouldLoadChunks(player);
+        this.players.setLoadingEnabled(player, loadChunks);
+        if (loadChunks) {
+            this.controller.getTicketManager().a(sectionPos, player);
+        }
+
+        ChunkAccess chunks = this.controller.getMap().primary();
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+            if (startTracking == null) {
+                continue;
+            }
+
+            tracker.viewAt(sectionPos).forEach(pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    startTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    public void removePlayer(EntityPlayer player) {
+        SectionPosition sectionPos = player.O();
+
+        boolean loadChunks = this.players.isLoadingEnabled(player);
+        if (loadChunks) {
+            this.controller.getTicketManager().b(sectionPos, player);
+        }
+
+        this.players.removePlayer(player);
+
+        ChunkAccess chunks = this.controller.getMap().primary();
+        for (ChunkTrackWatcher tracker : this.trackWatchers) {
+            ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+            if (stopTracking == null) {
+                continue;
+            }
+
+            tracker.viewAt(sectionPos).forEach(pos -> {
+                ChunkEntry entry = chunks.getEntry(pos);
+                if (entry != null) {
+                    stopTracking.accept(player, pos, entry);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void onAddChunk(ChunkEntry entry) {
+        ChunkCoordIntPair chunkPos = entry.location;
+        long chunkKey = chunkPos.longKey;
+
+        for (EntityPlayer player : this.players) {
+            int distance = getChunkDistance(player, chunkPos.x, chunkPos.z);
+
+            for (ChunkTrackWatcher tracker : this.trackWatchers) {
+                if (distance > tracker.getRadius()) {
+                    continue;
+                }
+
+                ChunkTrackWatcher.Function startTracking = tracker.getStartTracking();
+                if (startTracking != null) {
+                    startTracking.accept(player, chunkKey, entry);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onRemoveChunk(ChunkEntry entry) {
+        ChunkCoordIntPair chunkPos = entry.location;
+        long chunkKey = chunkPos.longKey;
+
+        for (EntityPlayer player : this.players) {
+            int distance = getChunkDistance(player, chunkPos.x, chunkPos.z);
+
+            for (ChunkTrackWatcher tracker : this.trackWatchers) {
+                if (distance > tracker.getRadius()) {
+                    continue;
+                }
+
+                ChunkTrackWatcher.Function stopTracking = tracker.getStopTracking();
+                if (stopTracking != null) {
+                    stopTracking.accept(player, chunkKey, entry);
+                }
+            }
+        }
+    }
+
+    public void onChunkFull(ChunkEntry entry, Chunk chunk) {
+        ChunkPackets.Data data = ChunkPackets.dataFor(chunk);
+        ChunkPackets.Entities entities = ChunkPackets.entitiesFor(entry);
+
+        Set<EntityPlayer> trackingPlayers = entry.getTrackers().getTrackingPlayers();
+        for (EntityPlayer player : trackingPlayers) {
+            data.sendTo(player);
+            entities.sendTo(player);
+        }
+    }
+
+    public ChunkEntityTrackers getEntities() {
+        return this.entities;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java
new file mode 100644
index 0000000000000000000000000000000000000000..b40df40c01209088aafd2ab8936e3826820cff30
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/AcquireChunks.java
@@ -0,0 +1,185 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.async.lock.JoinLock;
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.chunk.ChunkLockType;
+import net.gegy1000.tictacs.chunk.entry.ChunkAccessLock;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkRequirement;
+import net.gegy1000.tictacs.chunk.step.ChunkRequirements;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.function.Function;
+
+// TODO: ideally we can pool these instances
+final class AcquireChunks {
+    private final ChunkUpgradeKernel kernel;
+
+    private final Lock[] upgradeLocks;
+    private final Lock[] locks;
+
+    private final Lock joinLock;
+    private final Future<Unit> acquireJoinLock;
+
+    final ChunkUpgradeEntries entries;
+    volatile Result acquired;
+
+    AcquireChunks(ChunkUpgrade upgrade) {
+        this.kernel = upgrade.getKernel();
+        this.entries = upgrade.entries;
+
+        this.upgradeLocks = this.kernel.create(Lock[]::new);
+        this.locks = this.kernel.create(Lock[]::new);
+
+        this.joinLock = new JoinLock(
+                new JoinLock(this.upgradeLocks),
+                new JoinLock(this.locks)
+        );
+        this.acquireJoinLock = new Lock.AcquireFuture(this.joinLock);
+    }
+
+    private void clearBuffers() {
+        Arrays.fill(this.upgradeLocks, null);
+        Arrays.fill(this.locks, null);
+    }
+
+    @Nullable
+    public Result poll(Waker waker, ChunkStep step) {
+        if (this.acquired == null) {
+            this.acquired = this.pollAcquire(waker, step);
+            if (this.acquired != Result.OK) {
+                this.clearBuffers();
+            }
+        }
+
+        return this.acquired;
+    }
+
+    @Nullable
+    private Result pollAcquire(Waker waker, ChunkStep step) {
+        Result result = this.collectChunks(step);
+        if (result != Result.OK) {
+            return result;
+        }
+
+        if (this.acquireJoinLock.poll(waker) != null) {
+            return Result.OK;
+        } else {
+            return null;
+        }
+    }
+
+    private Result collectChunks(ChunkStep step) {
+        Lock[] upgradeLocks = this.upgradeLocks;
+        Lock[] locks = this.locks;
+
+        ChunkUpgradeEntries entries = this.entries;
+        ChunkUpgradeKernel kernel = this.kernel;
+        int radiusForStep = kernel.getRadiusFor(step);
+
+        ChunkRequirements requirements = step.getRequirements();
+
+        boolean empty = true;
+
+        for (int z = -radiusForStep; z <= radiusForStep; z++) {
+            for (int x = -radiusForStep; x <= radiusForStep; x++) {
+                ChunkEntry entry = entries.getEntry(x, z);
+                if (!entry.isValidAs(step)) {
+                    return Result.UNLOADED;
+                }
+
+                if (entry.canUpgradeTo(step)) {
+                    entry.trySpawnUpgradeTo(step);
+
+                    int idx = kernel.index(x, z);
+                    upgradeLocks[idx] = entry.getLock().upgrade();
+                    locks[idx] = entry.getLock().write(step.getLock());
+
+                    this.collectContextMargin(x, z, requirements);
+
+                    empty = false;
+                }
+            }
+        }
+
+        return empty ? Result.EMPTY : Result.OK;
+    }
+
+    private void collectContextMargin(int centerX, int centerZ, ChunkRequirements requirements) {
+        int contextRadius = requirements.getRadius();
+        if (contextRadius <= 0) {
+            return;
+        }
+
+        Lock[] locks = this.locks;
+        ChunkUpgradeEntries entries = this.entries;
+        ChunkUpgradeKernel kernel = this.kernel;
+
+        int kernelRadius = kernel.getRadius();
+
+        int minX = Math.max(centerX - contextRadius, -kernelRadius);
+        int maxX = Math.min(centerX + contextRadius, kernelRadius);
+        int minZ = Math.max(centerZ - contextRadius, -kernelRadius);
+        int maxZ = Math.min(centerZ + contextRadius, kernelRadius);
+
+        for (int z = minZ; z <= maxZ; z++) {
+            for (int x = minX; x <= maxX; x++) {
+                int idx = kernel.index(x, z);
+
+                if (locks[idx] == null) {
+                    int distance = Math.max(Math.abs(x - centerX), Math.abs(z - centerZ));
+                    ChunkRequirement requirement = requirements.byDistance(distance);
+
+                    if (requirement != null) {
+                        ChunkEntry entry = entries.getEntry(x, z);
+                        ChunkAccessLock lock = entry.getLock();
+                        ChunkLockType lockType = requirement.step.getLock();
+
+                        if (requirement.write) {
+                            locks[idx] = lock.write(lockType);
+                        } else if (requirement.read) {
+                            locks[idx] = lock.read(lockType);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void release() {
+        if (this.acquired == Result.OK) {
+            this.joinLock.release();
+        }
+
+        this.clearBuffers();
+
+        this.acquired = null;
+    }
+
+    <T> void openUpgradeTasks(Future<T>[] tasks, Function<ChunkEntry, Future<T>> function) {
+        Lock[] upgradeLocks = AcquireChunks.this.upgradeLocks;
+        ChunkUpgradeEntries entries = AcquireChunks.this.entries;
+        ChunkUpgradeKernel kernel = AcquireChunks.this.kernel;
+        int radius = kernel.getRadius();
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                int idx = kernel.index(x, z);
+                if (upgradeLocks[idx] != null) {
+                    tasks[idx] = function.apply(entries.getEntry(x, z));
+                }
+            }
+        }
+    }
+
+    public enum Result {
+        OK,
+        UNLOADED,
+        EMPTY
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..b145d998d63aec05fecb2e6a2fb33867754accbf
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkLoadFuture.java
@@ -0,0 +1,56 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import net.minecraft.server.IChunkAccess;
+
+import javax.annotation.Nullable;
+
+
+final class ChunkLoadFuture implements Future<IChunkAccess> {
+    final ChunkController controller;
+    final ChunkEntry entry;
+
+    volatile Future<Unit> acquireLock;
+    volatile Future<IChunkAccess> loadFuture;
+
+    public ChunkLoadFuture(ChunkController controller, ChunkEntry entry) {
+        this.controller = controller;
+        this.entry = entry;
+    }
+
+    @Nullable
+    @Override
+    public IChunkAccess poll(Waker waker) {
+        Lock upgradeLock = this.entry.getLock().upgrade();
+
+        if (this.loadFuture == null) {
+            if (this.acquireLock == null) {
+                this.acquireLock = upgradeLock.acquireAsync();
+            }
+
+            if (this.acquireLock.poll(waker) == null) {
+                return null;
+            }
+
+            this.loadFuture = this.controller.spawnLoadChunk(this.entry);
+        }
+
+        IChunkAccess chunk = this.loadFuture.poll(waker);
+        if (chunk == null) {
+            return null;
+        }
+
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+        upgrader.notifyUpgradeOk(this.entry, ChunkStep.EMPTY, chunk);
+
+        upgradeLock.release();
+
+        return chunk;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java
new file mode 100644
index 0000000000000000000000000000000000000000..6536a22dd90f152540d752f6a45c2fdee344c5d9
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrade.java
@@ -0,0 +1,23 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+class ChunkUpgrade {
+    final ChunkStep fromStep;
+    final ChunkStep toStep;
+    final ChunkUpgradeEntries entries;
+
+    ChunkUpgrade(ChunkStep fromStep, ChunkStep toStep, ChunkUpgradeEntries entries) {
+        this.fromStep = fromStep;
+        this.toStep = toStep;
+        this.entries = entries;
+    }
+
+    public boolean isEmpty() {
+        return this.toStep.lessOrEqual(this.fromStep);
+    }
+
+    public ChunkUpgradeKernel getKernel() {
+        return ChunkUpgradeKernel.betweenSteps(this.fromStep, this.toStep);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java
new file mode 100644
index 0000000000000000000000000000000000000000..40950c1328418336f49ac5b450494b92fee7eff8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeEntries.java
@@ -0,0 +1,25 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import com.google.common.collect.Iterators;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+
+import java.util.Iterator;
+
+final class ChunkUpgradeEntries implements Iterable<ChunkEntry> {
+    final ChunkUpgradeKernel kernel;
+    final ChunkEntry[] entries;
+
+    ChunkUpgradeEntries(ChunkUpgradeKernel kernel) {
+        this.kernel = kernel;
+        this.entries = kernel.create(ChunkEntry[]::new);
+    }
+
+    ChunkEntry getEntry(int x, int z) {
+        return this.entries[this.kernel.index(x, z)];
+    }
+
+    @Override
+    public Iterator<ChunkEntry> iterator() {
+        return Iterators.forArray(this.entries);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..a777865b5fef535ce28ebdc318366a82b6b9e8f5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeFuture.java
@@ -0,0 +1,218 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkNotLoadedException;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.Result;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.MinecraftServer;
+
+import javax.annotation.Nullable;
+
+
+public final class ChunkUpgradeFuture implements Future<Unit> {
+    final ChunkController controller;
+
+    final ChunkEntry entry;
+    final ChunkStep targetStep;
+
+    private final ChunkUpgradeStepper stepper;
+
+    private volatile PrepareUpgradeFuture prepareUpgrade;
+
+    private volatile ChunkUpgrade upgrade;
+    private volatile AcquireChunks acquireChunks;
+
+    private volatile ChunkStep currentStep;
+
+    private volatile Future<Unit> acquireStep;
+    private volatile boolean stepReady;
+
+    public ChunkUpgradeFuture(ChunkController controller, ChunkEntry entry, ChunkStep targetStep) {
+        this.controller = controller;
+        this.entry = entry;
+        this.targetStep = targetStep;
+
+        this.stepper = new ChunkUpgradeStepper(this);
+        this.prepareUpgrade = new PrepareUpgradeFuture(controller, entry, targetStep);
+    }
+
+    @Nullable
+    @Override
+    public Unit poll(Waker waker) {
+        if (this.upgrade == null) {
+            Result<ChunkUpgrade> prepare = this.prepareUpgrade.poll(waker);
+            if (prepare == null) {
+                return null;
+            }
+
+            this.prepareUpgrade = null;
+
+            if (prepare.isError()) {
+                // this chunk is no longer valid to be upgraded: abort
+                this.controller.getUpgrader().notifyUpgradeUnloaded(this.entry, this.targetStep);
+                return Unit.INSTANCE;
+            }
+
+            this.upgrade = prepare.get();
+
+            if (this.upgrade.isEmpty()) {
+                return Unit.INSTANCE;
+            }
+
+            this.currentStep = this.upgrade.fromStep.getNext();
+        }
+
+        while (true) {
+            ChunkStep currentStep = this.currentStep;
+
+            if (!this.pollStepReady(currentStep, waker)) {
+                return null;
+            }
+
+            if (this.acquireChunks == null) {
+                this.acquireChunks = new AcquireChunks(this.upgrade);
+            }
+
+            // poll to acquire read/write access to all the relevant entries
+            AcquireChunks.Result result = this.acquireChunks.poll(waker, currentStep);
+            if (result == null) {
+                return null;
+            }
+
+            // if some of the chunk entries have unloaded since we've started, we can't continue
+            if (result == AcquireChunks.Result.UNLOADED) {
+                return this.returnUnloaded(currentStep);
+            }
+
+            try {
+                if (result == AcquireChunks.Result.OK) {
+                    IChunkAccess[] pollChunks = this.stepper.pollStep(waker, this.upgrade.entries, this.acquireChunks, currentStep);
+                    if (pollChunks == null) {
+                        return null;
+                    }
+
+                    this.notifyUpgrades(pollChunks, currentStep);
+                }
+
+                this.releaseStep();
+            } catch (ChunkNotLoadedException err) {
+                return this.returnUnloaded(currentStep);
+            } catch (Exception e) {
+                MinecraftServer.LOGGER.error("Failed to generate chunk at {}", this.entry.location, e);
+                return this.returnUnloaded(currentStep);
+            }
+
+            if (currentStep.lessThan(this.targetStep)) {
+                this.currentStep = currentStep.getNext();
+            } else {
+                // we've finished upgrading this chunk!
+                return Unit.INSTANCE;
+            }
+        }
+    }
+
+    private boolean pollStepReady(ChunkStep currentStep, Waker waker) {
+        if (this.stepReady) {
+            return true;
+        }
+
+        if (this.acquireStep == null) {
+            ChunkStep.Acquire acquire = currentStep.getAcquireTask();
+            if (acquire == null) {
+                this.stepReady = true;
+                return true;
+            }
+
+            this.acquireStep = acquire.acquire(this.controller);
+        }
+
+        if (this.acquireStep.poll(waker) != null) {
+            this.stepReady = true;
+            this.acquireStep = null;
+            return true;
+        }
+
+        return false;
+    }
+
+    private Unit returnUnloaded(ChunkStep currentStep) {
+        this.notifyUpgradeUnloaded(currentStep);
+        this.releaseStep();
+
+        return Unit.INSTANCE;
+    }
+
+    private void releaseStep() {
+        this.stepper.reset();
+        this.acquireChunks.release();
+
+        ChunkStep.Release releaseTask = this.currentStep.getReleaseTask();
+        if (releaseTask != null) {
+            releaseTask.release(this.controller);
+        }
+
+        this.acquireChunks = null;
+        this.acquireStep = null;
+        this.stepReady = false;
+    }
+
+    private void notifyUpgrades(IChunkAccess[] chunks, ChunkStep step) {
+        ChunkUpgradeEntries entries = this.upgrade.entries;
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        ChunkUpgradeKernel kernel = this.upgrade.getKernel();
+        int radius = kernel.getRadiusFor(step);
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                IChunkAccess chunk = chunks[kernel.index(x, z)];
+                if (chunk != null) {
+                    ChunkEntry entry = entries.getEntry(x, z);
+                    upgrader.notifyUpgradeOk(entry, step, chunk);
+                }
+            }
+        }
+    }
+
+    private void notifyUpgradeUnloaded(ChunkStep step) {
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        upgrader.notifyUpgradeUnloaded(this.entry, step);
+
+        // let the chunk entries know that we're not trying to upgrade them anymore
+        for (ChunkEntry entry : this.upgrade.entries) {
+            entry.notifyUpgradeCanceled(step);
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder display = new StringBuilder();
+        display.append("upgrading ").append(this.entry.location).append(" to ").append(this.targetStep).append(": ");
+
+        if (this.upgrade != null) {
+            if (this.currentStep.greaterOrEqual(this.targetStep) && this.stepReady && this.acquireChunks.acquired != null) {
+                display.append("ready!");
+            } else {
+                if (this.stepReady) {
+                    if (this.acquireChunks.acquired != null) {
+                        display.append("waiting for upgrade to ").append(this.currentStep);
+                    } else {
+                        display.append("waiting to acquire entry locks @").append(this.currentStep);
+                    }
+                } else {
+                    display.append("waiting for ").append(this.currentStep).append(" to be ready");
+                }
+            }
+        } else {
+            display.append("preparing upgrade");
+        }
+
+        return display.toString();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java
new file mode 100644
index 0000000000000000000000000000000000000000..9882a2aed86061be539c903e85840d08e1f1ff71
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeKernel.java
@@ -0,0 +1,89 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.step.StepKernelResolver;
+
+import java.util.List;
+import java.util.function.IntFunction;
+
+public final class ChunkUpgradeKernel {
+    private static final List<ChunkStep> STEPS = ChunkStep.STEPS;
+    private static final int STEP_COUNT = STEPS.size();
+
+    private static final ChunkUpgradeKernel[] BETWEEN_STEPS = new ChunkUpgradeKernel[STEP_COUNT * STEP_COUNT];
+
+    static {
+        // TODO: this table can be more compact by not having null entries
+        for (int fromIdx = 0; fromIdx < STEP_COUNT; fromIdx++) {
+            ChunkStep from = ChunkStep.byIndex(fromIdx - 1);
+
+            for (int toIdx = fromIdx - 1; toIdx < STEP_COUNT; toIdx++) {
+                ChunkStep to = ChunkStep.byIndex(toIdx);
+                if (to == null) {
+                    continue;
+                }
+
+                BETWEEN_STEPS[toIdx + fromIdx * STEP_COUNT] = new ChunkUpgradeKernel(from, to);
+            }
+        }
+    }
+
+    private final ChunkStep from;
+    private final ChunkStep to;
+    private final int radius;
+    private final int size;
+
+    private ChunkUpgradeKernel(ChunkStep from, ChunkStep to) {
+        if (to.lessThan(from)) {
+            throw new IllegalArgumentException(from + " > " + to);
+        }
+
+        this.from = from;
+        this.to = to;
+
+        this.radius = to != from ? StepKernelResolver.effectiveRadiusFor(to, from) : 0;
+        this.size = this.radius * 2 + 1;
+    }
+
+    public static ChunkUpgradeKernel forStep(ChunkStep step) {
+        return BETWEEN_STEPS[step.getIndex()];
+    }
+
+    public static ChunkUpgradeKernel betweenSteps(ChunkStep from, ChunkStep to) {
+        if (to.lessThan(from)) {
+            throw new IllegalArgumentException(from + " > " + to);
+        }
+
+        int fromIdx = from != null ? from.getIndex() + 1 : 0;
+        int toIdx = to.getIndex();
+        return BETWEEN_STEPS[toIdx + fromIdx * STEP_COUNT];
+    }
+
+    public int getRadius() {
+        return this.radius;
+    }
+
+    public int getRadiusFor(ChunkStep step) {
+        return ChunkStep.getDistanceFromFull(step) - ChunkStep.getDistanceFromFull(this.to);
+    }
+
+    public int getSize() {
+        return this.size;
+    }
+
+    public int index(int x, int z) {
+        int radius = this.radius;
+        if (TicTacs.DEBUG) {
+            if (x < -radius || z < -radius || x > radius || z > radius) {
+                throw new IllegalArgumentException("[" + x + "; " + z + "] out of radius=" + this.radius);
+            }
+        }
+        return (x + radius) + (z + radius) * this.size;
+    }
+
+    public <T> T create(IntFunction<T> function) {
+        return function.apply(this.size * this.size);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1b19c521adebad9f4126df7c2a8d7a7864d0a4c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgradeStepper.java
@@ -0,0 +1,164 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.AtomicPool;
+import net.gegy1000.tictacs.TicTacs;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.JoinAllArray;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.IChunkAccess;
+
+import javax.annotation.Nullable;
+import java.util.AbstractList;
+import java.util.Arrays;
+
+final class ChunkUpgradeStepper {
+    private static final AtomicPool<ContextView> CONTEXT_POOL = new AtomicPool<>(512, ContextView::new);
+    private static final AtomicPool<TaskWithContext> TASK_POOL = new AtomicPool<>(512, TaskWithContext::new);
+
+    private final ChunkUpgradeFuture parent;
+
+    private final Future<IChunkAccess>[] tasks;
+    private final IChunkAccess[] chunks;
+
+    private volatile boolean pollingTasks;
+
+    @SuppressWarnings("unchecked")
+    ChunkUpgradeStepper(ChunkUpgradeFuture parent) {
+        this.parent = parent;
+
+        ChunkUpgradeKernel kernel = ChunkUpgradeKernel.forStep(parent.targetStep);
+        this.tasks = kernel.create(Future[]::new);
+        this.chunks = kernel.create(IChunkAccess[]::new);
+    }
+
+    void reset() {
+        this.pollingTasks = false;
+        Arrays.fill(this.chunks, null);
+        Arrays.fill(this.tasks, null);
+    }
+
+    @Nullable
+    IChunkAccess[] pollStep(Waker waker, ChunkUpgradeEntries entries, AcquireChunks chunks, ChunkStep step) {
+        Future<IChunkAccess>[] tasks = this.tasks;
+
+        if (!this.pollingTasks) {
+            this.pollingTasks = true;
+            this.openUpgradeTasks(entries, chunks, step, tasks);
+        }
+
+        return JoinAllArray.poll(waker, tasks, this.chunks);
+    }
+
+    private void openUpgradeTasks(ChunkUpgradeEntries entries, AcquireChunks chunks, ChunkStep step, Future<IChunkAccess>[] tasks) {
+        chunks.openUpgradeTasks(tasks, entry -> this.upgradeChunk(entry, entries, step));
+    }
+
+    private Future<IChunkAccess> upgradeChunk(ChunkEntry entry, ChunkUpgradeEntries entries, ChunkStep step) {
+        ContextView context = this.openContext(entry, entries, step);
+
+        Future<IChunkAccess> future = this.parent.controller.getUpgrader().runStepTask(entry, step, context);
+        return this.createTaskWithContext(future, context);
+    }
+
+    private ContextView openContext(ChunkEntry entry, ChunkUpgradeEntries entries, ChunkStep step) {
+        ContextView context = CONTEXT_POOL.acquire();
+        ChunkCoordIntPair targetPos = entry.location;
+
+        int targetRadius = step.getRequirements().getRadius();
+        context.open(this.parent.entry.location, entries, targetPos, targetRadius);
+
+        return context;
+    }
+
+    private TaskWithContext createTaskWithContext(Future<IChunkAccess> future, ContextView context) {
+        TaskWithContext task = TASK_POOL.acquire();
+        task.future = future;
+        task.context = context;
+
+        return task;
+    }
+
+    static class TaskWithContext implements Future<IChunkAccess> {
+        Future<IChunkAccess> future;
+        ContextView context;
+
+        @Nullable
+        @Override
+        public IChunkAccess poll(Waker waker) {
+            IChunkAccess poll = this.future.poll(waker);
+            if (poll != null) {
+                this.release();
+                return poll;
+            }
+
+            return null;
+        }
+
+        void release() {
+            this.context.release();
+
+            this.future = null;
+            this.context = null;
+
+            TASK_POOL.release(this);
+        }
+    }
+
+    static class ContextView extends AbstractList<IChunkAccess> {
+        private ChunkUpgradeEntries source;
+        private int targetSize;
+
+        private int targetToSourceOffsetX;
+        private int targetToSourceOffsetZ;
+
+        void open(
+                ChunkCoordIntPair sourceOrigin, ChunkUpgradeEntries source,
+                ChunkCoordIntPair targetOrigin, int targetRadius
+        ) {
+            this.source = source;
+            this.targetSize = targetRadius * 2 + 1;
+
+            this.targetToSourceOffsetX = (targetOrigin.x - targetRadius) - sourceOrigin.x;
+            this.targetToSourceOffsetZ = (targetOrigin.z - targetRadius) - sourceOrigin.z;
+
+            if (TicTacs.DEBUG) {
+                if (targetRadius > source.kernel.getRadius()) {
+                    throw new IllegalStateException("target radius larger than source radius");
+                }
+
+                IChunkAccess chunk = this.get(this.size() / 2);
+                if (chunk == null) {
+                    throw new IllegalStateException("center chunk is null");
+                }
+
+                if (!chunk.getPos().equals(targetOrigin)) {
+                    throw new IllegalStateException("center chunk pos does not match target pos");
+                }
+            }
+        }
+
+        @Override
+        public IChunkAccess get(int targetIndex) {
+            int targetX = targetIndex % this.targetSize;
+            int targetZ = targetIndex / this.targetSize;
+            int sourceX = targetX + this.targetToSourceOffsetX;
+            int sourceZ = targetZ + this.targetToSourceOffsetZ;
+
+            ChunkEntry entry = this.source.getEntry(sourceX, sourceZ);
+            return entry.getProtoChunk();
+        }
+
+        @Override
+        public int size() {
+            return this.targetSize * this.targetSize;
+        }
+
+        void release() {
+            this.source = null;
+            CONTEXT_POOL.release(this);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java
new file mode 100644
index 0000000000000000000000000000000000000000..d332ff7a792b2440e85dafec3223b9e728a47856
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/ChunkUpgrader.java
@@ -0,0 +1,91 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.async.lock.Lock;
+import net.gegy1000.tictacs.async.lock.NullLock;
+import net.gegy1000.tictacs.async.worker.ChunkExecutor;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.step.ChunkStepContext;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import net.minecraft.server.ChunkGenerator;
+import net.minecraft.server.ChunkStatus;
+import net.minecraft.server.DefinedStructureManager;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.LightEngineThreaded;
+import net.minecraft.server.ProtoChunk;
+import net.minecraft.server.WorldServer;
+
+import java.util.List;
+
+public final class ChunkUpgrader {
+    private final ChunkExecutor worker = ChunkExecutor.INSTANCE;
+
+    private final ChunkController controller;
+
+    private final WorldServer world;
+    private final ChunkGenerator generator;
+    private final DefinedStructureManager structures;
+    private final LightEngineThreaded lighting;
+
+    public final Lock lightingThrottler = NullLock.INSTANCE;
+
+    public ChunkUpgrader(WorldServer world, ChunkController controller, ChunkGenerator generator, DefinedStructureManager structures, LightEngineThreaded lighting) {
+        this.world = world;
+        this.generator = generator;
+        this.structures = structures;
+        this.lighting = lighting;
+
+        this.controller = controller;
+    }
+
+    public void spawnUpgradeTo(ChunkEntry entry, ChunkStep step) {
+        if (entry.trySpawnUpgradeTo(step)) {
+            this.worker.spawn(entry, this.upgradeTo(entry, step));
+        }
+    }
+
+    public Future<IChunkAccess> loadChunk(ChunkEntry entry) {
+        if (entry.trySpawnLoad()) {
+            return new ChunkLoadFuture(this.controller, entry);
+        } else {
+            return entry.getListenerFor(ChunkStep.EMPTY);
+        }
+    }
+
+    private Future<Unit> upgradeTo(ChunkEntry entry, ChunkStep step) {
+        // TODO: pool instances
+        return new ChunkUpgradeFuture(this.controller, entry, step);
+    }
+
+    Future<IChunkAccess> runStepTask(ChunkEntry entry, ChunkStep step, List<IChunkAccess> chunks) {
+        // TODO: reuse context objects
+        ChunkStepContext context = new ChunkStepContext(this.controller, entry, this.world, this.generator, this.structures, this.lighting, entry.getProtoChunk(), chunks);
+
+        if (this.hasAlreadyUpgradedTo(entry, step)) {
+            return step.runLoad(context);
+        } else {
+            return step.runUpgrade(context);
+        }
+    }
+
+    private boolean hasAlreadyUpgradedTo(ChunkEntry entry, ChunkStep step) {
+        ProtoChunk currentChunk = entry.getProtoChunk();
+        return currentChunk != null && currentChunk.getChunkStatus().isAtLeastStatus(step.getMaximumStatus());
+    }
+
+    void notifyUpgradeOk(ChunkEntry entry, ChunkStep step, IChunkAccess chunk) {
+        entry.completeUpgradeOk(step, chunk);
+
+        ChunkStatus status = step.getMaximumStatus();
+
+        this.controller.notifyStatus(entry.location, status);
+        ChunkStep.trySetStatus(chunk, status);
+    }
+
+    void notifyUpgradeUnloaded(ChunkEntry entry, ChunkStep step) {
+        entry.notifyUpgradeUnloaded(step);
+        this.controller.notifyStatus(entry.location, null);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java
new file mode 100644
index 0000000000000000000000000000000000000000..75e2350017ccd3e7c89d982ef95c4e993d6fc76c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/chunk/upgrade/PrepareUpgradeFuture.java
@@ -0,0 +1,226 @@
+package net.gegy1000.tictacs.chunk.upgrade;
+
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.future.JoinAllArray;
+import net.gegy1000.tictacs.chunk.future.Result;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+import net.minecraft.server.IChunkAccess;
+import net.minecraft.server.ProtoChunk;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+
+class PrepareUpgradeFuture implements Future<Result<ChunkUpgrade>> {
+    final ChunkController controller;
+
+    final ChunkEntry entry;
+    final ChunkStep targetStep;
+
+    private volatile ChunkStep fromStep;
+
+    private volatile ChunkUpgradeEntries entries;
+    private volatile Future<IChunkAccess>[] loadFutures;
+    private volatile IChunkAccess[] loadedChunks;
+
+    private volatile boolean collectedEntries;
+
+    private volatile Future<Unit> flushListener;
+
+    PrepareUpgradeFuture(ChunkController controller, ChunkEntry entry, ChunkStep targetStep) {
+        this.controller = controller;
+        this.entry = entry;
+        this.targetStep = targetStep;
+
+        // we don't want to do redundant work for generating neighbors if this chunk is already loaded
+        // the only exception for this is where the chunk step has an on-load task that need to run with context
+        this.fromStep = ChunkStep.min(this.targetStep, ChunkStep.MIN_WITH_LOAD_TASK.getPrevious());
+    }
+
+    @Nullable
+    @Override
+    public Result<ChunkUpgrade> poll(Waker waker) {
+        // this chunk is no longer valid to be upgraded to our target
+        if (!this.entry.isValidAs(this.targetStep)) {
+            return Result.error();
+        }
+
+        // we iterate downwards until we find a step that we can safely upgrade from
+        while (true) {
+            // we first need to collect all the required chunk entries
+            if (!this.collectedEntries) {
+                if (this.entries == null) {
+                    this.entries = new ChunkUpgradeEntries(ChunkUpgradeKernel.betweenSteps(this.fromStep, this.targetStep));
+                }
+
+                if (!this.pollCollectEntries(waker, this.entries)) {
+                    return null;
+                }
+
+                this.collectedEntries = true;
+            }
+
+            // we then need to load the relevant chunks from disk to test if this upgrade is valid
+            IChunkAccess[] chunks = this.pollLoadChunks(waker, this.entries);
+            if (chunks == null) {
+                return null;
+            }
+
+            ChunkStep newStep = this.tryStep(chunks);
+            if (newStep == null) {
+                // we've loaded enough context
+                this.notifyChunkLoads(chunks);
+                return Result.ok(new ChunkUpgrade(this.fromStep, this.targetStep, this.entries));
+            }
+
+            this.fromStep = newStep;
+
+            this.entries = null;
+            this.loadFutures = null;
+            this.loadedChunks = null;
+            this.collectedEntries = false;
+        }
+    }
+
+    private void notifyChunkLoads(IChunkAccess[] chunks) {
+        ChunkUpgradeKernel kernel = this.entries.kernel;
+        ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+        int radius = kernel.getRadius();
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                ChunkEntry entry = this.entries.getEntry(x, z);
+                if (entry.canUpgradeTo(this.fromStep)) {
+                    IChunkAccess chunk = chunks[kernel.index(x, z)];
+                    upgrader.notifyUpgradeOk(entry, this.fromStep, chunk);
+                }
+            }
+        }
+    }
+
+    @Nullable
+    private ChunkStep tryStep(IChunkAccess[] chunks) {
+        // we have reached the lowest step
+        if (this.fromStep == ChunkStep.EMPTY) {
+            return null;
+        }
+
+        ChunkStep minimumStep = this.getMinimumStepFor(chunks);
+
+        // the lowest step in this area is greater than or equal to the step we are trying to upgrade from
+        if (this.fromStep.lessOrEqual(minimumStep)) {
+            return null;
+        }
+
+        // we try upgrade from the lowest step in the area
+        return minimumStep;
+    }
+
+    @Nullable
+    private ChunkStep getMinimumStepFor(IChunkAccess[] chunks) {
+        ChunkStep minimumStep = ChunkStep.FULL;
+
+        for (IChunkAccess chunk : chunks) {
+            ChunkStep step = ChunkStep.byFullStatus(chunk.getChunkStatus());
+            if (step == ChunkStep.EMPTY) {
+                return ChunkStep.EMPTY;
+            }
+
+            if (step.lessThan(minimumStep)) {
+                minimumStep = step;
+            }
+        }
+
+        return minimumStep;
+    }
+
+    private boolean pollCollectEntries(Waker waker, ChunkUpgradeEntries entries) {
+        if (this.flushListener != null) {
+            if (this.flushListener.poll(waker) == null) {
+                return false;
+            } else {
+                this.flushListener = null;
+            }
+        }
+
+        while (true) {
+            ChunkAccess chunks = this.controller.getMap().visible();
+
+            // acquire a flush listener now so that we can be sure nothing has changed since we checked the entries
+            ChunkMap.FlushListener flushListener = this.controller.getMap().awaitFlush();
+
+            // not all of the required entries are loaded: wait for the entry list to update
+            if (!this.tryCollectEntries(chunks, entries)) {
+                // if a flush has happened since we last checked, try again now
+                if (flushListener.poll(waker) != null) {
+                    continue;
+                }
+
+                this.flushListener = flushListener;
+                return false;
+            }
+
+            // we have everything we need: we don't need to listen for flushes anymore
+            flushListener.invalidateWaker();
+
+            return true;
+        }
+    }
+
+    private boolean tryCollectEntries(ChunkAccess chunks, ChunkUpgradeEntries entries) {
+        int originX = this.entry.location.x;
+        int originZ = this.entry.location.z;
+
+        ChunkEntry[] array = this.entries.entries;
+        ChunkUpgradeKernel kernel = entries.kernel;
+        int radius = kernel.getRadius();
+
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                ChunkEntry entry = chunks.getEntry(x + originX, z + originZ);
+
+                // all chunk entries must be available before upgrading
+                if (entry == null) {
+                    Arrays.fill(array, null);
+                    return false;
+                }
+
+                array[kernel.index(x, z)] = entry;
+            }
+        }
+
+        return true;
+    }
+
+    @Nullable
+    private IChunkAccess[] pollLoadChunks(Waker waker, ChunkUpgradeEntries entries) {
+        ChunkUpgradeKernel kernel = entries.kernel;
+        int radius = kernel.getRadius();
+
+        if (this.loadFutures == null) {
+            this.loadFutures = kernel.create(Future[]::new);
+            this.loadedChunks = kernel.create(IChunkAccess[]::new);
+            ChunkUpgrader upgrader = this.controller.getUpgrader();
+
+            for (int z = -radius; z <= radius; z++) {
+                for (int x = -radius; x <= radius; x++) {
+                    ChunkEntry entry = entries.getEntry(x, z);
+
+                    ProtoChunk chunk = entry.getProtoChunk();
+                    if (chunk != null) {
+                        this.loadedChunks[kernel.index(x, z)] = chunk;
+                    } else {
+                        this.loadFutures[kernel.index(x, z)] = upgrader.loadChunk(entry);
+                    }
+                }
+            }
+        }
+
+        return JoinAllArray.poll(waker, this.loadFutures, this.loadedChunks);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/NullWaker.java b/src/main/java/net/gegy1000/tictacs/justnow/NullWaker.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c794431d3caa4dd25809254a246400ae0f1d7fd
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/NullWaker.java
@@ -0,0 +1,12 @@
+package net.gegy1000.tictacs.justnow;
+
+public final class NullWaker implements Waker {
+    public static final NullWaker INSTANCE = new NullWaker();
+
+    private NullWaker() {
+    }
+
+    @Override
+    public void wake() {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/SignalWaker.java b/src/main/java/net/gegy1000/tictacs/justnow/SignalWaker.java
new file mode 100644
index 0000000000000000000000000000000000000000..07de6d625e11df2f20c83da95f8699e6321e12e4
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/SignalWaker.java
@@ -0,0 +1,28 @@
+package net.gegy1000.tictacs.justnow;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class SignalWaker implements Waker {
+    private final Object signal = new Object();
+    private final AtomicBoolean signalled = new AtomicBoolean();
+
+    @Override
+    public void wake() {
+        synchronized (this.signal) {
+            this.signalled.set(true);
+            this.signal.notify();
+        }
+    }
+
+    public void awaitSignal() throws InterruptedException {
+        synchronized (this.signal) {
+            if (this.signalled.getAndSet(false)) {
+                return;
+            }
+
+            this.signal.wait();
+
+            this.signalled.set(false);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/Waker.java b/src/main/java/net/gegy1000/tictacs/justnow/Waker.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b08689ad5108b7f607d9ddc19911fbbf4abea29
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/Waker.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.justnow;
+
+public interface Waker {
+    void wake();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/CurrentThreadExecutor.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/CurrentThreadExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c55561880140d7830bd29441f7c275d1c87690a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/CurrentThreadExecutor.java
@@ -0,0 +1,33 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+
+import net.gegy1000.tictacs.justnow.NullWaker;
+import net.gegy1000.tictacs.justnow.SignalWaker;
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletionException;
+
+public final class CurrentThreadExecutor {
+    private static final ThreadLocal<SignalWaker> THREAD_WAKER = ThreadLocal.withInitial(SignalWaker::new);
+
+    public static <T> T blockOn(Future<T> future) {
+        try {
+            SignalWaker waker = THREAD_WAKER.get();
+
+            T result;
+            while ((result = future.poll(waker)) == null) {
+                waker.awaitSignal();
+            }
+
+            return result;
+        } catch (InterruptedException e) {
+            throw new CompletionException(e);
+        }
+    }
+
+    @Nullable
+    public static <T> T advance(Future<T> future) {
+        return future.poll(NullWaker.INSTANCE);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/LocalExecutor.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/LocalExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..183b7192f903c0a733a72428c50702b2a8816bd5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/LocalExecutor.java
@@ -0,0 +1,54 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+public final class LocalExecutor {
+    private final TaskQueue taskQueue = new TaskQueue();
+    private final Collection<Task<?>> drainBuffer = new ArrayList<>();
+
+    public <T> TaskHandle<T> spawn(Future<T> future) {
+        Task<T> task = new Task<>(future, this.taskQueue);
+        this.taskQueue.enqueue(task);
+        return task.handle;
+    }
+
+    public <T> Future<T> steal(TaskHandle<T> handle) {
+        this.taskQueue.remove(handle.task);
+        return handle.steal();
+    }
+
+    public boolean cancel(TaskHandle<?> handle) {
+        if (this.taskQueue.remove(handle.task)) {
+            handle.invalidate();
+            return true;
+        }
+        return false;
+    }
+
+    public void run() throws InterruptedException {
+        while (true) {
+            Task<?> task = this.taskQueue.take();
+            task.advance();
+        }
+    }
+
+    /**
+     * Attempts to advance all enqueued tasks on this executor
+     *
+     * @return if there are still tasks remaining in the queue
+     */
+    public boolean advanceAll() {
+        this.drainBuffer.clear();
+        this.taskQueue.drainTo(this.drainBuffer);
+
+        for (Task<?> task : this.drainBuffer) {
+            task.advance();
+        }
+
+        return !this.taskQueue.isEmpty();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/Task.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/Task.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a3d8098e32e4c5a543229f51f2991ca19d31479
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/Task.java
@@ -0,0 +1,48 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+final class Task<T> {
+    final Future<T> future;
+    final TaskQueue.Waker waker;
+
+    TaskHandle<T> handle;
+
+    private final AtomicBoolean invalidated = new AtomicBoolean(false);
+
+    Task(Future<T> future, TaskQueue taskQueue) {
+        this.future = future;
+        this.handle = new TaskHandle<>(this);
+        this.waker = taskQueue.waker(this);
+    }
+
+    void invalidate() {
+        this.invalidated.set(true);
+    }
+
+    boolean isInvalid() {
+        return this.invalidated.get();
+    }
+
+    void advance() {
+        if (this.isInvalid()) return;
+
+        try {
+            this.waker.polling();
+
+            T result = this.future.poll(this.waker);
+            if (result != null) {
+                this.invalidate();
+                this.handle.completeOk(result);
+            } else {
+                this.waker.ready();
+            }
+        } catch (Throwable exception) {
+            this.invalidate();
+            this.handle.completeErr(exception);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskHandle.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskHandle.java
new file mode 100644
index 0000000000000000000000000000000000000000..645b6561c1bf747b3746524c2c2d9d997264fe09
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskHandle.java
@@ -0,0 +1,34 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+
+import net.gegy1000.tictacs.justnow.future.Future;
+import net.gegy1000.tictacs.justnow.future.JoinHandle;
+public final class TaskHandle<T> extends JoinHandle<T> {
+    final Task<T> task;
+
+    TaskHandle(Task<T> task) {
+        this.task = task;
+    }
+
+    @Override
+    protected synchronized void completeOk(T result) {
+        super.completeOk(result);
+    }
+
+    @Override
+    protected synchronized void completeErr(Throwable exception) {
+        super.completeErr(exception);
+    }
+
+    void invalidate() {
+        this.task.invalidate();
+    }
+
+    Future<T> steal() {
+        this.task.invalidate();
+        if (this.result != null) {
+            return Future.ready(this.result);
+        }
+        return this.task.future;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskQueue.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..93eb4d811fac59254545fe896142cb22f56af72b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/TaskQueue.java
@@ -0,0 +1,80 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+import java.util.Collection;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public final class TaskQueue {
+    private final LinkedBlockingDeque<Task<?>> tasks = new LinkedBlockingDeque<>();
+
+    public void clear() {
+        this.tasks.clear();
+    }
+
+    public void enqueue(Task<?> task) {
+        if (task.isInvalid()) return;
+        this.tasks.add(task);
+    }
+
+    public boolean remove(Task<?> task) {
+        return this.tasks.remove(task);
+    }
+
+    public Task<?> take() throws InterruptedException {
+        return this.tasks.take();
+    }
+
+    public void drainTo(Collection<Task<?>> target) {
+        while (!this.tasks.isEmpty()) {
+            target.add(this.tasks.remove());
+        }
+    }
+
+    public boolean isEmpty() {
+        return this.tasks.isEmpty();
+    }
+
+    public Waker waker(Task task) {
+        return new Waker(task);
+    }
+
+    public class Waker implements net.gegy1000.tictacs.justnow.Waker {
+        static final int READY = 0;
+        static final int POLLING = 1;
+        static final int AWOKEN = 2;
+
+        private final Task<?> task;
+
+        final AtomicInteger state = new AtomicInteger(AWOKEN);
+
+        private Waker(Task<?> task) {
+            this.task = task;
+        }
+
+        @Override
+        public void wake() {
+            // if we are currently polling, set state to awoken and don't re-enqueue the task until we are ready again
+            if (this.state.compareAndSet(POLLING, AWOKEN)) {
+                return;
+            }
+
+            // if we are currently ready, set state to awoken and re-enqueue the task
+            if (this.state.compareAndSet(READY, AWOKEN)) {
+                TaskQueue.this.enqueue(this.task);
+            }
+        }
+
+        void polling() {
+            this.state.set(POLLING);
+        }
+
+        void ready() {
+            // we didn't get a result: set state to ready. we expect state to still be polling, so if that's not
+            // the case, we must've been awoken during polling. now that we know this task needs to continue
+            // execution, we can re-enqueue it.
+            if (!this.state.compareAndSet(Waker.POLLING, Waker.READY)) {
+                TaskQueue.this.enqueue(this.task);
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/executor/ThreadedExecutor.java b/src/main/java/net/gegy1000/tictacs/justnow/executor/ThreadedExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..79d5e46b2381ab3613f285861cf4165d3d7b8d28
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/executor/ThreadedExecutor.java
@@ -0,0 +1,74 @@
+package net.gegy1000.tictacs.justnow.executor;
+
+
+import net.gegy1000.tictacs.justnow.future.Future;
+
+import java.util.concurrent.ThreadFactory;
+
+public final class ThreadedExecutor implements AutoCloseable {
+    private final Worker[] workers;
+    private final TaskQueue taskQueue = new TaskQueue();
+
+    private boolean active = true;
+
+    public ThreadedExecutor(int threadCount, ThreadFactory factory) {
+        this.workers = new Worker[threadCount];
+        for (int i = 0; i < threadCount; i++) {
+            this.workers[i] = new Worker(factory);
+        }
+        for (Worker worker : this.workers) {
+            worker.start();
+        }
+    }
+
+    public <T> TaskHandle<T> spawn(Future<T> future) {
+        Task<T> task = new Task<>(future, this.taskQueue);
+        this.taskQueue.enqueue(task);
+        return task.handle;
+    }
+
+    public <T> Future<T> steal(TaskHandle<T> handle) {
+        this.taskQueue.remove(handle.task);
+        return handle.steal();
+    }
+
+    public boolean cancel(TaskHandle<?> handle) {
+        if (this.taskQueue.remove(handle.task)) {
+            handle.invalidate();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void close() {
+        this.active = false;
+        this.taskQueue.clear();
+        for (Worker worker : this.workers) {
+            worker.thread.interrupt();
+        }
+    }
+
+    private class Worker {
+        private final Thread thread;
+
+        Worker(ThreadFactory factory) {
+            this.thread = factory.newThread(this::drive);
+        }
+
+        public void start() {
+            this.thread.start();
+        }
+
+        private void drive() {
+            try {
+                while (ThreadedExecutor.this.active) {
+                    Task<?> task = ThreadedExecutor.this.taskQueue.take();
+                    task.advance();
+                }
+            } catch (InterruptedException e) {
+                // interrupted by executor
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/AndThen.java b/src/main/java/net/gegy1000/tictacs/justnow/future/AndThen.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a0e026c72a3a8d0a4758841cc75c1a8b1f8a51c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/AndThen.java
@@ -0,0 +1,33 @@
+package net.gegy1000.tictacs.justnow.future;
+
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.function.Function;
+
+final class AndThen<T, U> implements Future<U> {
+    private final Future<T> first;
+    private final Function<T, Future<U>> andThen;
+    private Future<U> thenFuture;
+
+    AndThen(Future<T> first, Function<T, Future<U>> andThen) {
+        this.first = first;
+        this.andThen = andThen;
+    }
+
+    @Override
+    public U poll(Waker waker) {
+        if (this.thenFuture == null) {
+            T poll = this.first.poll(waker);
+            if (poll != null) {
+                this.thenFuture = this.andThen.apply(poll);
+            }
+        }
+
+        if (this.thenFuture != null) {
+            return this.thenFuture.poll(waker);
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Cancelable.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Cancelable.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf35aee7b2506f43e7f3339f6ce42f011abe93f5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Cancelable.java
@@ -0,0 +1,32 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.concurrent.CancellationException;
+
+public final class Cancelable<T> implements Future<T> {
+    private final Future<T> inner;
+    private boolean canceled;
+
+    private Waker waker;
+
+    Cancelable(Future<T> inner) {
+        this.inner = inner;
+    }
+
+    @Override
+    public synchronized T poll(Waker waker) {
+        if (this.canceled) {
+            throw new CancellationException("task canceled");
+        }
+        this.waker = waker;
+        return this.inner.poll(waker);
+    }
+
+    public synchronized void cancel() {
+        this.canceled = true;
+        if (this.waker != null) {
+            this.waker.wake();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Future.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Future.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca017db64818037daa63dccbdd78225f674436a8
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Future.java
@@ -0,0 +1,203 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.tuple.Either;
+import net.gegy1000.tictacs.justnow.tuple.Two;
+
+import javax.annotation.Nullable;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * A Future is the most basic unit of asynchronous execution: it represents a value that will resolve at some point in
+ * the future.
+ *
+ * In this library, futures are driven by polling. This means that to get the output of a future, it needs to be asked
+ * whether it is ready or not. This means that the polling handler should never block: it should always return
+ * effectively immediately. For code that must block, use {@link net.gegy1000.tictacs.justnow.future.Future#spawnBlocking(java.util.concurrent.Executor, java.util.function.Supplier)}
+ *
+ * The biggest benefit of a polling-based design is the ability to drive multiple futures concurrently on a single
+ * thread. It is additionally possible to drive futures from a thread without consuming that thread. This removes any
+ * overhead from having lots of threads by allowing all the work to happen on a single thread.
+ *
+ * For long running tasks, it is not ideal to poll continually and cause the thread to spin and waste resources.
+ * This is solved by the {@link net.gegy1000.justnow.Waker} interface: when a future is polled, if it does not return a result, it should
+ * register the waker internally. When the future's result is ready, {@link net.gegy1000.justnow.Waker#wake()} should be called. If it is not
+ * called, the future will not be polled again.
+ * @see JoinHandle for a reference implementation of how to use wakers
+ *
+ * While it is possible to write a polling handler that does block, caution should be taken to avoid this as it can
+ * create unexpected inefficiency in execution by preventing futures from being run concurrently.
+ * @see net.gegy1000.tictacs.justnow.future.Future#poll(net.gegy1000.justnow.Waker) for more information on polling
+ *
+ * When a future is resolved is not guaranteed: a future may never become ready. For example, {@link net.gegy1000.tictacs.justnow.future.Future#pending()}
+ * will never resolve into a value.
+ *
+ * To drive a future, you generally do not want to be interacting with {@link net.gegy1000.tictacs.justnow.future.Future#poll(net.gegy1000.justnow.Waker)} directly. Rather, you
+ * should use an executor. In this library, 3 executors are provided out of the box:
+ * - {@link net.gegy1000.justnow.executor.CurrentThreadExecutor} provides utilities for driving and blocking on a future
+ * - {@link net.gegy1000.justnow.executor.LocalExecutor} allows running many futures concurrently on the local thread
+ * - {@link net.gegy1000.justnow.executor.ThreadedExecutor} allows running many futures concurrently on a thread pool
+ *
+ * @param <T> the type that this future will resolve to when ready
+ */
+public interface Future<T> {
+    /**
+     * Polls a future for its result.
+     * If the future is still pending a result, null should be returned
+     * If the future is ready, it should return its result
+     *
+     * Once this function has returned a non-null ready value, it should <b>not</b> be called again. Doing so may result
+     * in undefined behavior.
+     * To handle situations where you must do this, wrap the future with {@link net.gegy1000.tictacs.justnow.future.Future#maybeDone(net.gegy1000.tictacs.justnow.future.Future)}
+     *
+     * @param waker the waker to notify when this future becomes ready
+     * @return null if pending or T if ready
+     */
+    @Nullable
+    T poll(Waker waker);
+
+    /**
+     * Spawns a blocking task onto the given executor. The task is <b>not</b> allowed to return a null value, if it must
+     * return an optional value, use {@link java.util.Optional}.
+     *
+     * Returns a {@link JoinHandle} future which can be used to track the result of the task.
+     * <b>NB</b>: the handle is not attached to the execution of the task: it does not need to be polled in order for
+     * the task to be executed.
+     *
+     * A blocking task is one that should take a long time to execute or cannot return effectively instantly
+     *   @see net.gegy1000.tictacs.justnow.future.Future for further discussion around futures design
+     *
+     * @param executor the executor to execute the blocking task on
+     * @param supplier the blocking task
+     * @param <T> the future output type
+     *
+     * @return the handle for this task's execution
+     */
+    static <T> JoinHandle<T> spawnBlocking(Executor executor, Supplier<T> supplier) {
+        JoinHandle<T> handle = new JoinHandle<>();
+        executor.execute(() -> {
+            handle.setExecutingThread(Thread.currentThread());
+            T result = supplier.get();
+            handle.completeOk(result);
+        });
+        return handle;
+    }
+
+    /**
+     * Returns a future that will always be in a ready state with the given return value
+     *
+     * @param value the value to be ready with (cannot be null)
+     * @param <T> the future output type
+     * @return an always ready future
+     */
+    static <T> Future<T> ready(T value) {
+        if (value == null) throw new IllegalArgumentException("ready value cannot be null");
+        return new Ready<>(value);
+    }
+
+    /**
+     * Returns a future that will always be in the pending state. Polling will never return a ready result.
+     *
+     * @param <T> the future output type
+     * @return an always pending future
+     */
+    static <T> Future<T> pending() {
+        return new Pending<>();
+    }
+
+    /**
+     * Returns a future that lazily evaluates its result. Polling should return a ready result immediately, but the
+     * supplier will only be invoked when the future is polled.
+     *
+     * @param op the operator to lazily evaluate
+     * @param <T> the future output type
+     * @return a lazily evaluated future
+     */
+    static <T> Future<T> lazy(Supplier<T> op) {
+        return new Lazy<>(op);
+    }
+
+    /**
+     * Wraps a future allowing its execution to be canceled. When this future is canceled,
+     * it will yield a {@link java.util.concurrent.CancellationException} which must be handled
+     *
+     * @param future the future to wrap
+     * @param <T> the future output type
+     * @return a cancelable future
+     */
+    static <T> Cancelable<T> cancelable(Future<T> future) {
+        return new Cancelable<>(future);
+    }
+
+    /**
+     * Wraps a future allowing its result to be retrieved even after it has completed. A MaybeDone future should still
+     * be polled, however once it has completed, the result is accessible through {@link MaybeDone#getResult()}
+     *
+     * @param future the future to wrap
+     * @param <T> the future output type
+     * @return a MaybeDone future
+     */
+    static <T> MaybeDone<T> maybeDone(Future<T> future) {
+        return new MaybeDone<>(future);
+    }
+
+    static <A, B> Future<Two<A, B>> join2(Future<A> a, Future<B> b) {
+        return new Join2<>(a, b);
+    }
+
+    static <A, B, R> Future<Either<A, B>> select2(Future<A> a, Future<B> b) {
+        return new Select2<>(a, b);
+    }
+
+    static <T> Future<Collection<T>> joinAll(Collection<Future<T>> futures) {
+        return new JoinAll<>(futures);
+    }
+
+    static <T> Future<Collection<T>> joinAll(Stream<Future<T>> futures) {
+        return new JoinAll<>(futures.collect(Collectors.toCollection(LinkedList::new)));
+    }
+
+    static <K, V> Future<Map<K, V>> joinAll(Map<K, Future<V>> map) {
+        return new JoinAllMap<>(map);
+    }
+
+    static <T> Future<T> selectAll(Collection<Future<T>> futures) {
+        return new SelectAll<>(futures);
+    }
+
+    static <A, B, R> Future<R> map2(Future<A> a, Future<B> b, BiFunction<A, B, R> map) {
+        return new Map2<>(a, b, map);
+    }
+
+    static <A, B, R> Future<R> andThen2(Future<A> a, Future<B> b, BiFunction<A, B, Future<R>> andThen) {
+        return new Map2<>(a, b, andThen).andThen(f -> f);
+    }
+
+    default <U> Future<U> map(Function<T, U> map) {
+        return new Map1<>(this, map);
+    }
+
+    default <U> Future<U> andThen(Function<T, Future<U>> andThen) {
+        return new AndThen<>(this, andThen);
+    }
+
+    default <U> Future<U> handle(BiFunction<T, Throwable, U> handle) {
+        return new Handle<>(this, handle);
+    }
+
+    default <U> Future<Two<T, U>> join(Future<U> future) {
+        return new Join2<>(this, future);
+    }
+
+    default <U> Future<Either<T, U>> select(Future<U> future) {
+        return new Select2<>(this, future);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Handle.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Handle.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e3b5076f20fbd4797d4d3197b0344b19161b88d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Handle.java
@@ -0,0 +1,28 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.function.BiFunction;
+
+final class Handle<T, U> implements Future<U> {
+    private final Future<T> future;
+    private final BiFunction<T, Throwable, U> handle;
+
+    Handle(Future<T> future, BiFunction<T, Throwable, U> handle) {
+        this.future = future;
+        this.handle = handle;
+    }
+
+    @Override
+    public U poll(Waker waker) {
+        try {
+            T result = this.future.poll(waker);
+            if (result != null) {
+                return this.handle.apply(result, null);
+            }
+            return null;
+        } catch (Throwable t) {
+            return this.handle.apply(null, t);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Join2.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Join2.java
new file mode 100644
index 0000000000000000000000000000000000000000..08d6c9deab2bf5b0fadf64dc8d6f806f1a0e68c5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Join2.java
@@ -0,0 +1,26 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.tuple.Two;
+
+final class Join2<A, B> implements Future<Two<A, B>> {
+    private final MaybeDone<A> a;
+    private final MaybeDone<B> b;
+
+    Join2(Future<A> a, Future<B> b) {
+        this.a = Future.maybeDone(a);
+        this.b = Future.maybeDone(b);
+    }
+
+    @Override
+    public Two<A, B> poll(Waker waker) {
+        this.a.poll(waker);
+        this.b.poll(waker);
+
+        if (this.a.isDone() && this.b.isDone()) {
+            return Two.of(this.a.getResult(), this.b.getResult());
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAll.java b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAll.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b96f5d3314cba2fc3a3ddd66ce6b16c47937a12
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAll.java
@@ -0,0 +1,35 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+final class JoinAll<T> implements Future<Collection<T>> {
+    private final Collection<Future<T>> futures;
+    private final Collection<T> result;
+
+    JoinAll(Collection<Future<T>> futures) {
+        this.futures = futures;
+        this.result = new ArrayList<>(futures.size());
+    }
+
+    @Override
+    public Collection<T> poll(Waker waker) {
+        Iterator<Future<T>> iterator = this.futures.iterator();
+        while (iterator.hasNext()) {
+            Future<T> future = iterator.next();
+            T poll = future.poll(waker);
+            if (poll != null) {
+                this.result.add(poll);
+                iterator.remove();
+            }
+        }
+        if (this.futures.isEmpty()) {
+            return this.result;
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAllMap.java b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAllMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..191287f62e38da120c9d67ff0490955cedb119b5
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinAllMap.java
@@ -0,0 +1,36 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.HashMap;
+import java.util.Map;
+
+final class JoinAllMap<K, V> implements Future<Map<K, V>> {
+    private final Map<K, Future<V>> futures;
+    private final Map<K, V> result;
+
+    JoinAllMap(Map<K, Future<V>> futures) {
+        this.futures = futures;
+        this.result = new HashMap<>(futures.size());
+    }
+
+    @Override
+    public Map<K, V> poll(Waker waker) {
+        for (Map.Entry<K, Future<V>> entry : this.futures.entrySet()) {
+            if (this.result.containsKey(entry.getKey())) {
+                continue;
+            }
+
+            V poll = entry.getValue().poll(waker);
+            if (poll != null) {
+                this.result.put(entry.getKey(), poll);
+            }
+        }
+
+        if (this.result.size() >= this.futures.size()) {
+            return this.result;
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/JoinHandle.java b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinHandle.java
new file mode 100644
index 0000000000000000000000000000000000000000..549915480d695f30d3cc9ed04e96ef0a4288ecdd
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/JoinHandle.java
@@ -0,0 +1,75 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import javax.annotation.Nullable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletionException;
+
+public class JoinHandle<T> implements Future<T> {
+    protected T result;
+    protected Throwable exception;
+
+    protected Thread executingThread;
+    protected Waker waker;
+
+    @Nullable
+    @Override
+    public synchronized T poll(Waker waker) {
+        this.waker = waker;
+        if (this.exception != null) {
+            throw encodeException(this.exception);
+        }
+        return this.result;
+    }
+
+    public synchronized void cancel() {
+        this.cancel(new CancellationException("task canceled"));
+    }
+
+    public synchronized void cancel(Throwable exception) {
+        this.exception = exception;
+        if (this.waker != null) {
+            this.waker.wake();
+        }
+        if (this.executingThread != null) {
+            this.executingThread.interrupt();
+        }
+    }
+
+    public synchronized boolean isDone() {
+        return this.result != null || this.exception != null;
+    }
+
+    protected synchronized void setExecutingThread(Thread executingThread) {
+        this.executingThread = executingThread;
+    }
+
+    protected synchronized void completeOk(T result) {
+        if (result == null) throw new IllegalArgumentException("cannot complete with null result");
+        if (this.isDone()) throw new IllegalStateException("already completed");
+
+        this.result = result;
+        if (this.waker != null) {
+            this.waker.wake();
+        }
+    }
+
+    protected synchronized void completeErr(Throwable exception) {
+        if (exception == null) throw new IllegalArgumentException("cannot complete with null exception");
+        if (this.isDone()) throw new IllegalStateException("already completed");
+
+        this.exception = exception;
+        if (this.waker != null) {
+            this.waker.wake();
+        }
+    }
+
+    private static CompletionException encodeException(Throwable exception) {
+        if (exception instanceof CompletionException) {
+            return (CompletionException) exception;
+        } else {
+            return new CompletionException(exception);
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Lazy.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Lazy.java
new file mode 100644
index 0000000000000000000000000000000000000000..54cc20ddba31ef9036d6a3e3f441fbfe86a3eac2
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Lazy.java
@@ -0,0 +1,18 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.function.Supplier;
+
+final class Lazy<T> implements Future<T> {
+    private final Supplier<T> op;
+
+    Lazy(Supplier<T> op) {
+        this.op = op;
+    }
+
+    @Override
+    public T poll(Waker waker) {
+        return this.op.get();
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Map1.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Map1.java
new file mode 100644
index 0000000000000000000000000000000000000000..76e1477eb754dbc0b17fdc22829987c98d60c435
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Map1.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.function.Function;
+
+final class Map1<T, U> implements Future<U> {
+    private final Future<T> future;
+    private final Function<T, U> map;
+
+    Map1(Future<T> a, Function<T, U> map) {
+        this.future = a;
+        this.map = map;
+    }
+
+    @Override
+    public U poll(Waker waker) {
+        T poll = this.future.poll(waker);
+        if (poll != null) {
+            return this.map.apply(poll);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Map2.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Map2.java
new file mode 100644
index 0000000000000000000000000000000000000000..3668296e99dc46df8b43be30155a305b6b3b2086
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Map2.java
@@ -0,0 +1,29 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.function.BiFunction;
+
+final class Map2<A, B, R> implements Future<R> {
+    private final MaybeDone<A> a;
+    private final MaybeDone<B> b;
+    private final BiFunction<A, B, R> map;
+
+    Map2(Future<A> a, Future<B> b, BiFunction<A, B, R> map) {
+        this.a = Future.maybeDone(a);
+        this.b = Future.maybeDone(b);
+        this.map = map;
+    }
+
+    @Override
+    public R poll(Waker waker) {
+        this.a.poll(waker);
+        this.b.poll(waker);
+
+        if (this.a.isDone() && this.b.isDone()) {
+            return this.map.apply(this.a.getResult(), this.b.getResult());
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/MaybeDone.java b/src/main/java/net/gegy1000/tictacs/justnow/future/MaybeDone.java
new file mode 100644
index 0000000000000000000000000000000000000000..532e43b40535f29bf93faf97110ad613da2e1350
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/MaybeDone.java
@@ -0,0 +1,32 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.tuple.Unit;
+
+import javax.annotation.Nullable;
+
+public final class MaybeDone<T> implements Future<Unit> {
+    private final Future<T> future;
+    private T result;
+
+    MaybeDone(Future<T> future) {
+        this.future = future;
+    }
+
+    @Override
+    public Unit poll(Waker waker) {
+        if (this.result == null) {
+            this.result = this.future.poll(waker);
+        }
+        return this.isDone() ? Unit.INSTANCE : null;
+    }
+
+    @Nullable
+    public T getResult() {
+        return this.result;
+    }
+
+    public boolean isDone() {
+        return this.result != null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Pending.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Pending.java
new file mode 100644
index 0000000000000000000000000000000000000000..304e4075a6d8466265c8e45b39a45882f0729a4f
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Pending.java
@@ -0,0 +1,10 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+final class Pending<T> implements Future<T> {
+    @Override
+    public T poll(Waker waker) {
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Ready.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Ready.java
new file mode 100644
index 0000000000000000000000000000000000000000..72b34fd7997b6f073f894ab82283584d2941441c
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Ready.java
@@ -0,0 +1,16 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+final class Ready<T> implements Future<T> {
+    private final T value;
+
+    Ready(T value) {
+        this.value = value;
+    }
+
+    @Override
+    public T poll(Waker waker) {
+        return this.value;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/Select2.java b/src/main/java/net/gegy1000/tictacs/justnow/future/Select2.java
new file mode 100644
index 0000000000000000000000000000000000000000..15aeb636130f8e8996674568e6a82bacb61de93d
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/Select2.java
@@ -0,0 +1,28 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+import net.gegy1000.tictacs.justnow.tuple.Either;
+
+final class Select2<A, B> implements Future<Either<A, B>> {
+    private final MaybeDone<A> a;
+    private final MaybeDone<B> b;
+
+    Select2(Future<A> a, Future<B> b) {
+        this.a = Future.maybeDone(a);
+        this.b = Future.maybeDone(b);
+    }
+
+    @Override
+    public Either<A, B> poll(Waker waker) {
+        this.a.poll(waker);
+        this.b.poll(waker);
+
+        if (this.a.isDone()) {
+            return Either.a(this.a.getResult());
+        } else if (this.b.isDone()) {
+            return Either.b(this.b.getResult());
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/future/SelectAll.java b/src/main/java/net/gegy1000/tictacs/justnow/future/SelectAll.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b8cfda73605c2d4e56fb756bab6526aa01a68ba
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/future/SelectAll.java
@@ -0,0 +1,24 @@
+package net.gegy1000.tictacs.justnow.future;
+
+import net.gegy1000.tictacs.justnow.Waker;
+
+import java.util.Collection;
+
+final class SelectAll<T> implements Future<T> {
+    private final Collection<Future<T>> futures;
+
+    SelectAll(Collection<Future<T>> futures) {
+        this.futures = futures;
+    }
+
+    @Override
+    public T poll(Waker waker) {
+        for (Future<T> future : this.futures) {
+            T poll = future.poll(waker);
+            if (poll != null) {
+                return poll;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/tuple/Either.java b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Either.java
new file mode 100644
index 0000000000000000000000000000000000000000..2437bf2ce065e763b0aa156310c96b0d94da008a
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Either.java
@@ -0,0 +1,41 @@
+package net.gegy1000.tictacs.justnow.tuple;
+
+import javax.annotation.Nullable;
+
+public final class Either<A, B> {
+    private final A a;
+    private final B b;
+
+    private Either(A a, B b) {
+        this.a = a;
+        this.b = b;
+    }
+
+    public static <A, B> Either<A, B> a(A a) {
+        if (a == null) throw new IllegalArgumentException("A cannot be null");
+        return new Either<>(a, null);
+    }
+
+    public static <A, B> Either<A, B> b(B b) {
+        if (b == null) throw new IllegalArgumentException("B cannot be null");
+        return new Either<>(null, b);
+    }
+
+    public boolean isA() {
+        return this.a != null;
+    }
+
+    public boolean isB() {
+        return this.b != null;
+    }
+
+    @Nullable
+    public A getA() {
+        return this.a;
+    }
+
+    @Nullable
+    public B getB() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/tuple/Two.java b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Two.java
new file mode 100644
index 0000000000000000000000000000000000000000..f511fb0784fe6ae9c136c32398ba31a11f19a575
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Two.java
@@ -0,0 +1,15 @@
+package net.gegy1000.tictacs.justnow.tuple;
+
+public final class Two<A, B> {
+    public final A a;
+    public final B b;
+
+    private Two(A a, B b) {
+        this.a = a;
+        this.b = b;
+    }
+
+    public static <A, B> Two<A, B> of(A a, B b) {
+        return new Two<>(a, b);
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/justnow/tuple/Unit.java b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Unit.java
new file mode 100644
index 0000000000000000000000000000000000000000..49ed552ac743afb33eec3bc2c60995b65e18d72b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/justnow/tuple/Unit.java
@@ -0,0 +1,8 @@
+package net.gegy1000.tictacs.justnow.tuple;
+
+public final class Unit {
+    public static final Unit INSTANCE = new Unit();
+
+    private Unit() {
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb0c8e04da57c8b5c885536261123637540d83c6
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutor.java
@@ -0,0 +1,97 @@
+package net.gegy1000.tictacs.lighting;
+import net.minecraft.server.LightEngine;
+import net.minecraft.server.LightEngineThreaded;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+
+// TODO: consolidate lighting workers?
+public final class LightingExecutor implements Runnable, AutoCloseable {
+    private final LightEngine lightingProvider;
+
+    private volatile Queues queues = new Queues();
+    private volatile Queues processingQueues = new Queues();
+
+    private final Thread thread;
+    private volatile boolean closed;
+
+    private final AtomicBoolean parked = new AtomicBoolean();
+
+    public LightingExecutor(LightEngine lightingProvider) {
+        this.lightingProvider = lightingProvider;
+
+        this.thread = new Thread(this);
+        this.thread.setName("lighting-worker");
+        this.thread.setDaemon(true);
+        this.thread.start();
+    }
+
+    public void enqueue(Runnable task, LightEngineThreaded.Update stage) {
+        this.queues.enqueue(task, stage);
+        this.wake();
+    }
+
+    public void wake() {
+        if (this.hasTasks() && this.parked.compareAndSet(true, false)) {
+            LockSupport.unpark(this.thread);
+        }
+    }
+
+    @Override
+    public void run() {
+        while (!this.closed) {
+            if (this.hasTasks()) {
+                Queues queues = this.queues;
+                this.queues = this.processingQueues;
+                this.processingQueues = queues;
+
+                this.runTasks(queues);
+            } else {
+                this.parked.set(true);
+                LockSupport.park();
+            }
+        }
+    }
+
+    private boolean hasTasks() {
+        return !this.queues.isEmpty() || this.lightingProvider.a();
+    }
+
+    private void runTasks(Queues queues) {
+        this.processQueue(queues.preUpdate);
+        this.lightingProvider.a(Integer.MAX_VALUE, true, true);
+        this.processQueue(queues.postUpdate);
+    }
+
+    private void processQueue(Queue<Runnable> queue) {
+        Runnable task;
+        while ((task = queue.poll()) != null) {
+            task.run();
+        }
+    }
+
+    @Override
+    public void close() {
+        this.closed = true;
+        this.wake();
+    }
+
+    private static class Queues {
+        final Queue<Runnable> preUpdate = new ConcurrentLinkedQueue<>();
+        final Queue<Runnable> postUpdate = new ConcurrentLinkedQueue<>();
+
+        void enqueue(Runnable task, LightEngineThreaded.Update stage) {
+            if (stage == LightEngineThreaded.Update.PRE_UPDATE) {
+                this.preUpdate.add(task);
+            } else {
+                this.postUpdate.add(task);
+            }
+        }
+
+        boolean isEmpty() {
+            return this.preUpdate.isEmpty() && this.postUpdate.isEmpty();
+        }
+    }
+}
diff --git a/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2379a0bf52ea416dd7343d46dd4f014fd90a758
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/lighting/LightingExecutorHolder.java
@@ -0,0 +1,5 @@
+package net.gegy1000.tictacs.lighting;
+
+public interface LightingExecutorHolder {
+    LightingExecutor getLightingExecutor();
+}
diff --git a/src/main/java/net/gegy1000/tictacs/util/NbtType.java b/src/main/java/net/gegy1000/tictacs/util/NbtType.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b5e5e2dad532916c7c2682fcf522a69aa5171c6
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/util/NbtType.java
@@ -0,0 +1,33 @@
+package net.gegy1000.tictacs.util;
+
+/**
+ * NBT type ID constants. Useful for filtering by value type in a few cases.
+ *
+ *
+ * @see net.minecraft.server.NBTTagCompound#hasKeyOfType(String, int)
+ * @see net.minecraft.server.NBTTagTypes#a(int)
+ */
+public final class NbtType {
+    public static final int END = 0;
+    public static final int BYTE = 1;
+    public static final int SHORT = 2;
+    public static final int INT = 3;
+    public static final int LONG = 4;
+    public static final int FLOAT = 5;
+    public static final int DOUBLE = 6;
+    public static final int BYTE_ARRAY = 7;
+    public static final int STRING = 8;
+    public static final int LIST = 9;
+    public static final int COMPOUND = 10;
+    public static final int INT_ARRAY = 11;
+    public static final int LONG_ARRAY = 12;
+
+    /**
+     * Any numeric value: byte, short, int, long, float, double.
+     *
+     * @see net.minecraft.server.NBTTagCompound#hasKeyOfType(String, int)
+     */
+    public static final int NUMBER = 99;
+
+    private NbtType() { }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/util/PlayerStream.java b/src/main/java/net/gegy1000/tictacs/util/PlayerStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ddb6e6182508d998b531ed3606d535c81007d4b
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/util/PlayerStream.java
@@ -0,0 +1,34 @@
+package net.gegy1000.tictacs.util;
+
+import java.util.stream.Stream;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.TileEntity;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+
+
+/**
+ * Helper streams for looking up players on a server.
+ *
+ * <p>In general, most of these methods will only function with a {@link net.minecraft.server.WorldServer} instance.
+ *
+ */
+public final class PlayerStream {
+    private PlayerStream() { }
+
+
+    public static Stream<EntityHuman> world(World world) {
+        if (world instanceof WorldServer) {
+            // noinspection unchecked,rawtypes
+            return ((Stream) ((WorldServer) world).getPlayers().stream());
+        } else {
+            throw new RuntimeException("Only supported on WorldServer!");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java b/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..00fbe5c9970079e90ee04dd4e38c1ecda6509d20
--- /dev/null
+++ b/src/main/java/net/gegy1000/tictacs/util/UnsafeAccess.java
@@ -0,0 +1,23 @@
+package net.gegy1000.tictacs.util;
+
+import sun.misc.Unsafe;
+
+import java.lang.reflect.Field;
+
+public final class UnsafeAccess {
+    private static final Unsafe INSTANCE = getUnsafe();
+
+    private static Unsafe getUnsafe() {
+        try {
+            Field field = Unsafe.class.getDeclaredField("theUnsafe");
+            field.setAccessible(true);
+            return (Unsafe) field.get(null);
+        } catch (ReflectiveOperationException e) {
+            throw new Error("failed to access unsafe", e);
+        }
+    }
+
+    public static Unsafe get() {
+        return INSTANCE;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 7eb7ef891034f3e4ea5110ce9adcea0e7d589646..eea2a066e156793b78a2cf41c13f0fcf0a5cb478 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -29,6 +29,9 @@ import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 // Tuinity end
 
 public class ChunkProviderServer extends IChunkProvider {
+    public PlayerChunkMap.a ticketManager;
+    private final LossyChunkCache fastCache = new LossyChunkCache(32);
+
 
     private static final List<ChunkStatus> b = ChunkStatus.a(); static final List<ChunkStatus> getPossibleChunkStatuses() { return ChunkProviderServer.b; } // Paper - OBFHELPER
     private final ChunkMapDistance chunkMapDistance;
@@ -406,9 +409,47 @@ public class ChunkProviderServer extends IChunkProvider {
         return this.lightEngine;
     }
 
+    private Chunk getOrCreateChunkOnThread(int x, int z, ChunkStep step) {
+        // first we test if the chunk already exists in our small cache
+        Chunk cached = this.fastCache.get(x, z, step);
+        if (cached != null) {
+            return cached;
+        }
+
+        // if it does not exist, try load it from the chunk entry
+        ChunkEntry entry = this.getChunkEntry(x, z);
+        Chunk chunk = this.getExistingChunkFor(entry, step);
+
+        // the chunk is not ready, we must interface and join the chunk future
+        if (chunk == null) {
+            Either<Chunk, ChunkHolder.Unloaded> result = this.joinFuture(this.createChunk(x, z, step));
+
+            chunk = result.map(
+                    Function.identity(),
+                    err -> { throw new IllegalStateException("Chunk not there when requested: " + err); }
+            );
+        }
+
+        this.fastCache.put(x, z, step, chunk);
+
+        return chunk;
+    }
+
     @Nullable
-    private PlayerChunk getChunk(long i) {
-        return this.playerChunkMap.getVisibleChunk(i);
+    // private PlayerChunk getChunk(long i) {
+    //     return this.playerChunkMap.getVisibleChunk(i);
+    // }
+    public Chunk getChunk(int x, int z, ChunkStatus status, boolean create) {
+        ChunkStep step = ChunkStep.byStatus(status);
+        if (create) {
+            if (Thread.currentThread() != this.serverThread) {
+                return this.getOrCreateChunkOffThread(x, z, step);
+            } else {
+                return this.getOrCreateChunkOnThread(x, z, step);
+            }
+        } else {
+            return this.getExistingChunk(x, z, step);
+        }
     }
 
     public int b() {
@@ -705,9 +746,12 @@ public class ChunkProviderServer extends IChunkProvider {
     }
 
     private void clearCache() {
+        this.fastCache.clear();
+        /*
         Arrays.fill(this.cachePos, ChunkCoordIntPair.a);
         Arrays.fill(this.cacheStatus, (Object) null);
         Arrays.fill(this.cacheChunk, (Object) null);
+        */
     }
 
     private long syncLoadCounter; // Tuinity - prevent plugin unloads from removing our ticket
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index ad06bd81eded5d60f16c2d0ad1a4390f4b5a11a5..d8c18b1d364646114891ca405c8d8ffbcc8d31cf 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -20,8 +20,8 @@ import org.bukkit.event.player.PlayerVelocityEvent;
 public class EntityTrackerEntry {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final WorldServer b;
-    private final Entity tracker;
+    public final WorldServer b;
+    public final Entity tracker;
     private final int d;
     private final boolean e;
     private final Consumer<Packet<?>> f; private Consumer<Packet<?>> getPacketConsumer() { return f; } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
index 7a35a367a5840fd5df72b0bd64e630197562f160..a0821def1a0120fb8aaa2c92045d385fce8906a3 100644
--- a/src/main/java/net/minecraft/server/EntityTypes.java
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -129,8 +129,8 @@ public class EntityTypes<T extends Entity> {
     private final boolean bj;
     private final boolean bk;
     private final boolean bl;
-    private final int bm;
-    private final int bn;
+    public final int bm;
+    public final int bn;
     @Nullable
     private String bo;
     @Nullable
diff --git a/src/main/java/net/minecraft/server/LightEngineThreaded.java b/src/main/java/net/minecraft/server/LightEngineThreaded.java
index 4d6663b3b4118f1b7f655c7b4a31d89a98e0d18f..5a361fea94d1b19db2f44932ad33b71267ade38a 100644
--- a/src/main/java/net/minecraft/server/LightEngineThreaded.java
+++ b/src/main/java/net/minecraft/server/LightEngineThreaded.java
@@ -619,7 +619,7 @@ public class LightEngineThreaded extends LightEngine implements AutoCloseable {
         this.f = i;
     }
 
-    static enum Update {
+    public static enum Update {
 
         PRE_UPDATE, POST_UPDATE;
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index ac82f1791ce07e9a23cf97ca34974ab25e26be46..7b0690b8f98f1121c2816b8c3fdc34a472a3f4d0 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -22,7 +22,7 @@ public class PlayerChunk {
     private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.a();
     private static final PlayerChunk.State[] CHUNK_STATES = PlayerChunk.State.values();
     boolean isUpdateQueued = false; // Paper
-    private final AtomicReferenceArray<CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> statusFutures;
+    public final AtomicReferenceArray<CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> statusFutures;
     private volatile CompletableFuture<Either<Chunk, PlayerChunk.Failure>> fullChunkFuture; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
     private volatile CompletableFuture<Either<Chunk, PlayerChunk.Failure>> tickingFuture; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
     private volatile CompletableFuture<Either<Chunk, PlayerChunk.Failure>> entityTickingFuture; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
@@ -335,7 +335,7 @@ public class PlayerChunk {
     }
 
     @Nullable
-    public final Chunk getChunk() { // Paper - final for inline
+    public Chunk getChunk() { // Paper - final for inline
         CompletableFuture<Either<Chunk, PlayerChunk.Failure>> completablefuture = this.a();
         Either<Chunk, PlayerChunk.Failure> either = (Either) completablefuture.getNow(null); // CraftBukkit - decompile error
 
@@ -466,7 +466,7 @@ public class PlayerChunk {
     }
 
     public void sendPacketToTrackedPlayers(Packet<?> packet, boolean flag) { a(packet, flag); } // Paper - OBFHELPER
-    private void a(Packet<?> packet, boolean flag) {
+    public void a(Packet<?> packet, boolean flag) {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
@@ -535,7 +535,7 @@ public class PlayerChunk {
         }
     }
 
-    private void a(CompletableFuture<? extends Either<? extends IChunkAccess, PlayerChunk.Failure>> completablefuture) {
+    public void a(CompletableFuture<? extends Either<? extends IChunkAccess, PlayerChunk.Failure>> completablefuture) {
         this.chunkSave = this.chunkSave.thenCombine(completablefuture, (ichunkaccess, either) -> {
             return (IChunkAccess) either.map((ichunkaccess1) -> {
                 return ichunkaccess1;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 13948d6225efc4bbac87788d970d00e6a62586a1..b4fe457d986a4f48eab650194ee69aaa59b7b2b6 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -54,8 +54,117 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.entity.Player; // CraftBukkit
 import org.spigotmc.AsyncCatcher;
+// Titanium start - tic-tacs imports
+import net.minecraft.server.WorldLoadListener;
+import net.gegy1000.tictacs.VoidActor;
+import net.gegy1000.tictacs.async.worker.ChunkMainThreadExecutor;
+import net.gegy1000.tictacs.chunk.ChunkAccess;
+import net.gegy1000.tictacs.chunk.ChunkController;
+import net.gegy1000.tictacs.chunk.ChunkLevelTracker;
+import net.gegy1000.tictacs.chunk.ChunkMap;
+import net.gegy1000.tictacs.chunk.entry.ChunkEntry;
+import net.gegy1000.tictacs.chunk.entry.ChunkListener;
+import net.gegy1000.tictacs.chunk.future.AwaitAll;
+import net.gegy1000.tictacs.chunk.future.ChunkNotLoadedFuture;
+import net.gegy1000.tictacs.chunk.future.LazyRunnableFuture;
+import net.gegy1000.tictacs.chunk.future.VanillaChunkFuture;
+import net.gegy1000.tictacs.chunk.step.ChunkStep;
+import net.gegy1000.tictacs.chunk.tracker.ChunkTracker;
+import net.gegy1000.tictacs.chunk.upgrade.ChunkUpgrader;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.gegy1000.tictacs.justnow.future.Future;
+// Titanium end - tic-tacs imports
+
+
+public abstract class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d, ChunkController {
+    // Titanium start - tic-tacs
+    public IAsyncTaskHandler<Runnable> mainThreadExecutor;
+    public LightEngineThreaded lightEngineThreaded;
+    public PlayerChunkMap.a ticketManager;
+    public AtomicInteger totalChunksLoadedCount;
+    public int watchDistance;
+    public ChunkMap map = new ChunkMap(world, this);
+    public ChunkUpgrader upgrader = new ChunkUpgrader(world, this, chunkGenerator, structures, lighting);
+    public ChunkTracker tracker = new ChunkTracker(world, this);
+    public ChunkLevelTracker levelTracker = new ChunkLevelTracker(world, this);
+    public ChunkMainThreadExecutor chunkMainExecutor = new ChunkMainThreadExecutor(mainThread);
+    public LightEngineThreaded lighting = this.lightengineThreaded;
+
+    // tracker.PlayerChunkMap.a(watchDistance);
+
+    // map.addListener(tracker);
+    
+    private ThreadedMailbox<Runnable> createWorldgenActor(Executor executor, String name) {
+        return new VoidActor(name);
+    }
+
+    public ChunkMap getMap() {
+        return this.map;
+    }
+    
+    public ChunkUpgrader getUpgrader() {
+        return this.upgrader;
+    }
+
+    public ChunkTracker getTracker() {
+        return this.tracker;
+    }
+
+    public ChunkListener getChunkAs(ChunkEntry entry, ChunkStep step) {
+        this.upgrader.spawnUpgradeTo(entry, step);
+        return entry.getListenerFor(step);
+    }
+
+    public Future<Unit> getRadiusAs(ChunkCoordIntPair pos, int radius, ChunkStep step) {
+        ChunkAccess chunks = this.map.visible();
+
+        ChunkMap.FlushListener flushListener = this.map.awaitFlush();
+
+        int size = radius * 2 + 1;
+        Future<Chunk>[] futures = new Future[size * size];
+        for (int z = -radius; z <= radius; z++) {
+            for (int x = -radius; x <= radius; x++) {
+                int idx = (x + radius) + (z + radius) * size;
+                ChunkEntry entry = chunks.getEntry(pos.x + x, pos.z + z);
+                if (entry == null) {
+                    return flushListener.andThen(unit -> this.getRadiusAs(pos, radius, step));
+                }
+
+                if (entry.isValidAs(step)) {
+                    this.upgrader.spawnUpgradeTo(entry, step);
+                    futures[idx] = entry.getListenerFor(step);
+                } else {
+                    return ChunkNotLoadedFuture.get();
+                }
+            }
+        }
+
+        flushListener.invalidateWaker();
+
+        return AwaitAll.of(futures);
+    }
+
+    // public Future<Chunk> spawnLoadChunk(ChunkEntry entry) {
+    //     return VanillaChunkFuture.of(this.loadChunk(entry.getPos()));
+    // }
+
+    public void notifyStatus(ChunkCoordIntPair pos, ChunkStatus status) {
+        this.worldGenerationProgressListener.setChunkStatus(pos, status);
+    }
+
+    public <T> void spawnOnMainThread(ChunkEntry entry, Future<T> future) {
+        this.chunkMainExecutor.spawn(entry, future);
+    }
+
+    public void spawnOnMainThread(ChunkEntry entry, Runnable runnable) {
+        this.chunkMainExecutor.spawn(entry, new LazyRunnableFuture(runnable));
+    }
+
+    private ObjectCollection<?> getChunks(Long2ObjectLinkedOpenHashMap<?> map) {
+        return this.map.primary().getEntries();
+    }
+    // Titanium end
 
-public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
@@ -453,17 +562,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     return;
                 }
 
-                ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(rangeX, rangeZ);
-                PlayerChunkMap.this.world.getChunkProvider().addTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
+                ChunkCoordIntPair ChunkCoordIntPair = new ChunkCoordIntPair(rangeX, rangeZ);
+                PlayerChunkMap.this.world.getChunkProvider().addTicketAtLevel(TicketType.PLAYER, ChunkCoordIntPair, 31, ChunkCoordIntPair); // entity ticking level, TODO check on update
             },
             (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
                 if (newState != null) {
                     return;
                 }
-                ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(rangeX, rangeZ);
-                PlayerChunkMap.this.world.getChunkProvider().removeTicketAtLevel(TicketType.PLAYER, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
-                PlayerChunkMap.this.world.getChunkProvider().clearPriorityTickets(chunkPos);
+                ChunkCoordIntPair ChunkCoordIntPair = new ChunkCoordIntPair(rangeX, rangeZ);
+                PlayerChunkMap.this.world.getChunkProvider().removeTicketAtLevel(TicketType.PLAYER, ChunkCoordIntPair, 31, ChunkCoordIntPair); // entity ticking level, TODO check on update
+                PlayerChunkMap.this.world.getChunkProvider().clearPriorityTickets(ChunkCoordIntPair);
             }, (player, prevPos, newPos) -> {
             player.lastHighPriorityChecked = -1; // reset and recheck
             checkHighPriorityChunks(player);
@@ -631,7 +740,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return entityPlayer.mobCounts[enumCreatureType.ordinal()];
     }
 
-    private static double getDistanceSquaredFromChunk(ChunkCoordIntPair chunkPos, Entity entity) { return a(chunkPos, entity); } // Paper - OBFHELPER
+    private static double getDistanceSquaredFromChunk(ChunkCoordIntPair ChunkCoordIntPair, Entity entity) { return a(ChunkCoordIntPair, entity); } // Paper - OBFHELPER
     private static double a(ChunkCoordIntPair chunkcoordintpair, Entity entity) {
         double d0 = (double) (chunkcoordintpair.x * 16 + 8);
         double d1 = (double) (chunkcoordintpair.z * 16 + 8);
@@ -823,13 +932,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> b(ChunkCoordIntPair chunkcoordintpair) {
-        return this.a(chunkcoordintpair, 2, (i) -> {
-            return ChunkStatus.FULL;
-        }).thenApplyAsync((either) -> {
-            return either.mapLeft((list) -> {
-                return (Chunk) list.get(list.size() / 2);
-            });
-        }, this.mainInvokingExecutor); // Paper
+        // Titanium start - tic-tacs
+        CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> future = new CompletableFuture<>();
+
+        ChunkEntry entry = this.map.primary().getEntry(chunkcoordintpair);
+
+        this.spawnOnMainThread(entry, this.getRadiusAs(pos, 2, ChunkStep.FULL).handle((ok, err) -> {
+            if (err == null && entry.getWorldChunk() != null) {
+                future.complete(Either.left(entry.getWorldChunk()));
+            } else {
+                future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+            }
+            return Unit.INSTANCE;
+        }));
+
+        return future;
+        // Titanium start
     }
 
     @Nullable
@@ -875,6 +993,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Override
     public void close() throws IOException {
+        /*
         try {
             this.lightThread.shutdown(); // Paper
             this.p.close();
@@ -883,7 +1002,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         } finally {
             super.close();
         }
-
+        */
+        this.chunkMainExecutor.close(); // Titanium - tic-tacs
     }
 
     // Paper start - incremental autosave
@@ -1048,13 +1168,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // This is also modeled after PlayerChunkMap#saveChunk(IChunkAccess, boolean), with the intentional difference being
     // serializing the chunk is left to a worker thread.
     private void asyncSave(IChunkAccess chunk) {
-        ChunkCoordIntPair chunkPos = chunk.getPos();
+        ChunkCoordIntPair ChunkCoordIntPair = chunk.getPos();
         NBTTagCompound poiData;
         try (Timing ignored = this.world.timings.chunkUnloadPOISerialization.startTiming()) {
             poiData = this.getVillagePlace().getData(chunk.getPos());
         }
 
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkPos.x, chunkPos.z,
+        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, ChunkCoordIntPair.x, ChunkCoordIntPair.z,
             poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY); // Tuinity - use normal priority
 
         if (!chunk.isNeedsSaving()) {
@@ -1068,7 +1188,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveOverwriteCheck.startTiming()) { // Paper
                 // Paper start - Optimize save by using status cache
                 try {
-                    ChunkStatus statusOnDisk = this.getChunkStatusOnDisk(chunkPos);
+                    ChunkStatus statusOnDisk = this.getChunkStatusOnDisk(ChunkCoordIntPair);
                     if (statusOnDisk != null && statusOnDisk.getType() == ChunkStatus.Type.LEVELCHUNK) {
                         // Paper end
                         return;
@@ -1089,7 +1209,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             asyncSaveData = ChunkRegionLoader.getAsyncSaveData(this.world, chunk);
         }
 
-        this.world.asyncChunkTaskManager.scheduleChunkSave(chunkPos.x, chunkPos.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, // Tuinity - use normal priority
+        this.world.asyncChunkTaskManager.scheduleChunkSave(ChunkCoordIntPair.x, ChunkCoordIntPair.z, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, // Tuinity - use normal priority
             asyncSaveData, chunk);
 
         chunk.setLastSaved(this.world.getTime());
@@ -1156,74 +1276,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
-    protected boolean b() {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot update visibleChunks off of the main thread"); // Tuinity
-        if (!this.updatingChunksModified) {
-            return false;
-        } else {
-            // AirplaneL start
-            /*
-            // Paper start - stop cloning visibleChunks
-            synchronized (this.visibleChunks) {
-                if (isIterating) {
-                    hasPendingVisibleUpdate = true;
-                    this.pendingVisibleChunks.copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk>)this.updatingChunks);
-                } else {
-                    hasPendingVisibleUpdate = false;
-                    this.pendingVisibleChunks.clear();
-                    ((ProtectedVisibleChunksMap)this.visibleChunks).copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk>)this.updatingChunks);
-                    this.visibleChunksClone = null;
-                }
-            }
-            // Paper end
-             */
-            this.internalMap.transfer();
-            // AirplaneL end
-
-            this.updatingChunksModified = false;
-            return true;
-        }
+    private boolean b() {
+        return this.map.flushToVisible();
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(PlayerChunk playerchunk, ChunkStatus chunkstatus) {
-        ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-
-        if (chunkstatus == ChunkStatus.EMPTY) {
-            return this.f(chunkcoordintpair);
-        } else {
-            CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = playerchunk.a(chunkstatus.e(), this);
-
-            return completablefuture.thenComposeAsync((either) -> {
-                Optional<IChunkAccess> optional = either.left();
+        // Titanium start - tic-tacs
+        ChunkStep step = ChunkStep.byStatus(chunkstatus);
 
-                if (!optional.isPresent()) {
-                    return CompletableFuture.completedFuture(either);
-                } else {
-                    if (chunkstatus == ChunkStatus.LIGHT) {
-                        this.chunkDistanceManager.a(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.a(ChunkStatus.FEATURES), chunkcoordintpair);
-                    }
+        ChunkEntry entry = (ChunkEntry) playerchunk;
+        this.upgrader.spawnUpgradeTo(entry, step);
 
-                    IChunkAccess ichunkaccess = (IChunkAccess) optional.get();
-
-                    if (ichunkaccess.getChunkStatus().b(chunkstatus)) {
-                        CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture1; // Paper
-
-                        if (chunkstatus == ChunkStatus.LIGHT) {
-                            completablefuture1 = this.b(playerchunk, chunkstatus);
-                        } else {
-                            completablefuture1 = chunkstatus.a(this.world, this.definedStructureManager, this.lightEngine, (ichunkaccess1) -> {
-                                return this.c(playerchunk);
-                            }, ichunkaccess);
-                        }
-
-                        this.worldLoadListener.a(chunkcoordintpair, chunkstatus);
-                        return completablefuture1;
-                    } else {
-                        return this.b(playerchunk, chunkstatus);
-                    }
-                }
-            }, this.mainInvokingExecutor).thenComposeAsync(CompletableFuture::completedFuture, this.mainInvokingExecutor); // Paper - optimize chunk status progression without jumping through thread pool - ensure main
-        }
+        return entry.getListenerFor(step).asVanilla();
+        // Titanium end - tic-tacs
     }
 
     private CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> f(ChunkCoordIntPair chunkcoordintpair) {
@@ -1358,11 +1423,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void c(ChunkCoordIntPair chunkcoordintpair) {
-        this.executor.a(SystemUtils.a(() -> {
-            this.chunkDistanceManager.b(TicketType.LIGHT, chunkcoordintpair, 33 + ChunkStatus.a(ChunkStatus.FEATURES), chunkcoordintpair);
-        }, () -> {
-            return "release light ticket " + chunkcoordintpair;
-        }));
+        this.mainThreadExecutor.send(() -> {
+            this.ticketManager.removeTicketWithLevel(ChunkTicketType.LIGHT, chunkcoordintpair, ChunkLevelTracker.LIGHT_TICKET_LEVEL, chunkcoordintpair);
+        });
     }
 
     private ChunkStatus a(ChunkStatus chunkstatus, int i) {
@@ -1384,7 +1447,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             ChunkStatus chunkstatus = PlayerChunk.getChunkStatus(playerchunk.getTicketLevel());
 
             return !chunkstatus.b(ChunkStatus.FULL) ? PlayerChunk.UNLOADED_CHUNK_ACCESS : either.mapLeft((ichunkaccess) -> {
-            try (Timing ignored = world.timings.chunkPostLoad.startTimingIfSync()) { // Paper
+            try (Timing ignored = world.timings.ChunkCoordIntPairtLoad.startTimingIfSync()) { // Paper
                 ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
                 Chunk chunk;
 
@@ -1664,15 +1727,15 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public int d() {
-        return this.visibleChunks.size();
+        return this.map.getEntryCount();
     }
 
     protected PlayerChunkMap.a e() {
-        return this.chunkDistanceManager;
+        return this.ticketManager; // Titanium - tic-tacs
     }
 
     protected Iterable<PlayerChunk> f() {
-        return Iterables.unmodifiableIterable(this.getVisibleChunks().values()); // Paper
+        return Iterables.unmodifiableIterable(this.map.visible().getEntries());
     }
 
     void a(Writer writer) throws IOException {
@@ -1763,37 +1826,37 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     // Paper start - chunk status cache "api"
-    public ChunkStatus getChunkStatusOnDiskIfCached(ChunkCoordIntPair chunkPos) {
+    public ChunkStatus getChunkStatusOnDiskIfCached(ChunkCoordIntPair ChunkCoordIntPair) {
         synchronized (this) { // Paper
-        RegionFile regionFile = this.regionFileCache.getRegionFileIfLoaded(chunkPos);
+        RegionFile regionFile = this.regionFileCache.getRegionFileIfLoaded(ChunkCoordIntPair);
 
-        return regionFile == null ? null : regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+        return regionFile == null ? null : regionFile.getStatusIfCached(ChunkCoordIntPair.x, ChunkCoordIntPair.z);
         } // Paper
     }
 
-    public ChunkStatus getChunkStatusOnDisk(ChunkCoordIntPair chunkPos) throws IOException {
+    public ChunkStatus getChunkStatusOnDisk(ChunkCoordIntPair ChunkCoordIntPair) throws IOException {
         // Paper start - async chunk save for unload
-        IChunkAccess unloadingChunk = this.world.asyncChunkTaskManager.getChunkInSaveProgress(chunkPos.x, chunkPos.z);
+        IChunkAccess unloadingChunk = this.world.asyncChunkTaskManager.getChunkInSaveProgress(ChunkCoordIntPair.x, ChunkCoordIntPair.z);
         if (unloadingChunk != null) {
             return unloadingChunk.getChunkStatus();
         }
         // Paper end
         // Paper start - async io
         NBTTagCompound inProgressWrite = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE
-                                             .getPendingWrite(this.world, chunkPos.x, chunkPos.z, false);
+                                             .getPendingWrite(this.world, ChunkCoordIntPair.x, ChunkCoordIntPair.z, false);
 
         if (inProgressWrite != null) {
             return ChunkRegionLoader.getStatus(inProgressWrite);
         }
         // Paper end
         synchronized (this) { // Paper - async io
-            RegionFile regionFile = this.regionFileCache.getFile(chunkPos, true);
+            RegionFile regionFile = this.regionFileCache.getFile(ChunkCoordIntPair, true);
 
-            if (regionFile == null || !regionFile.chunkExists(chunkPos)) {
+            if (regionFile == null || !regionFile.chunkExists(ChunkCoordIntPair)) {
                 return null;
             }
 
-            ChunkStatus status = regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
+            ChunkStatus status = regionFile.getStatusIfCached(ChunkCoordIntPair.x, ChunkCoordIntPair.z);
 
             if (status != null) {
                 return status;
@@ -1801,17 +1864,17 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             // Paper start - async io
         }
 
-        NBTTagCompound compound = this.readChunkData(chunkPos);
+        NBTTagCompound compound = this.readChunkData(ChunkCoordIntPair);
 
         return ChunkRegionLoader.getStatus(compound);
         // Paper end
     }
 
-    public void updateChunkStatusOnDisk(ChunkCoordIntPair chunkPos, @Nullable NBTTagCompound compound) throws IOException {
+    public void updateChunkStatusOnDisk(ChunkCoordIntPair ChunkCoordIntPair, @Nullable NBTTagCompound compound) throws IOException {
         synchronized (this) {
-            RegionFile regionFile = this.regionFileCache.getFile(chunkPos, false);
+            RegionFile regionFile = this.regionFileCache.getFile(ChunkCoordIntPair, false);
 
-            regionFile.setStatus(chunkPos.x, chunkPos.z, ChunkRegionLoader.getStatus(compound));
+            regionFile.setStatus(ChunkCoordIntPair.x, ChunkCoordIntPair.z, ChunkRegionLoader.getStatus(compound));
         }
     }
 
@@ -1846,22 +1909,24 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
         // Paper end
         // variant of PlayerChunkMap#getChunkStatusOnDisk that does not load data off disk, but loads the region file
-        ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
+        ChunkCoordIntPair ChunkCoordIntPair = new ChunkCoordIntPair(x, z);
         synchronized (world.getChunkProvider().playerChunkMap) {
             net.minecraft.server.RegionFile file;
             try {
-                file = world.getChunkProvider().playerChunkMap.regionFileCache.getFile(chunkPos, false);
+                file = world.getChunkProvider().playerChunkMap.regionFileCache.getFile(ChunkCoordIntPair, false);
             } catch (IOException ex) {
                 throw new RuntimeException(ex);
             }
 
-            return !file.chunkExists(chunkPos) ? ChunkStatus.EMPTY : file.getStatusIfCached(x, z);
+            return !file.chunkExists(ChunkCoordIntPair) ? ChunkStatus.EMPTY : file.getStatusIfCached(x, z);
         }
     }
 
     boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair) {
-        // Spigot start
-        return isOutsideOfRange(chunkcoordintpair, false);
+        long pos = chunkcoordintpair.toLong();
+
+        ChunkEntry entry = this.map.visible().getEntry(pos);
+        return entry == null || !entry.isChunkTickable();
     }
 
     // Paper start - optimise isOutsideOfRange
@@ -1941,7 +2006,6 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
 
         // Paper - broadcast view distance map handles this (see remove/add calls above)
-
     }
 
     private SectionPosition c(EntityPlayer entityplayer) {
@@ -2038,50 +2102,24 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        // Paper start - per player view distance
-        // there can be potential desync with player's last mapped section and the view distance map, so use the
-        // view distance map here.
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, long pos) {
+        return this.getPlayersWatchingChunk(pos);
+    }
 
-        if (inRange == null) {
-            return Stream.empty();
+    private Stream<EntityPlayer> getPlayersWatchingChunk(long pos) {
+        ChunkEntry entry = this.map.visible().getEntry(pos);
+        if (entry != null) {
+            return entry.getTrackers().getTrackingPlayers().stream();
         }
-        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
-        List<EntityPlayer> players = new java.util.ArrayList<>();
-        Object[] backingSet = inRange.getBackingSet();
-
-        if (flag) { // flag -> border only
-            for (int i = 0, len = backingSet.length; i < len; ++i) {
-                Object temp = backingSet[i];
-                if (!(temp instanceof EntityPlayer)) {
-                    continue;
-                }
-                EntityPlayer player = (EntityPlayer)temp;
-                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
-                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
-
-                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkcoordintpair.x);
-                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
-                if (Math.max(distX, distZ) == viewDistance) {
-                    players.add(player);
-                }
-            }
-        } else {
-            for (int i = 0, len = backingSet.length; i < len; ++i) {
-                Object temp = backingSet[i];
-                if (!(temp instanceof EntityPlayer)) {
-                    continue;
-                }
-                EntityPlayer player = (EntityPlayer)temp;
-                players.add(player);
-            }
-        }
-        return players.stream();
-        // Paper end - per player view distance
+        return Stream.empty();
     }
 
     protected void addEntity(Entity entity) {
+        if (entity instanceof EnderDragonPart) {
+            return;
+        }
+        this.tracker.getEntities().add(entity);
+        /*
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
         if (!entity.valid || entity.world != this.world || this.trackedEntities.containsKey(entity.getId())) {
@@ -2123,9 +2161,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             }
         }
+        */
     }
 
     protected void removeEntity(Entity entity) {
+        this.tracker.getEntities().remove(entity);
+        /*
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
@@ -2138,6 +2179,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
                 playerchunkmap_entitytracker.clear(entityplayer);
             }
+            
         }
 
         PlayerChunkMap.EntityTracker playerchunkmap_entitytracker1 = (PlayerChunkMap.EntityTracker) this.trackedEntities.remove(entity.getId());
@@ -2146,6 +2188,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             playerchunkmap_entitytracker1.a();
         }
         entity.tracker = null; // Paper - We're no longer tracked
+        */
     }
 
     // Paper start - optimised tracker
@@ -2176,6 +2219,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper end - optimised tracker
 
     protected void g() {
+        this.tracker.tick();
+        /*
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -2218,25 +2263,29 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             world.timings.tracker2.stopTiming(); // Paper
         }
 
-
+        */
     }
 
     protected void broadcast(Entity entity, Packet<?> packet) {
+        /*
         PlayerChunkMap.EntityTracker playerchunkmap_entitytracker = (PlayerChunkMap.EntityTracker) this.trackedEntities.get(entity.getId());
 
         if (playerchunkmap_entitytracker != null) {
             playerchunkmap_entitytracker.broadcast(packet);
         }
-
+        */
+        this.tracker.getEntities().sendToTracking(entity, packet);
     }
 
     protected void broadcastIncludingSelf(Entity entity, Packet<?> packet) {
+        this.tracker.getEntities().sendToTrackingAndSelf(entity, packet);
+        /*
         PlayerChunkMap.EntityTracker playerchunkmap_entitytracker = (PlayerChunkMap.EntityTracker) this.trackedEntities.get(entity.getId());
 
         if (playerchunkmap_entitytracker != null) {
             playerchunkmap_entitytracker.broadcastIncludingSelf(packet);
         }
-
+        */
     }
 
     // Paper start
@@ -2404,10 +2453,35 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         return this.m;
     }
 
-    public CompletableFuture<Void> a(Chunk chunk) {
-        return this.executor.f(() -> {
-            chunk.a(this.world);
-        });
+    public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> a(ChunkHolder holder) {
+        CompletableFuture<Either<Chunk, PlayerChunk.Failure>> future = new CompletableFuture<>();
+        ChunkEntry entry = (ChunkEntry) holder;
+
+        this.spawnOnMainThread(entry, this.getRadiusAs(entry.getPos(), 1, ChunkStep.FULL)
+                .handle((ok, err) -> {
+                    if (err != null) {
+                        future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+                        return Unit.INSTANCE;
+                    }
+
+                    WorldChunk chunk = entry.getWorldChunk();
+                    if (chunk != null) {
+                        chunk.runPostProcessing();
+
+                        this.totalChunksLoadedCount.getAndIncrement();
+                        this.tracker.onChunkFull(entry, chunk);
+                        this.map.getTickingMaps().addTrackableChunk(entry);
+
+                        future.complete(Either.left(chunk));
+                    } else {
+                        future.complete(ChunkHolder.UNLOADED_WORLD_CHUNK);
+                    }
+
+                    return Unit.INSTANCE;
+                })
+        );
+
+        return future;
     }
 
     public class EntityTracker {
@@ -2598,19 +2672,19 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
         @Override
         protected boolean a(long i) {
-            return PlayerChunkMap.this.unloadQueue.contains(i);
+            return this.map.primary().getEntry(i); // Titanium - tic-tacs
         }
 
         @Nullable
         @Override
         protected PlayerChunk b(long i) {
-            return PlayerChunkMap.this.getUpdatingChunk(i);
+            return this.map.visible().getEntry(i); // Titanium - tic-tacs
         }
 
         @Nullable
         @Override
         protected PlayerChunk a(long i, int j, @Nullable PlayerChunk playerchunk, int k) {
-            return PlayerChunkMap.this.a(i, j, playerchunk, k);
+            return this.levelTracker.setLevel(i, j, (ChunkEntry) playerchunk, k); // Titanium - tic-tacs
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/VillagePlaceType.java b/src/main/java/net/minecraft/server/VillagePlaceType.java
index b6b4c8c491d692f93d2c38d602ff99b0611b72aa..7d93d23803e8258f24cae90d88fb8df28c646ce8 100644
--- a/src/main/java/net/minecraft/server/VillagePlaceType.java
+++ b/src/main/java/net/minecraft/server/VillagePlaceType.java
@@ -50,7 +50,7 @@ public class VillagePlaceType {
     public static final VillagePlaceType u = a("bee_nest", a(Blocks.BEE_NEST), 0, 1);
     public static final VillagePlaceType v = a("nether_portal", a(Blocks.NETHER_PORTAL), 0, 1);
     public static final VillagePlaceType w = a("lodestone", a(Blocks.LODESTONE), 0, 1);
-    protected static final Set<IBlockData> x = new ObjectOpenHashSet(VillagePlaceType.A.keySet());
+    public static final Set<IBlockData> x = new ObjectOpenHashSet(VillagePlaceType.A.keySet());
     private final String B;
     private final Set<IBlockData> C;
     private final int D;
