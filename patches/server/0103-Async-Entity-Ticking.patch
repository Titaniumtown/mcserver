From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Wed, 3 Mar 2021 12:02:28 -0500
Subject: [PATCH] Async Entity Ticking

Based off of: https://github.com/PaperMC/Paper/pull/2671 by Bloodrayne1995

diff --git a/src/main/java/com/tuinity/tuinity/util/TickThread.java b/src/main/java/com/tuinity/tuinity/util/TickThread.java
index 08ed243259f052165c6f75aed1d1d65a14219715..2a64e01d2fb84510db14d4627fd15d4c8427cbe8 100644
--- a/src/main/java/com/tuinity/tuinity/util/TickThread.java
+++ b/src/main/java/com/tuinity/tuinity/util/TickThread.java
@@ -22,10 +22,12 @@ public final class TickThread extends Thread {
 
 
     public static void ensureTickThread(final String reason) {
+        /*
         if (!Bukkit.isPrimaryThread()) {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
             throw new IllegalStateException(reason);
         }
+        */
     }
 
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
index 180c724b40228f11ed0c9869779cf466e8e97ebe..507d71825603fdcd64fa1a14469bf7689f3d37fc 100644
--- a/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
+++ b/src/main/java/me/jellysquid/mods/lithium/common/entity/tracker/EntityTrackerEngine.java
@@ -31,7 +31,7 @@ public class EntityTrackerEngine {
     /**
      * Called when an entity is added to the world.
      */
-    public void onEntityAdded(int x, int y, int z, EntityLiving entity) {
+    public synchronized void onEntityAdded(int x, int y, int z, EntityLiving entity) {
         if (this.addEntity(x, y, z, entity)) {
             this.addListener(x, y, z, entity.getListener());
         }
@@ -40,7 +40,7 @@ public class EntityTrackerEngine {
     /**
      * Called when an entity is removed from the world.
      */
-    public void onEntityRemoved(int x, int y, int z, EntityLiving entity) {
+    public synchronized void onEntityRemoved(int x, int y, int z, EntityLiving entity) {
         if (this.removeEntity(x, y, z, entity)) {
             this.removeListener(entity.getListener());
         }
@@ -183,7 +183,7 @@ public class EntityTrackerEngine {
             this.key = key;
         }
 
-        public void addListener(NearbyEntityListener listener) {
+        public synchronized void addListener(NearbyEntityListener listener) {
             for (EntityLiving entity : this.entities) {
                 listener.onEntityEnteredRange(entity);
             }
@@ -191,7 +191,7 @@ public class EntityTrackerEngine {
             this.listeners.add(listener);
         }
 
-        public void removeListener(NearbyEntityListener listener) {
+        public synchronized void removeListener(NearbyEntityListener listener) {
             if (this.listeners.remove(listener)) {
                 for (EntityLiving entity : this.entities) {
                     listener.onEntityLeftRange(entity);
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 04acf3b9052986c0ad305350133644031d240b9b..2adf655f562419da05189cf970d52aef83070c56 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -22,6 +22,7 @@ import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import net.minecraft.server.MCUtil;
 
 public class Chunk implements IChunkAccess {
 
@@ -814,11 +815,13 @@ public class Chunk implements IChunkAccess {
         if (!this.entitySlices[i].remove(entity)) { // Tuinity - optimise hard colliding entities // Tuinity - entities by class // Tuinity
             return;
         }
+        MCUtil.ensureMain(() -> {
         // Yatopia start - Port lithium
         if (entity instanceof EntityLiving) {
             this.world.getEntityTracker().onEntityAdded(entity.chunkX, entity.chunkY, entity.chunkZ, (EntityLiving) entity);
         }
         // Yatopia end
+        });
         if (entity instanceof EntityItem) {
             itemCounts[i]--;
         } else if (entity instanceof IInventory) {
@@ -828,11 +831,14 @@ public class Chunk implements IChunkAccess {
         this.markDirty(); // Paper
         // Paper end
         this.entities.remove(entity); // Paper
+        MCUtil.ensureMain(() -> {
         // Yatopia start - Port lithium
         if (entity instanceof EntityLiving) {
             this.world.getEntityTracker().onEntityRemoved(entity.chunkX, entity.chunkY, entity.chunkZ, (EntityLiving) entity);
         }
         // Yatopia end
+        });
+
     }
 
     public final int getHighestBlockY(HeightMap.Type heightmap_type, int i, int j) { return this.getHighestBlock(heightmap_type, i, j) + 1; } // Paper - sort of an obfhelper, but without -1
diff --git a/src/main/java/net/minecraft/server/CombatTracker.java b/src/main/java/net/minecraft/server/CombatTracker.java
index a8054a599e3eb502e7bbce903b5683987f95fb66..f96fce1e7bf8aa68fe03cdfefa8600d8653ce88e 100644
--- a/src/main/java/net/minecraft/server/CombatTracker.java
+++ b/src/main/java/net/minecraft/server/CombatTracker.java
@@ -5,10 +5,11 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import javax.annotation.Nullable;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public class CombatTracker {
 
-    private final List<CombatEntry> a = Lists.newArrayList();
+    private final CopyOnWriteArrayList<CombatEntry> a = new CopyOnWriteArrayList<>();
     private final EntityLiving b;
     private int c;
     private int d;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 673f2da97c59232d048151c394a84c36264bbdac..7a8efa332ee7f5fd16831d36fd788c69a91c44d0 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -68,6 +68,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import org.yatopiamc.yatopia.server.ticking.AsyncEntityManager;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
 
@@ -808,6 +809,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             worldserver = (WorldServer) iterator.next();
             if (worldserver != null) {
                 try {
+                    worldserver.asyncentitymanager.shutdownExecutors(); // Yatopia
                     worldserver.close();
                 } catch (IOException ioexception) {
                     MinecraftServer.LOGGER.error("Exception closing the level", ioexception);
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 74ba8de1bf70a8bd212906d3dd39bb435c917585..518df27500e6d6bb46c9cc0c67ede886f15aeb7a 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -590,7 +590,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable, NonBlocki
     }
 
     @Override
-    public final boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) { // Paper - final for inline
+    public synchronized final boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) { // Paper - final for inline
         return this.a(blockposition, iblockdata, i, 512);
     }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 1a960e1f839b435da29321ad01751b5df9a630fc..2903020b21e66710bac2c08849659724bc99e832 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -10,6 +10,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import org.yatopiamc.yatopia.server.ticking.AsyncEntityManager;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
@@ -64,7 +65,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
     public static final BlockPosition a = new BlockPosition(100, 50, 0);
     private static final Logger LOGGER = LogManager.getLogger();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2, true); // Tuinity - make removing entities while ticking safe
+    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
+    final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2, true); // Tuinity - make removing entities while ticking safe
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
     public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
@@ -100,6 +102,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     private double fakeTime; // Purpur
 
 
+    public AsyncEntityManager asyncentitymanager = null; // Yatopia - Async entity ticking
     // CraftBukkit start
     private int tickPosition;
     public final Convertable.ConversionSession convertable;
@@ -490,6 +493,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
 
         this.asyncChunkTaskManager = new com.destroystokyo.paper.io.chunk.ChunkTaskManager(this); // Paper
         this.fakeTime = this.worldDataServer.getDayTime(); // Purpur
+        this.asyncentitymanager = new AsyncEntityManager(this); // Yatopia - Async entity Ticking
     }
 
     // Tuinity start - optimise collision
@@ -979,28 +983,19 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             }
 
             this.tickingEntities = true;
+
             com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator = this.entitiesForIteration.iterator(); // Tuinity
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+
             timings.entityTick.startTiming(); // Spigot
+            if (!org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntities) {
             while (objectiterator.hasNext()) {
-                Entity entity = (Entity) objectiterator.next(); // Tuinity
+                Entity entity = (Entity) objectiterator.next();
                 Entity entity1 = entity.getVehicle();
-
-                /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
-                if (!this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
-                    entity.die();
-                }
-
-                if (!this.server.getSpawnNPCs() && entity instanceof NPC) {
-                    entity.die();
-                }
-                // CraftBukkit end */
-
                 gameprofilerfiller.enter("checkDespawn");
                 if (!entity.dead) {
                     entity.checkDespawn();
-                    // Tuinity start - optimise notify()
                     if (entity.inChunk && entity.valid) {
                         if (this.getChunkProvider().isInEntityTickingChunk(entity)) {
                             this.updateNavigatorsInRegion(entity);
@@ -1008,7 +1003,6 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                     } else {
                         this.removeNavigatorsFromData(entity);
                     }
-                    // Tuinity end - optimise notify()
                 }
 
                 gameprofilerfiller.exit();
@@ -1016,7 +1010,6 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                     if (!entity1.dead && entity1.w(entity)) {
                         continue;
                     }
-
                     entity.stopRiding();
                 }
 
@@ -1028,23 +1021,48 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                 gameprofilerfiller.exit();
                 gameprofilerfiller.enter("remove");
                 if (entity.dead) {
-                    this.removeEntityFromChunk(entity);
-                    this.entitiesById.remove(entity.getId()); // Tuinity
-                    this.unregisterEntity(entity);
-                } else if (entity.inChunk && entity.valid) { // Tuinity start - optimise notify()
+                    this.removeEntity(entity);
+                } else if (entity.inChunk && entity.valid) {
                     if (this.getChunkProvider().isInEntityTickingChunk(entity)) {
                         this.updateNavigatorsInRegion(entity);
                     }
                 } else {
                     this.removeNavigatorsFromData(entity);
                 }
-                // Tuinity end - optimise notify()
 
                 gameprofilerfiller.exit();
             }
-            timings.entityTick.stopTiming(); // Spigot
+            } else {
+                while (objectiterator.hasNext()) {
+                    Entity entity = (Entity) objectiterator.next();
+                    Entity entity1 = entity.getVehicle();
+                    gameprofilerfiller.enter("checkDespawn");
+                    if (!entity.dead) {
+                        entity.checkDespawn();
+                        if (entity.inChunk && entity.valid) {
+                            if (this.getChunkProvider().isInEntityTickingChunk(entity)) {
+                                this.updateNavigatorsInRegion(entity);
+                            }
+                        } else {
+                            this.removeNavigatorsFromData(entity);
+                        }
+                    }
+
+                    gameprofilerfiller.exit();
+                    if (entity1 != null) {
+                        if (!entity1.dead && entity1.w(entity)) {
+                            continue;
+                        }
+                        entity.stopRiding();
+                    }
+                }
+
+                this.asyncentitymanager.doTick(this.entitiesForIteration, gameprofilerfiller); // Yatopia - Async entity ticking
+            }
 
             objectiterator.finishedIterating(); // Tuinity
+            timings.entityTick.stopTiming(); // Spigot
+
             this.tickingEntities = false;
             // Paper start
             for (java.lang.Runnable run : this.afterEntityTickingTasks) {
@@ -1341,7 +1359,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     }
 
     // Tuinity start - log detailed entity tick information
-    static final java.util.concurrent.ConcurrentLinkedDeque<Entity> currentlyTickingEntities = new java.util.concurrent.ConcurrentLinkedDeque<>();
+    public static final java.util.concurrent.ConcurrentLinkedDeque<Entity> currentlyTickingEntities = new java.util.concurrent.ConcurrentLinkedDeque<>();
 
     public static List<Entity> getCurrentlyTickingEntities() {
         List<Entity> ret = Lists.newArrayListWithCapacity(4);
@@ -1390,11 +1408,13 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
                     return IRegistry.ENTITY_TYPE.getKey(entity.getEntityType()).toString();
                 });
                 gameprofilerfiller.c("tickNonPassenger");
-                if (isActive) { // Paper - EAR 2
-                    TimingHistory.activatedEntityTicks++; // Paper
-                entity.tick();
-                entity.postTick(); // CraftBukkit
-                } else { entity.inactiveTick(); } // Paper - EAR 2
+                if (isActive) {
+                    TimingHistory.activatedEntityTicks++;
+                    entity.tick();
+                    entity.postTick();
+                } else {
+                    entity.inactiveTick(); // Paper - EAR 2
+                }
                 gameprofilerfiller.exit();
             }
 
@@ -1765,8 +1785,10 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             if (!(ichunkaccess instanceof Chunk)) {
                 return false;
             } else {
+                MCUtil.ensureMain(() -> {
                 ichunkaccess.a(entity);
                 this.registerEntity(entity);
+                });
                 return true;
             }
         }
@@ -1906,7 +1928,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         chunkProvider.getLightEngine().queue.remove(chunk.getPos().pair()); // Yatopia - unregister from light queue
     }
 
-    public void unregisterEntity(Entity entity) {
+    public synchronized void unregisterEntity(Entity entity) {
+        MCUtil.ensureMain(() -> {
         org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
         this.entitiesForIteration.remove(entity); // Tuinity
         // Paper start - fix entity registration issues
@@ -1990,6 +2013,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         new com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent(entity.getBukkitEntity()).callEvent(); // Paper - fire while valid
         this.removeNavigatorsFromData(entity); // Tuinity - optimise notify()
         entity.valid = false; // CraftBukkit
+        });
     }
 
     // Tuinity start - optimise notify()
@@ -2014,7 +2038,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         }
     }
 
-    void removeNavigatorsFromData(Entity entity) {
+    public void removeNavigatorsFromData(Entity entity) {
         com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionSection<PlayerChunkMap.RegionData> section =
                 this.getChunkProvider().playerChunkMap.dataRegionManager.getRegionSection(entity.chunkX, entity.chunkZ);
         if (section != null) {
@@ -2050,7 +2074,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         }
     }
 
-    void updateNavigatorsInRegion(Entity entity) {
+    public void updateNavigatorsInRegion(Entity entity) {
         com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager.RegionSection<PlayerChunkMap.RegionData> section =
                 this.getChunkProvider().playerChunkMap.dataRegionManager.getRegionSection(entity.chunkX, entity.chunkZ);
         if (section != null) {
@@ -2078,7 +2102,8 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
     }
     // Tuinity end - optimise notify()
 
-    private void registerEntity(Entity entity) {
+    private synchronized void registerEntity(Entity entity) {
+        MCUtil.ensureMain(() -> {
         org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
         // Paper start - don't double enqueue entity registration
         //noinspection ObjectEquality
@@ -2088,7 +2113,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             return;
         }
         // Paper end
-        if (false && this.tickingEntities) { // Tuinity
+        if (this.tickingEntities) { // Tuinity
             if (!entity.isQueuedForRegister) { // Paper
                 this.entitiesToAdd.add(entity);
                 entity.isQueuedForRegister = true; // Paper
@@ -2151,20 +2176,26 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
             entity.shouldBeRemoved = false; // Paper - shouldn't be removed after being re-added
             new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entity.getBukkitEntity()).callEvent(); // Paper - fire while valid
         }
+        });
 
     }
 
     public void removeEntity(Entity entity) {
-        if (false && this.tickingEntities) {  // Tuinity
-            throw (IllegalStateException) SystemUtils.c((Throwable) (new IllegalStateException("Removing entity while ticking!")));
-        } else {
-            this.removeEntityFromChunk(entity);
-            this.entitiesById.remove(entity.getId());
-            this.unregisterEntity(entity);
-            entity.shouldBeRemoved = true; // Paper
+        MCUtil.ensureMain(() -> {
+        // this.removeEntityFromChunk(entity);
+        Chunk ichunkaccess = entity.getCurrentChunk(); // Paper - getChunkAt(x,z,full,false) is broken by CraftBukkit as it won't return an unloading chunk. Use our current chunk reference as this points to what chunk they need to be removed from anyways
+
+        if (ichunkaccess != null) { // Paper
+            ((Chunk) ichunkaccess).b(entity);
         }
+
+        this.entitiesById.remove(entity.getId());
+        this.unregisterEntity(entity);
+        entity.shouldBeRemoved = true;
+        });
     }
 
+    /*
     private void removeEntityFromChunk(Entity entity) {
         Chunk ichunkaccess = entity.getCurrentChunk(); // Paper - getChunkAt(x,z,full,false) is broken by CraftBukkit as it won't return an unloading chunk. Use our current chunk reference as this points to what chunk they need to be removed from anyways
 
@@ -2173,6 +2204,7 @@ public class WorldServer extends World implements GeneratorAccessSeed, NonBlocki
         }
 
     }
+    */
 
     public void removePlayer(EntityPlayer entityplayer) {
         entityplayer.die();
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..c0d0e69711e0db496085cc07a6a926036bbcfae2 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -5,7 +5,7 @@ import net.minecraft.server.MinecraftServer;
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
     public static boolean shuttingDown = false; // Paper
 
     public static void catchOp(String reason)
diff --git a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
index cb6ddf318ed07f05e32f8149e7b8be37bb6f1cf1..f3ac86c9f8d2df2573cdd5d6f8d67192a4e438be 100644
--- a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
@@ -304,4 +304,11 @@ public class YatopiaConfig {
         regionFileIOThreadPoolSize = getInt("settings.threads.regionfile", -1);
         Preconditions.checkArgument(regionFileIOThreadPoolSize == -1 || regionFileIOThreadPoolSize > 0, "Invalid settings.threads.regionfile in yatopia.yml");
     }
+
+    public static boolean asyncEntities = false;
+    public static int asyncEntityThreads = 4;
+    private static void asyncentityTicking() {
+        asyncEntities = getBoolean("settings.async-entity.enabled", asyncEntities);
+        asyncEntityThreads = getInt("settings.async-entity.threads", asyncEntityThreads);
+    }
 }
diff --git a/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..13a2d0764d26299709d984f762af2aee1682aa9c
--- /dev/null
+++ b/src/main/java/org/yatopiamc/yatopia/server/ticking/AsyncEntityManager.java
@@ -0,0 +1,191 @@
+package org.yatopiamc.yatopia.server.ticking;
+
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityFallingBlock;
+import net.minecraft.server.EntityComplexPart;
+import net.minecraft.server.WorldServer;
+import net.minecraft.server.GameProfilerFiller;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.bukkit.Server;
+import org.bukkit.Bukkit;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import com.google.common.collect.Lists;
+import co.aikar.timings.TimingHistory;
+import java.util.Iterator;
+
+public class AsyncEntityManager {
+
+    public ExecutorService entityTickPool = Executors.newFixedThreadPool(org.yatopiamc.yatopia.server.YatopiaConfig.asyncEntityThreads);
+
+    private CopyOnWriteArrayList<Entity> targetEntitiesTick = new CopyOnWriteArrayList<>();
+    private CopyOnWriteArrayList<Entity> targetEntitiesInactive = new CopyOnWriteArrayList<>();
+    private CopyOnWriteArrayList<Entity> targetEntitiesRemove = new CopyOnWriteArrayList<>();
+
+    WorldServer worldserver = null;
+
+    public AsyncEntityManager(WorldServer worldserver) {
+        this.worldserver = worldserver;
+    }
+
+    public void queueEntity(Entity entity) {
+        targetEntitiesTick.add(entity);
+    }
+
+    public void queueEntityInactive(Entity entity) {
+        targetEntitiesInactive.add(entity);
+    }
+
+    public void queueEntityRemove(Entity entity) {
+        targetEntitiesRemove.add(entity);
+    }
+
+    public void entityInactiveTick(Entity entity) {
+        entity.inactiveTick();
+    }
+
+    public void entityActiveTick(Entity entity) {
+        entity.tick();
+        entity.postTick();
+    }
+
+    public boolean shouldTickEntityAsync(Entity entity) {
+        if (!(entity instanceof EntityHuman) && !(entity instanceof EntityFallingBlock)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void entityJoinedWorld(Entity entity) {
+        try {
+            worldserver.currentlyTickingEntities.push(entity);
+        if (!(entity instanceof EntityHuman) && !worldserver.getChunkProvider().a(entity)) {
+            worldserver.chunkCheck(entity);
+        } else {
+            ++TimingHistory.entityTicks;
+            co.aikar.timings.Timing timer;
+            final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
+            timer = isActive ? entity.getEntityType().tickTimer.startTiming() : entity.getEntityType().inactiveTickTimer.startTiming();
+            try {
+            entity.g(entity.locX(), entity.locY(), entity.locZ());
+            entity.lastYaw = entity.yaw;
+            entity.lastPitch = entity.pitch;
+            if (entity.inChunk) {
+                ++entity.ticksLived;
+                GameProfilerFiller gameprofilerfiller = worldserver.getMethodProfiler();
+                /*
+                gameprofilerfiller.a(() -> {
+                    return IRegistry.ENTITY_TYPE.getKey(entity.getEntityType()).toString();
+                });
+                */
+                gameprofilerfiller.c("tickNonPassenger");
+                if (shouldTickEntityAsync(entity)) {
+                    if (isActive) {
+                        TimingHistory.activatedEntityTicks++;
+                        queueEntity(entity);
+                    } else {
+                        queueEntityInactive(entity);
+                    }
+                } else {
+                    if (isActive) {
+                        TimingHistory.activatedEntityTicks++;
+                        entity.tick();
+                        entity.postTick();
+                    } else {
+                        entity.inactiveTick();
+                    }
+                }
+                gameprofilerfiller.exit();
+            }
+
+            worldserver.chunkCheck(entity);
+            } finally { timer.stopTiming(); }
+            if (entity.inChunk) {
+                Iterator iterator = entity.getPassengers().iterator();
+                while (iterator.hasNext()) {
+                    Entity entity1 = (Entity) iterator.next();
+                    worldserver.a(entity, entity1);
+                }
+            }
+
+        }
+        } finally {
+            worldserver.currentlyTickingEntities.pop();
+        }
+    }
+
+
+    public void tickEntity(Entity entity, GameProfilerFiller gameprofilerfiller) {
+        Entity entity1 = entity.getVehicle();
+        gameprofilerfiller.enter("tick");
+        if (!entity.dead && !(entity instanceof EntityComplexPart)) {
+            worldserver.a(this::entityJoinedWorld, entity);
+        }
+        gameprofilerfiller.exit();
+    }
+
+    public void doTick(com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration, GameProfilerFiller gameprofilerfiller) {
+        List<Entity> entityList = Lists.newArrayList(entitiesForIteration.iterator());
+        entityList.stream().forEach(entity -> {
+            tickEntity(entity, gameprofilerfiller);
+        });
+
+        targetEntitiesTick.stream().map(entity -> CompletableFuture.runAsync(() -> entityActiveTick(entity), entityTickPool)).collect(Collectors.toSet());
+
+        targetEntitiesInactive.stream().map(entity -> CompletableFuture.runAsync(() -> entityInactiveTick(entity), entityTickPool)).collect(Collectors.toSet());
+
+
+        entityList.stream().forEach(entity -> {
+            if (entity.dead) {
+                queueEntityRemove(entity);
+            } else if (entity.inChunk && entity.valid) {
+                if (worldserver.getChunkProvider().isInEntityTickingChunk(entity)) {
+                    worldserver.updateNavigatorsInRegion(entity);
+                }
+            } else {
+                worldserver.removeNavigatorsFromData(entity);
+            }
+        });
+
+        gameprofilerfiller.enter("remove");
+        targetEntitiesRemove.stream().forEach(entity -> {
+            worldserver.removeEntity(entity);
+        });
+        gameprofilerfiller.exit();
+
+        targetEntitiesTick.clear();
+        targetEntitiesInactive.clear();
+        targetEntitiesRemove.clear();
+    }
+
+
+    public void startTick() {
+        targetEntitiesTick.stream().map(entity -> CompletableFuture.runAsync(() -> entityActiveTick(entity), entityTickPool)).collect(Collectors.toSet());
+
+        targetEntitiesInactive.stream().map(entity -> CompletableFuture.runAsync(() -> entityInactiveTick(entity), entityTickPool)).collect(Collectors.toSet());
+
+        targetEntitiesTick.clear();
+        targetEntitiesInactive.clear();
+    }
+
+    public void shutdownExecutors() {
+        entityTickPool.shutdown();
+        while (!entityTickPool.isTerminated()) {
+            try {
+                entityTickPool.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+
+}
