From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Paul Sauve <paul@technove.co>
Date: Sun, 1 Nov 2020 16:45:21 -0600
Subject: [PATCH] Concurrent visibleChunks and updatingChunks

This is slightly more complicated than the loadedChunkMap change, it
works by using one map to represent both maps, then when it needs to
update the visibleChunks it just sets the visible reference to the value
of the updated one. This provides no copies, while also allowing
concurrent access to the map.

An improvement that should be made later is to
ConcLong2ObjectOpenHashMap's entry set iterator to not make a copy of
the entire map, because it's used for the visible/updating map values()
iterator which is used fairly heavily.

Airplane Lite
Copyright (C) 2020 Technove LLC

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 27bcbfe73aeb638c3303ef2a56c6563c7388a277..d87a675ee78d8596bb03694ee57636cca43fb590 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -72,8 +72,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
     // Paper start - faster copying
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<>(); // Paper - faster copying
-    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = new ProtectedVisibleChunksMap(); // Paper - faster copying
+    // AirplaneL start - swap for our maps
+    private final gg.airplane.structs.ChunkMapMap internalMap = new gg.airplane.structs.ChunkMapMap();
+    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> updatingChunks = this.internalMap.getUpdatingMap(); // Paper - faster copying
+    public final Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = this.internalMap.getVisibleMap(); // Paper - faster copying
+    // AirplaneL end
 
     private class ProtectedVisibleChunksMap extends com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> {
         @Override
@@ -609,7 +612,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     @Nullable
     public PlayerChunk getUpdatingChunk(long i) { // Paper
-        return (PlayerChunk) this.updatingChunks.get(i);
+        // AirplaneL start
+        gg.airplane.structs.ChunkMapMap.ChunkMapChunk chunk = this.internalMap.get(i);
+        return chunk == null ? null : chunk.updating;
+        // AirplaneL end
     }
 
     // Paper start - remove cloning of visible chunks unless accessed as a collection async
@@ -617,6 +623,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private boolean isIterating = false;
     private boolean hasPendingVisibleUpdate = false;
     public void forEachVisibleChunk(java.util.function.Consumer<PlayerChunk> consumer) {
+        // AirplaneL start
+        /*
         org.spigotmc.AsyncCatcher.catchOp("forEachVisibleChunk");
         boolean prev = isIterating;
         isIterating = true;
@@ -632,8 +640,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 this.hasPendingVisibleUpdate = false;
             }
         }
+         */
+        this.visibleChunks.values().forEach(consumer);
+        // AirplaneL end
     }
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
+        // AirplaneL start
+        /*
         if (Thread.currentThread() == this.world.serverThread) {
             return this.visibleChunks;
         } else {
@@ -645,11 +658,16 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 return this.visibleChunksClone;
             }
         }
+         */
+        return this.visibleChunks;
+        // AirplaneL end
     }
     // Paper end
 
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
+        // AirplaneL start
+        /*
         // Paper start - mt safe get
         if (Thread.currentThread() != this.world.serverThread) {
             synchronized (this.visibleChunks) {
@@ -658,6 +676,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         }
         return (PlayerChunk) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(i) : ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(i));
         // Paper end
+         */
+        gg.airplane.structs.ChunkMapMap.ChunkMapChunk chunk = this.internalMap.get(i);
+        return chunk == null ? null : chunk.visible;
+        // AirplaneL end
     }
     // Airplane start - since neither map can be updated during tracker tick, it's safe to allow direct retrieval here
     private PlayerChunk trackerGetVisibleChunk(long i) {
@@ -786,7 +808,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
                 this.getVillagePlace().dequeueUnload(playerchunk.location.pair()); // Tuinity - unload POI data
 
-                this.updatingChunks.put(i, playerchunk);
+                // AirplaneL start
+                this.internalMap.addUpdatingChunk(i, playerchunk);
+                //this.updatingChunks.put(i, playerchunk);
+                // AirplaneL end
                 this.updatingChunksModified = true;
             }
 
@@ -939,7 +964,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         while (longiterator.hasNext()) { // Spigot
             long j = longiterator.nextLong();
             longiterator.remove(); // Spigot
-            PlayerChunk playerchunk = (PlayerChunk) this.updatingChunks.remove(j);
+            PlayerChunk playerchunk = (PlayerChunk) this.internalMap.removeUpdatingChunk(j); // AirplaneL
 
             if (playerchunk != null) {
                 this.pendingUnload.put(j, playerchunk);
@@ -1082,6 +1107,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         if (!this.updatingChunksModified) {
             return false;
         } else {
+            // AirplaneL start
+            /*
             // Paper start - stop cloning visibleChunks
             synchronized (this.visibleChunks) {
                 if (isIterating) {
@@ -1095,6 +1122,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
             // Paper end
+             */
+            this.internalMap.transfer();
+            // AirplaneL end
 
             this.updatingChunksModified = false;
             return true;
