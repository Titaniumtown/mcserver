From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Sat, 9 Jan 2021 19:21:16 +0800
Subject: [PATCH] Threaded WorldGen

A massive improvement to world generation.
This patch actually schedules chunk status upgrade later rather than doing it right away.

diff --git a/pom.xml b/pom.xml
index 6109699411c349c4965de6dbdbd9f8454bc18b10..8f42f14b24d8679f4bd6db090db8142935cb7975 100644
--- a/pom.xml
+++ b/pom.xml
@@ -182,6 +182,12 @@
             <artifactId>commons-rng-core</artifactId>
             <version>1.3</version>
         </dependency>
+        <!-- https://mvnrepository.com/artifact/com.ibm.async/asyncutil -->
+        <dependency>
+            <groupId>com.ibm.async</groupId>
+            <artifactId>asyncutil</artifactId>
+            <version>0.1.0</version>
+        </dependency>
     </dependencies>
 
     <repositories>
diff --git a/src/main/java/net/minecraft/server/ChunkGenerator.java b/src/main/java/net/minecraft/server/ChunkGenerator.java
index 6223d1d9048e31fb10cec7f485d1556aec2c7d5e..01caa55482aa963dfe7726e652a1157aa90f5631 100644
--- a/src/main/java/net/minecraft/server/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/server/ChunkGenerator.java
@@ -20,6 +20,7 @@ public abstract class ChunkGenerator {
     private final StructureSettings structureSettings;
     private final long e;
     private final List<ChunkCoordIntPair> f;
+    public final com.ibm.asyncutil.locks.AsyncLock featureGenLock = com.ibm.asyncutil.locks.AsyncLock.createFair(); // Yatopia - threaded WorldGen
 
     public ChunkGenerator(WorldChunkManager worldchunkmanager, StructureSettings structuresettings) {
         this(worldchunkmanager, worldchunkmanager, structuresettings, 0L);
diff --git a/src/main/java/net/minecraft/server/ChunkStatus.java b/src/main/java/net/minecraft/server/ChunkStatus.java
index 51ea295d66312c95685b9fe4ee502a029d2fff20..eee9e29392a0bde2cae02f26a05cfda7416c4c68 100644
--- a/src/main/java/net/minecraft/server/ChunkStatus.java
+++ b/src/main/java/net/minecraft/server/ChunkStatus.java
@@ -9,11 +9,52 @@ import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
+// Yatopia start
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+// Yatopia end
 import java.util.function.Function;
 import javax.annotation.Nullable;
 
 public class ChunkStatus {
 
+    // Yatopia start - threaded WorldGen
+    private static final ThreadPoolExecutor featureGenExecutor = new ThreadPoolExecutor(
+            org.yatopiamc.yatopia.server.YatopiaConfig.featureGenExecutorSize == -1 ? Math.min(Runtime.getRuntime().availableProcessors(), 3) : org.yatopiamc.yatopia.server.YatopiaConfig.featureGenExecutorSize,
+            org.yatopiamc.yatopia.server.YatopiaConfig.featureGenExecutorSize == -1 ? Math.min(Runtime.getRuntime().availableProcessors(), 3) : org.yatopiamc.yatopia.server.YatopiaConfig.featureGenExecutorSize,
+            0,
+            TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks FeatureGen Worker #%d").build()
+    );
+    private static final ThreadPoolExecutor worldGenExecutor = new ThreadPoolExecutor(
+            org.yatopiamc.yatopia.server.YatopiaConfig.worldGenExecutorSize == -1 ? Math.min(Runtime.getRuntime().availableProcessors(), 8) : org.yatopiamc.yatopia.server.YatopiaConfig.worldGenExecutorSize,
+            org.yatopiamc.yatopia.server.YatopiaConfig.worldGenExecutorSize == -1 ? Math.min(Runtime.getRuntime().availableProcessors(), 8) : org.yatopiamc.yatopia.server.YatopiaConfig.worldGenExecutorSize,
+            0,
+            TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Yatopia Async Chunks WorldGen Worker #%d").build()
+    );
+
+    static void shutdownExecutors() {
+        featureGenExecutor.shutdown();
+        worldGenExecutor.shutdown();
+        while (!featureGenExecutor.isTerminated()) {
+            try {
+                featureGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+        while (!worldGenExecutor.isTerminated()) {
+            try {
+                worldGenExecutor.awaitTermination(30, TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+
+    }
+    // Yatopia end
     private static final EnumSet<HeightMap.Type> n = EnumSet.of(HeightMap.Type.OCEAN_FLOOR_WG, HeightMap.Type.WORLD_SURFACE_WG);
     private static final EnumSet<HeightMap.Type> o = EnumSet.of(HeightMap.Type.OCEAN_FLOOR, HeightMap.Type.WORLD_SURFACE, HeightMap.Type.MOTION_BLOCKING, HeightMap.Type.MOTION_BLOCKING_NO_LEAVES);
     private static final ChunkStatus.c p = (chunkstatus, worldserver, definedstructuremanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -26,6 +67,8 @@ public class ChunkStatus {
     public static final ChunkStatus EMPTY = a("empty", (ChunkStatus) null, -1, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (worldserver, chunkgenerator, list, ichunkaccess) -> {
     });
     public static final ChunkStatus STRUCTURE_STARTS = a("structure_starts", ChunkStatus.EMPTY, 0, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        // Yatopia start - threaded WorldGen
+        return CompletableFuture.supplyAsync(() -> {
         if (!ichunkaccess.getChunkStatus().b(chunkstatus)) {
             if (worldserver.worldDataServer.getGeneratorSettings().shouldGenerateMapFeatures()) { // CraftBukkit
                 chunkgenerator.createStructures(worldserver.r(), worldserver.getStructureManager(), ichunkaccess, definedstructuremanager, worldserver.getSeed());
@@ -35,8 +78,9 @@ public class ChunkStatus {
                 ((ProtoChunk) ichunkaccess).a(chunkstatus);
             }
         }
-
-        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+        return Either.left(ichunkaccess);
+        }, worldGenExecutor);
+        // Yatopia end
     });
     public static final ChunkStatus STRUCTURE_REFERENCES = a("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.n, ChunkStatus.Type.PROTOCHUNK, (worldserver, chunkgenerator, list, ichunkaccess) -> {
         RegionLimitedWorldAccess regionlimitedworldaccess = new RegionLimitedWorldAccess(worldserver, list);
@@ -61,6 +105,9 @@ public class ChunkStatus {
         chunkgenerator.doCarving(worldserver.getSeed(), worldserver.d(), ichunkaccess, WorldGenStage.Features.LIQUID);
     });
     public static final ChunkStatus FEATURES = a("features", ChunkStatus.LIQUID_CARVERS, 8, ChunkStatus.o, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        // Yatopia start - threaded WorldGen
+        return chunkgenerator.featureGenLock.acquireLock().toCompletableFuture().thenComposeAsync(token -> {
+        try {
         ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
 
         protochunk.a((LightEngine) lightenginethreaded);
@@ -71,8 +118,13 @@ public class ChunkStatus {
             chunkgenerator.addDecorations(regionlimitedworldaccess, worldserver.getStructureManager().a(regionlimitedworldaccess));
             protochunk.a(chunkstatus);
         }
+        } finally {
+            token.releaseLock();
+        }
 
         return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+        }, featureGenExecutor);
+        // Yatopia end
     });
     public static final ChunkStatus LIGHT = a("light", ChunkStatus.FEATURES, 1, ChunkStatus.o, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, definedstructuremanager, lightenginethreaded, function, list, ichunkaccess) -> {
         return a(chunkstatus, lightenginethreaded, ichunkaccess);
@@ -245,14 +297,18 @@ public class ChunkStatus {
 
         @Override
         default CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> doWork(ChunkStatus chunkstatus, WorldServer worldserver, ChunkGenerator chunkgenerator, DefinedStructureManager definedstructuremanager, LightEngineThreaded lightenginethreaded, Function<IChunkAccess, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function, List<IChunkAccess> list, IChunkAccess ichunkaccess) {
+            // Yatopia start - threaded worldGen
+            return CompletableFuture.supplyAsync(() -> {
             if (!ichunkaccess.getChunkStatus().b(chunkstatus)) {
                 this.doWork(worldserver, chunkgenerator, list, ichunkaccess);
                 if (ichunkaccess instanceof ProtoChunk) {
                     ((ProtoChunk) ichunkaccess).a(chunkstatus);
                 }
             }
+            return Either.left(ichunkaccess);
+            }, worldGenExecutor);
 
-            return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+            // Yatopia end
         }
 
         void doWork(WorldServer worldserver, ChunkGenerator chunkgenerator, List<IChunkAccess> list, IChunkAccess ichunkaccess);
diff --git a/src/main/java/net/minecraft/server/GenLayers.java b/src/main/java/net/minecraft/server/GenLayers.java
index 7abf0e4b7e96dd367b9d03cbc62ac7bb03542d0a..76a76c26650bca73828d7893a537a0235f573e20 100644
--- a/src/main/java/net/minecraft/server/GenLayers.java
+++ b/src/main/java/net/minecraft/server/GenLayers.java
@@ -6,7 +6,7 @@ import java.util.function.LongFunction;
 
 public class GenLayers {
 
-    private static final Int2IntMap a = (Int2IntMap) SystemUtils.a((Object) (new Int2IntOpenHashMap()), (int2intopenhashmap) -> {
+    private static final Int2IntMap a = (Int2IntMap) SystemUtils.a((new Int2IntOpenHashMap()), (int2intopenhashmap) -> { // Yatopia - decompile fix
         a(int2intopenhashmap, GenLayers.Type.BEACH, 16);
         a(int2intopenhashmap, GenLayers.Type.BEACH, 26);
         a(int2intopenhashmap, GenLayers.Type.DESERT, 2);
@@ -154,6 +154,11 @@ public class GenLayers {
         return new GenLayer(areafactory);
     }
 
+    // Yatopia start
+    public static ThreadLocal<GenLayer> genLayerThreadLocal(long i, boolean flag, int j, int k) {
+        return ThreadLocal.withInitial(() -> new GenLayer(a(flag, j, k, (l) -> new WorldGenContextArea(25, i, l))));
+    }
+    // Yatopia end
     public static boolean a(int i, int j) {
         return i == j ? true : GenLayers.a.get(i) == GenLayers.a.get(j);
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 89db3d0bbb4d683907943b2dc01404d69b0cc842..77d8c85a1305ce17220772ff2e191ea341af5e75 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -835,6 +835,8 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         // Spigot end
         // Paper start - move final shutdown items here
         LOGGER.info("Flushing Chunk IO");
+        PlayerChunkMap.shutdownScheduler(); // Yatopia
+        ChunkStatus.shutdownExecutors(); // Yatopia
         com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.close(true); // Paper // Yatopia
         LOGGER.info("Closing Thread Pool");
         SystemUtils.shutdownServerThreadPool(); // Paper
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 09e3861f8a8f50d810fc1ff1fb5f4a2f24b5f09e..122bd635a35847d03849f47112e399026a1b8aa6 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -57,6 +57,18 @@ import org.spigotmc.AsyncCatcher;
 
 public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
+    // Yatopia start
+    static final java.util.concurrent.ExecutorService worldGenScheduler = java.util.concurrent.Executors.newSingleThreadExecutor(new com.google.common.util.concurrent.ThreadFactoryBuilder().setNameFormat("Yatopia Async Chunks Scheduler").setDaemon(true).setPriority(Thread.NORM_PRIORITY - 1).build());
+    static void shutdownScheduler() {
+        worldGenScheduler.shutdown();
+        while (!worldGenScheduler.isTerminated()) {
+            try {
+                worldGenScheduler.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS);
+            } catch (InterruptedException ignored) {
+            }
+        }
+    }
+    // Yatopia end
     private static final Logger LOGGER = LogManager.getLogger();
     public static final int GOLDEN_TICKET = 33 + ChunkStatus.b();
     // Paper start - faster copying
@@ -1320,7 +1332,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 return;
             }
             // Paper end
-            this.mailboxWorldGen.a(ChunkTaskQueueSorter.a(playerchunk, runnable));
+            worldGenScheduler.execute(runnable); // Yatopia
         }).thenComposeAsync((either) -> { // Tuinity start - force competion on the main thread
             return CompletableFuture.completedFuture(either);
         }, this.mainInvokingExecutor);
diff --git a/src/main/java/net/minecraft/server/SystemUtils.java b/src/main/java/net/minecraft/server/SystemUtils.java
index 61d399077f87fc1f198811ee31fc779b6f0ecfa9..98ec9db831697f59ddbefaee7e22d01888082485 100644
--- a/src/main/java/net/minecraft/server/SystemUtils.java
+++ b/src/main/java/net/minecraft/server/SystemUtils.java
@@ -115,6 +115,7 @@ public class SystemUtils {
         return SystemUtils.d;
     }
 
+    public static Executor getMainThreadExecutor() { return f(); } // Yatopia - OBFHELPER
     public static Executor f() {
         return SystemUtils.e;
     }
diff --git a/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java b/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
index d98ac030e205dbb1512ef6b837e2f3fdd208e231..451ea5b703d01664942899ca62cf789e2cd15ab9 100644
--- a/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
+++ b/src/main/java/net/minecraft/server/WorldChunkManagerOverworld.java
@@ -19,7 +19,7 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
             return worldchunkmanageroverworld.k;
         })).apply(instance, instance.stable(WorldChunkManagerOverworld::new));
     });
-    private final GenLayer f;
+    private final ThreadLocal<GenLayer> f; // Yatopia
     private static final List<ResourceKey<BiomeBase>> g = ImmutableList.of(Biomes.OCEAN, Biomes.PLAINS, Biomes.DESERT, Biomes.MOUNTAINS, Biomes.FOREST, Biomes.TAIGA, Biomes.SWAMP, Biomes.RIVER, Biomes.FROZEN_OCEAN, Biomes.FROZEN_RIVER, Biomes.SNOWY_TUNDRA, Biomes.SNOWY_MOUNTAINS, new ResourceKey[]{Biomes.MUSHROOM_FIELDS, Biomes.MUSHROOM_FIELD_SHORE, Biomes.BEACH, Biomes.DESERT_HILLS, Biomes.WOODED_HILLS, Biomes.TAIGA_HILLS, Biomes.MOUNTAIN_EDGE, Biomes.JUNGLE, Biomes.JUNGLE_HILLS, Biomes.JUNGLE_EDGE, Biomes.DEEP_OCEAN, Biomes.STONE_SHORE, Biomes.SNOWY_BEACH, Biomes.BIRCH_FOREST, Biomes.BIRCH_FOREST_HILLS, Biomes.DARK_FOREST, Biomes.SNOWY_TAIGA, Biomes.SNOWY_TAIGA_HILLS, Biomes.GIANT_TREE_TAIGA, Biomes.GIANT_TREE_TAIGA_HILLS, Biomes.WOODED_MOUNTAINS, Biomes.SAVANNA, Biomes.SAVANNA_PLATEAU, Biomes.BADLANDS, Biomes.WOODED_BADLANDS_PLATEAU, Biomes.BADLANDS_PLATEAU, Biomes.WARM_OCEAN, Biomes.LUKEWARM_OCEAN, Biomes.COLD_OCEAN, Biomes.DEEP_WARM_OCEAN, Biomes.DEEP_LUKEWARM_OCEAN, Biomes.DEEP_COLD_OCEAN, Biomes.DEEP_FROZEN_OCEAN, Biomes.SUNFLOWER_PLAINS, Biomes.DESERT_LAKES, Biomes.GRAVELLY_MOUNTAINS, Biomes.FLOWER_FOREST, Biomes.TAIGA_MOUNTAINS, Biomes.SWAMP_HILLS, Biomes.ICE_SPIKES, Biomes.MODIFIED_JUNGLE, Biomes.MODIFIED_JUNGLE_EDGE, Biomes.TALL_BIRCH_FOREST, Biomes.TALL_BIRCH_HILLS, Biomes.DARK_FOREST_HILLS, Biomes.SNOWY_TAIGA_MOUNTAINS, Biomes.GIANT_SPRUCE_TAIGA, Biomes.GIANT_SPRUCE_TAIGA_HILLS, Biomes.MODIFIED_GRAVELLY_MOUNTAINS, Biomes.SHATTERED_SAVANNA, Biomes.SHATTERED_SAVANNA_PLATEAU, Biomes.ERODED_BADLANDS, Biomes.MODIFIED_WOODED_BADLANDS_PLATEAU, Biomes.MODIFIED_BADLANDS_PLATEAU});
     private final long h;
     private final boolean i;
@@ -36,7 +36,7 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
         this.i = flag;
         this.j = flag1;
         this.k = iregistry;
-        this.f = GenLayers.a(i, flag, flag1 ? 6 : 4, 4);
+        this.f = GenLayers.genLayerThreadLocal(i, flag, flag1 ? 6 : 4, 4); // Yatopia
     }
 
     @Override
@@ -46,6 +46,6 @@ public class WorldChunkManagerOverworld extends WorldChunkManager {
 
     @Override
     public BiomeBase getBiome(int i, int j, int k) {
-        return this.f.a(this.k, i, k);
+        return this.f.get().a(this.k, i, k); // Yatopia
     }
 }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 40e87f3043da14b1265fcdadde02bef3b261a9d1..8a28b98d35dcdfbd4bb55a3b7f2d963cf7b997d6 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -2548,28 +2548,26 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
         // Paper start
         BlockPosition blockposition1 = blockposition.immutableCopy();
+        // Yatopia start - reduce scheduling overhead
         this.getMinecraftServer().execute(() -> {
                 if (!optional.isPresent() && this.getPoiStorage().test(blockposition1, com.google.common.base.Predicates.alwaysTrue())) {
                     this.getPoiStorage().remove(blockposition1);
                 }
-        });
         if (!Objects.equals(optional, optional1)) {
             //BlockPosition blockposition1 = blockposition.immutableCopy();
             // Paper end
 
             optional.ifPresent((villageplacetype) -> {
-                this.getMinecraftServer().execute(() -> {
                     this.y().a(blockposition1);
                     PacketDebug.b(this, blockposition1);
-                });
             });
             optional1.ifPresent((villageplacetype) -> {
-                this.getMinecraftServer().execute(() -> {
                     this.y().a(blockposition1, villageplacetype);
                     PacketDebug.a(this, blockposition1);
-                });
             });
         }
+        });
+        // Yatopia end
     }
 
     public final VillagePlace getPoiStorage() { return this.y(); } // Paper - OBFHELPER
diff --git a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
index 1a2e15c6fd6e6654b0a6d6b0826814f5180a3e17..1362783943fd5956040a4c2035daaefa0e8ea3a5 100644
--- a/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
+++ b/src/main/java/org/yatopiamc/yatopia/server/YatopiaConfig.java
@@ -1,5 +1,6 @@
 package org.yatopiamc.yatopia.server;
 
+import com.google.common.base.Preconditions;
 import com.google.common.base.Throwables;
 import java.io.File;
 import java.io.IOException;
@@ -286,4 +287,13 @@ public class YatopiaConfig {
         regionFileIOThreadPoolSize = getInt("settings.threads.regionfile", -1);
         Preconditions.checkArgument(regionFileIOThreadPoolSize == -1 || regionFileIOThreadPoolSize > 0, "Invalid settings.threads.regionfile in yatopia.yml");
     }
+
+    public static int featureGenExecutorSize = -1;
+    public static int worldGenExecutorSize = -1;
+    private static void multiThreadedWorldGen() {
+        featureGenExecutorSize = getInt("settings.threads.featuregen", -1);
+        Preconditions.checkArgument(featureGenExecutorSize == -1 || featureGenExecutorSize > 0, "Invalid settings.threads.featuregen in yatopia.yml");
+        worldGenExecutorSize = getInt("settings.threads.worldgen", -1);
+        Preconditions.checkArgument(worldGenExecutorSize == -1 || worldGenExecutorSize > 0, "Invalid settings.threads.worldgen in yatopia.yml");
+    }
 }
