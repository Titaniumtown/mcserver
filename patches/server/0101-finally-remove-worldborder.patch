From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Gardling <titaniumtown@gmail.com>
Date: Fri, 26 Feb 2021 18:04:05 -0500
Subject: [PATCH] finally remove worldborder


diff --git a/src/main/java/net/minecraft/server/WorldBorder.java b/src/main/java/net/minecraft/server/WorldBorder.java
index 7e9a5a22201985da78baa358a56a40ec7b9b6954..a8775bb4c315fa0e20745d7d25a9b86d5b344c8c 100644
--- a/src/main/java/net/minecraft/server/WorldBorder.java
+++ b/src/main/java/net/minecraft/server/WorldBorder.java
@@ -29,38 +29,45 @@ public class WorldBorder {
 
     public final boolean isInBounds(BlockPosition blockposition) { return this.a(blockposition); } // Paper - OBFHELPER
     public boolean a(BlockPosition blockposition) {
-        return (double) (blockposition.getX() + 1) > this.e() && (double) blockposition.getX() < this.g() && (double) (blockposition.getZ() + 1) > this.f() && (double) blockposition.getZ() < this.h();
+        // return (double) (blockposition.getX() + 1) > this.e() && (double) blockposition.getX() < this.g() && (double) (blockposition.getZ() + 1) > this.f() && (double) blockposition.getZ() < this.h();
+        return true;
     }
 
     // Paper start
     private final BlockPosition.MutableBlockPosition mutPos = new BlockPosition.MutableBlockPosition();
     public boolean isBlockInBounds(int chunkX, int chunkZ) {
-        this.mutPos.setValues(chunkX, 64, chunkZ);
-        return this.isInBounds(this.mutPos);
+        // this.mutPos.setValues(chunkX, 64, chunkZ);
+        // return this.isInBounds(this.mutPos);
+        return true;
     }
     public boolean isChunkInBounds(int chunkX, int chunkZ) {
-        this.mutPos.setValues(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
-        return this.isInBounds(this.mutPos);
+        // this.mutPos.setValues(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
+        // return this.isInBounds(this.mutPos);
+        return true;
     }
     // Paper end
 
     public boolean isInBounds(ChunkCoordIntPair chunkcoordintpair) {
-        return (double) chunkcoordintpair.f() > this.e() && (double) chunkcoordintpair.d() < this.g() && (double) chunkcoordintpair.g() > this.f() && (double) chunkcoordintpair.e() < this.h();
+        // return (double) chunkcoordintpair.f() > this.e() && (double) chunkcoordintpair.d() < this.g() && (double) chunkcoordintpair.g() > this.f() && (double) chunkcoordintpair.e() < this.h();
+        return true;
     }
 
     public final boolean isInBounds(AxisAlignedBB aabb) { return this.a(aabb); } // Paper - OBFHELPER
     public boolean a(AxisAlignedBB axisalignedbb) {
-        return axisalignedbb.maxX > this.e() && axisalignedbb.minX < this.g() && axisalignedbb.maxZ > this.f() && axisalignedbb.minZ < this.h();
+        // return axisalignedbb.maxX > this.e() && axisalignedbb.minX < this.g() && axisalignedbb.maxZ > this.f() && axisalignedbb.minZ < this.h();
+        return true;
     }
 
     // Tuinity start - optimise collisions
     // determines whether we are almost colliding with the world border
     // for clear collisions, this rets false
     public final boolean isAlmostCollidingOnBorder(AxisAlignedBB boundingBox) {
-        return this.isAlmostCollidingOnBorder(boundingBox.minX, boundingBox.maxX, boundingBox.minZ, boundingBox.maxZ);
+        // return this.isAlmostCollidingOnBorder(boundingBox.minX, boundingBox.maxX, boundingBox.minZ, boundingBox.maxZ);
+        return false;
     }
 
     public final boolean isAlmostCollidingOnBorder(double boxMinX, double boxMaxX, double boxMinZ, double boxMaxZ) {
+        /*
         double borderMinX = this.getMinX();
         double borderMaxX = this.getMaxX();
 
@@ -83,13 +90,17 @@ public class WorldBorder {
                         borderMinX, Double.NEGATIVE_INFINITY, borderMinZ, borderMaxX, Double.POSITIVE_INFINITY, borderMaxZ
                 )
                 ;
+        */
+        return false;
     }
 
     public final boolean isCollidingWithBorderEdge(AxisAlignedBB boundingBox) {
-        return this.isCollidingWithBorderEdge(boundingBox.minX, boundingBox.maxX, boundingBox.minZ, boundingBox.maxZ);
+        // return this.isCollidingWithBorderEdge(boundingBox.minX, boundingBox.maxX, boundingBox.minZ, boundingBox.maxZ);
+        return false;
     }
 
     public final boolean isCollidingWithBorderEdge(double boxMinX, double boxMaxX, double boxMinZ, double boxMaxZ) {
+        /*
         double borderMinX = this.getMinX() + MCUtil.COLLISION_EPSILON;
         double borderMaxX = this.getMaxX() - MCUtil.COLLISION_EPSILON;
 
@@ -97,6 +108,8 @@ public class WorldBorder {
         double borderMaxZ = this.getMaxZ() - MCUtil.COLLISION_EPSILON;
 
         return boxMinX < borderMinX || boxMaxX > borderMaxX || boxMinZ < borderMinZ || boxMaxZ > borderMaxZ;
+        */
+        return false;
     }
     // Tuinity end - optimise collisions
 
@@ -164,7 +177,8 @@ public class WorldBorder {
     }
 
     public double getSize() {
-        return this.j.e();
+        // return this.j.e();
+        return 4294967294D;
     }
 
     public long j() {
@@ -334,7 +348,8 @@ public class WorldBorder {
             this.d = worldborder.getDamageBuffer();
             this.e = worldborder.getWarningDistance();
             this.f = worldborder.getWarningTime();
-            this.g = worldborder.getSize();
+            // this.g = worldborder.getSize();
+            this.g = 4294967294D;
             this.h = worldborder.j();
             this.i = worldborder.k();
         }
