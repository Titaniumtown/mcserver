From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E3=84=97=E3=84=A0=CB=8B=20=E3=84=91=E3=84=A7=CB=8A?=
 <tsao-chi@the-lingo.org>
Date: Sun, 31 May 2020 11:21:53 +0800
Subject: [PATCH] Option for async world ticking

Improted from https://github.com/tr7zw/YAPFA/blob/1a54ef2f995f049d4fcf1f2bd084691126f10046/patches/server/0040-Add-MainThreadHandler-to-allow-custom-MainThreads.patch and https://github.com/tr7zw/YAPFA/blob/1a54ef2f995f049d4fcf1f2bd084691126f10046/patches/server/0046-Option-for-async-world-ticking.patch

diff --git a/src/main/java/de/tr7zw/yapfa/MainThreadHandler.java b/src/main/java/de/tr7zw/yapfa/MainThreadHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..f66e15e76e1f4b1357b386eec162be5616b70309
--- /dev/null
+++ b/src/main/java/de/tr7zw/yapfa/MainThreadHandler.java
@@ -0,0 +1,24 @@
+package de.tr7zw.yapfa;
+
+import org.bukkit.craftbukkit.util.WeakCollection;
+
+/**
+ * All Threads that are stored in this Collection are considered "MainThread"
+ * for all intents and purposes.
+ * 
+ * @author tr7zw
+ *
+ */
+public class MainThreadHandler {
+
+	private static WeakCollection<Thread> weakMainThreads = new WeakCollection<Thread>();
+
+	public static void registerThread(Thread thread) {
+		weakMainThreads.add(thread);
+	}
+
+	public static boolean isMainThread(Thread thread) {
+		return weakMainThreads.contains(thread);
+	}
+
+}
diff --git a/src/main/java/me/titaniumtown/TitaniumConfig.java b/src/main/java/me/titaniumtown/TitaniumConfig.java
index cc128896477ae03f1d6fa1849094496a9bb9948e..dc1173bc0d2e7b19f096a9df4d6ba099f00225f4 100644
--- a/src/main/java/me/titaniumtown/TitaniumConfig.java
+++ b/src/main/java/me/titaniumtown/TitaniumConfig.java
@@ -156,10 +156,12 @@ public class TitaniumConfig {
     public static boolean allowSandDupe = false;
     public static boolean worldBorderChecks = true;
     public static boolean allowAllDupes = false;
+    public static boolean asyncWorldTick = false;
     private static void experimental() {
         allowSandDupe = getBoolean("settings.experimental.allow-sand-dupe", allowSandDupe);
         worldBorderChecks = getBoolean("settings.experimental.world-border-checks", worldBorderChecks);
         allowAllDupes = getBoolean("settings.experimental.allow-all-dupes", allowAllDupes);
+        asyncWorldTick = getBoolean("settings.experimental.async-world-tick", asyncWorldTick);
     }
 
     public static double WborderSize = 6.0E7D; // Vanilla 6.0E7D; Max: 4.294967294E9D // replacement for 6.0E7D
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index f1c686810fb4e9c05df45d664c93af73d17f0624..dec1b62c61b157003c3eeb42a1669da199fb12ec 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -108,6 +108,7 @@ public abstract class ChunkMapDistance {
     protected void purgeTickets() {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async purge tickets"); // Tuinity
         ++this.currentTick;
+        synchronized (tickets) {
         ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
         // Tuinity start - delay chunk unloads
@@ -147,7 +148,7 @@ public abstract class ChunkMapDistance {
             tempLevel[0] = PlayerChunkMap.GOLDEN_TICKET + 1; // Tuinity - reset
         }
 
-    }
+    }}
 
     private static int getLowestTicketLevel(ArraySetSorted<Ticket<?>> arraysetsorted) {
         AsyncCatcher.catchOp("ChunkMapDistance::getLowestTicketLevel"); // Paper
@@ -250,7 +251,9 @@ public abstract class ChunkMapDistance {
         }
 
         if (arraysetsorted.isEmpty()) {
-            this.tickets.remove(i);
+        	synchronized (tickets) {
+        		this.tickets.remove(i);
+        	}
         }
 
         int newLevel = getLowestTicketLevel(arraysetsorted); // Paper
@@ -421,9 +424,11 @@ public abstract class ChunkMapDistance {
 
     private ArraySetSorted<Ticket<?>> e(long i) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async tickets compute"); // Tuinity
+        synchronized (tickets) {
         return (ArraySetSorted) this.tickets.computeIfAbsent(i, (j) -> {
             return ArraySetSorted.a(4);
         });
+        }
     }
 
     protected void a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
@@ -463,16 +468,18 @@ public abstract class ChunkMapDistance {
     }
 
     protected String c(long i) {
-        ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) this.tickets.get(i);
-        String s;
+    	synchronized (tickets) {
+    		ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) this.tickets.get(i);
+            String s;
 
-        if (arraysetsorted != null && !arraysetsorted.isEmpty()) {
-            s = ((Ticket) arraysetsorted.b()).toString();
-        } else {
-            s = "no_ticket";
-        }
+            if (arraysetsorted != null && !arraysetsorted.isEmpty()) {
+                s = ((Ticket) arraysetsorted.b()).toString();
+            } else {
+                s = "no_ticket";
+            }
 
-        return s;
+            return s;
+		}
     }
 
     protected void setNoTickViewDistance(int i) { // Paper - force abi breakage on usage change
@@ -502,6 +509,7 @@ public abstract class ChunkMapDistance {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async ticket remove"); // Tuinity
         Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
 
+        synchronized (tickets) {
         for (java.util.Iterator<Entry<ArraySetSorted<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
             Entry<ArraySetSorted<Ticket<?>>> entry = iterator.next();
             ArraySetSorted<Ticket<?>> tickets = entry.getValue();
@@ -515,6 +523,7 @@ public abstract class ChunkMapDistance {
                 }
             }
         }
+        }
     }
     // CraftBukkit end
 
@@ -526,9 +535,11 @@ public abstract class ChunkMapDistance {
 
         @Override
         protected int b(long i) {
-            ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) ChunkMapDistance.this.tickets.get(i);
+        	synchronized (tickets) {
+        		ArraySetSorted<Ticket<?>> arraysetsorted = (ArraySetSorted) ChunkMapDistance.this.tickets.get(i);
 
-            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.b()).b());
+                return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.b()).b());
+			}
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 83e3dcbbe36ce1f947f387ec55067e51a1b7384a..ce45c0a1d47ba7bab49b2ac58d9a172620f13883 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -667,7 +667,7 @@ public class ChunkProviderServer extends IChunkProvider {
             return ifLoaded;
         }
         // AirplaneL end
-        if (Thread.currentThread() != this.serverThread) {
+        if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index ad06bd81eded5d60f16c2d0ad1a4390f4b5a11a5..3d7127f03a5ae69386431f64015232eed99de5dd 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -89,7 +89,7 @@ public class EntityTrackerEntry {
 
             if (this.tickCounter % 10 == 0 && itemstack.getItem() instanceof ItemWorldMap) { // CraftBukkit - Moved this.tickCounter % 10 logic here so item frames do not enter the other blocks
                 WorldMap worldmap = ItemWorldMap.getSavedMap(itemstack, this.b);
-                Iterator iterator = this.trackedPlayers.iterator(); // CraftBukkit
+                Iterator iterator = new HashSet<>(this.trackedPlayers).iterator(); // CraftBukkit
 
                 while (iterator.hasNext()) {
                     EntityPlayer entityplayer = (EntityPlayer) iterator.next();
diff --git a/src/main/java/net/minecraft/server/IAsyncTaskHandler.java b/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
index 27db247aa40e0516302c74b9bf00c631a8607af5..dab2309ea8e564a1b79c577ea1781723a5f2a736 100644
--- a/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
+++ b/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
@@ -1,6 +1,9 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Queues;
+
+import de.tr7zw.yapfa.MainThreadHandler;
+
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -25,7 +28,7 @@ public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return MainThreadHandler.isMainThread(Thread.currentThread()); // YAPFA
     }
 
     protected abstract Thread getThread();
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index e79e773f2219f9a9ae076fcbc8108b792201b11a..013a02d834711dbd78adfa33ac8d69910ffc9b00 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -12,6 +12,8 @@ import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonWriter;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
+
+import de.tr7zw.yapfa.MainThreadHandler;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import org.bukkit.Location;
 import org.bukkit.block.BlockFace;
@@ -362,7 +364,7 @@ public final class MCUtil {
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && !MainThreadHandler.isMainThread(Thread.currentThread())) { // YAPFA
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -387,7 +389,7 @@ public final class MCUtil {
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && !MainThreadHandler.isMainThread(Thread.currentThread())) { // YAPFA
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 1fd7cec23b0e5cec99065af26b7182944ea7893e..9fc8c41933d44ca1f7f51e36937518fd5aeea101 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import co.aikar.timings.Timings;
+import de.tr7zw.yapfa.MainThreadHandler;
+
 import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
 import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
@@ -49,6 +51,14 @@ import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
@@ -71,6 +81,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 import co.aikar.timings.MinecraftTimings; // Paper
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import org.spigotmc.WatchdogThread;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
 
@@ -183,6 +194,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         thread.setUncaughtExceptionHandler((thread1, throwable) -> {
             MinecraftServer.LOGGER.error(throwable);
         });
+        MainThreadHandler.registerThread(thread); // YAPFA
         S s0 = function.apply(thread); // CraftBukkit - decompile error
 
         atomicreference.set(s0);
@@ -1357,6 +1369,29 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
+    // Akarin start
+    
+    public static final ThreadFactory threadFactory = new ThreadFactory() {
+
+        private final AtomicInteger id = new AtomicInteger(0);
+
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new Thread(r);
+            thread.setName("ASYNC_WORLD_THREAD" + "_" + id.incrementAndGet());
+            de.tr7zw.yapfa.MainThreadHandler.registerThread(thread);
+            return thread;
+        }
+    };
+    
+    public final ExecutorService worldPool = new ThreadPoolExecutor(3, 50, 60, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<Runnable>(), MinecraftServer.threadFactory);
+    
+    public static long worldTick = 0;
+    public static boolean asyncWorlds = false;
+    
+    // Akarin end
+    
     protected void b(BooleanSupplier booleansupplier) {
         // Tuinity - replace logic
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
@@ -1401,6 +1436,25 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
 
+        if (me.titaniumtown.TitaniumConfig.asyncWorldTick && !Timings.isTimingsEnabled()) {
+            asyncWorlds = true;
+            try {
+                worldTick = worldPool.invokeAll(new ArrayList<WorldServer>(this.worldServer.values())).parallelStream().mapToLong(f -> {
+                    try {
+                        return f.get();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    } catch (ExecutionException e) {
+                        e.printStackTrace();
+                    }
+                    return 100000;
+                }).sum();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        } else {
+        asyncWorlds = false;
+        long start = System.currentTimeMillis();
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
             worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
@@ -1447,6 +1501,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
             this.methodProfiler.exit();
             worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
+        }
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 0c4dcccfa2bb4b0367505695885441a4b4b6ea48..90189e5989c6ac3316de717dff85fc9ffc839c4d 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -26,6 +26,8 @@ import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.HashMap; // Paper
+import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -706,7 +708,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
         // AirplaneL start
         /*
-        if (Thread.currentThread() == this.world.serverThread) {
+        if (de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             return this.visibleChunks;
         } else {
             synchronized (this.visibleChunks) {
@@ -728,7 +730,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         // AirplaneL start
         /*
         // Paper start - mt safe get
-        if (Thread.currentThread() != this.world.serverThread) {
+        if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             synchronized (this.visibleChunks) {
                 return (PlayerChunk) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(i) : ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(i));
             }
@@ -2474,7 +2476,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.trackedPlayers.iterator();
+            Iterator iterator = new HashSet<>(this.trackedPlayers).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
@@ -2493,7 +2495,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void a() {
-            Iterator iterator = this.trackedPlayers.iterator();
+            Iterator iterator = new HashSet<>(this.trackedPlayers).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
@@ -2579,7 +2581,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void track(List<EntityPlayer> list) {
-            Iterator iterator = list.iterator();
+            Iterator iterator = new ArrayList<>(list).iterator();
 
             while (iterator.hasNext()) {
                 EntityPlayer entityplayer = (EntityPlayer) iterator.next();
diff --git a/src/main/java/net/minecraft/server/PlayerConnectionUtils.java b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
index e698dd22607b2b2c4068c5bfb03ac53eb5bac080..898517bb8fa6a756d0a7d6ea064781995287fffa 100644
--- a/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
+++ b/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
@@ -4,13 +4,23 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import co.aikar.timings.Timings;
 
 public class PlayerConnectionUtils {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
     public static <T extends PacketListener> void ensureMainThread(Packet<T> packet, T t0, WorldServer worldserver) throws CancelledPacketHandleException {
-        ensureMainThread(packet, t0, (IAsyncTaskHandler) worldserver.getMinecraftServer());
+        // Akarin start
+		if (Timings.isTimingsEnabled() || packet instanceof PacketPlayInCustomPayload) {
+			ensureMainThread(packet, t0, (IAsyncTaskHandler) worldserver.getMinecraftServer());
+		} else {
+			if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) {
+				worldserver.packets.add(() -> packet.a(t0));
+				throw CancelledPacketHandleException.INSTANCE;
+			}
+		}
+    	// Akarin end
     }
 
     // Tuinity start - detailed watchdog information
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index a3b7704492f6a5af4c05d15e3692d15c1392955e..f8d49935d35fc382a655cd39f775a8e7b3fde8e8 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -45,7 +45,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     protected final List<TileEntity> tileEntityListPending = Lists.newArrayList();
     protected final java.util.Set<TileEntity> tileEntityListUnload = com.google.common.collect.Sets.newHashSet();
-    public final Thread serverThread;
+    // public final Thread serverThread;
     private final boolean debugWorld;
     private int d;
     protected int n = (new Random()).nextInt();
@@ -233,7 +233,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
             this.worldBorder = new WorldBorder();
         }
 
-        this.serverThread = Thread.currentThread();
+        // this.serverThread = Thread.currentThread();
         this.biomeManager = new BiomeManager(this, i, dimensionmanager.getGenLayerZoomer());
         this.debugWorld = flag1;
         // CraftBukkit start
@@ -1109,7 +1109,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && !de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             return null;
         } else {
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 0e2bbf292be2bd20b01ec6e630ea3d8a8e8d3cc8..9abe1ce301c0d525e2dd50633c4bff0e47dfbcc6 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -23,6 +23,7 @@ import java.io.BufferedWriter;
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -33,6 +34,7 @@ import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -241,7 +243,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, int toX, int toZ, // Yatopia
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -634,7 +636,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || !de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -2873,4 +2875,40 @@ public class WorldServer extends World implements GeneratorAccessSeed {
         }
         // CraftBukkit end
     }
+    
+    // Akarin start
+    public List<Runnable> packets = new ArrayList<Runnable>();
+    
+	public Long call() throws Exception {
+		long start = System.currentTimeMillis();
+		List<Runnable> copy = new ArrayList<>(packets);
+		copy.forEach(r -> {
+			packets.remove(r);
+			r.run();
+		});
+        hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+        TileEntityHopper.skipHopperEvents = paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+
+        try {
+            doTick(server::canSleepForTick);
+        } catch (Throwable throwable) {
+            // Spigot Start
+            CrashReport crashreport;
+            try {
+                crashreport = CrashReport.a(throwable, "Exception ticking world");
+            } catch (Throwable t) {
+                throw new RuntimeException("Error generating crash report", t);
+            }
+            // Spigot End
+
+            a(crashreport);
+            throw new ReportedException(crashreport);
+        }
+
+        explosionDensityCache.clear(); // Paper - Optimize explosions
+		return System.currentTimeMillis() - start;
+	}
+	
+	// Akarin end
+    
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 491c91fa4c8901c5c3ec61679508211556164890..7da80c3be4aa880f5c53980c8b01201c31883854 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -15,6 +15,7 @@ import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.LiteralCommandNode;
 import com.mojang.serialization.DynamicOps;
 import com.mojang.serialization.Lifecycle;
+import de.tr7zw.yapfa.MainThreadHandler;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
@@ -1868,7 +1869,7 @@ public final class CraftServer implements Server {
     public boolean isPrimaryThread() {
         // Tuinity start
         final Thread currThread = Thread.currentThread();
-        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return MainThreadHandler.isMainThread(currThread) || currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
         // Tuinity End
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index a69b38f293723a58691b2777d170f9cc146d1148..495da9c9be6271ae36f26744d13a7ecb5e3f9160 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -469,7 +469,7 @@ public class CraftWorld implements World {
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (!de.tr7zw.yapfa.MainThreadHandler.isMainThread(Thread.currentThread())) { // Akarin
             synchronized (world.getChunkProvider().playerChunkMap.visibleChunks) {
                 Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
                 return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
@@ -677,7 +677,10 @@ public class CraftWorld implements World {
     @Override
     public Collection<Plugin> getPluginChunkTickets(int x, int z) {
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
-        ArraySetSorted<Ticket<?>> tickets = chunkDistanceManager.tickets.get(ChunkCoordIntPair.pair(x, z));
+        ArraySetSorted<Ticket<?>> tickets = null;
+        synchronized (chunkDistanceManager.tickets) {
+        	tickets = chunkDistanceManager.tickets.get(ChunkCoordIntPair.pair(x, z));
+		}
 
         if (tickets == null) {
             return Collections.emptyList();
@@ -698,22 +701,24 @@ public class CraftWorld implements World {
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
 
-        for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
-            long chunkKey = chunkTickets.getLongKey();
-            ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
-
-            Chunk chunk = null;
-            for (Ticket<?> ticket : tickets) {
-                if (ticket.getTicketType() != TicketType.PLUGIN_TICKET) {
-                    continue;
-                }
-
-                if (chunk == null) {
-                    chunk = this.getChunkAt(ChunkCoordIntPair.getX(chunkKey), ChunkCoordIntPair.getZ(chunkKey));
-                }
-
-                ret.computeIfAbsent((Plugin) ticket.identifier, (key) -> ImmutableList.builder()).add(chunk);
-            }
+        synchronized (chunkDistanceManager.tickets) {
+	        for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
+	            long chunkKey = chunkTickets.getLongKey();
+	            ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
+	
+	            Chunk chunk = null;
+	            for (Ticket<?> ticket : tickets) {
+	                if (ticket.getTicketType() != TicketType.PLUGIN_TICKET) {
+	                    continue;
+	                }
+	
+	                if (chunk == null) {
+	                    chunk = this.getChunkAt(ChunkCoordIntPair.getX(chunkKey), ChunkCoordIntPair.getZ(chunkKey));
+	                }
+	
+	                ret.computeIfAbsent((Plugin) ticket.identifier, (key) -> ImmutableList.builder()).add(chunk);
+	            }
+	        }
         }
 
         return ret.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, (entry) -> entry.getValue().build()));
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
index 3c8946837351bf5a469be494b735d414e1801c20..c0369adfd825e8b2ea9c83a63c15cc686eb7b862 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
@@ -18,23 +18,29 @@ public final class WeakCollection<T> implements Collection<T> {
     @Override
     public boolean add(T value) {
         Validate.notNull(value, "Cannot add null value");
-        return collection.add(new WeakReference<T>(value));
+        synchronized (collection) {
+        	return collection.add(new WeakReference<T>(value));
+		}
     }
 
     @Override
     public boolean addAll(Collection<? extends T> collection) {
-        Collection<WeakReference<T>> values = this.collection;
-        boolean ret = false;
-        for (T value : collection) {
-            Validate.notNull(value, "Cannot add null value");
-            ret |= values.add(new WeakReference<T>(value));
-        }
-        return ret;
+    	synchronized (collection) {
+	        Collection<WeakReference<T>> values = this.collection;
+	        boolean ret = false;
+	        for (T value : collection) {
+	            Validate.notNull(value, "Cannot add null value");
+	            ret |= values.add(new WeakReference<T>(value));
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public void clear() {
-        collection.clear();
+    	synchronized (collection) {
+    		collection.clear();
+    	}
     }
 
     @Override
@@ -42,17 +48,21 @@ public final class WeakCollection<T> implements Collection<T> {
         if (object == null) {
             return false;
         }
-        for (T compare : this) {
-            if (object.equals(compare)) {
-                return true;
-            }
+        synchronized (collection) {
+	        for (T compare : this) {
+	            if (object.equals(compare)) {
+	                return true;
+	            }
+	        }
+	        return false;
         }
-        return false;
     }
 
     @Override
     public boolean containsAll(Collection<?> collection) {
-        return toCollection().containsAll(collection);
+    	synchronized (collection) {
+    		return toCollection().containsAll(collection);
+    	}
     }
 
     @Override
@@ -73,20 +83,22 @@ public final class WeakCollection<T> implements Collection<T> {
                     return true;
                 }
 
-                Iterator<WeakReference<T>> it = this.it;
-                value = null;
-
-                while (it.hasNext()) {
-                    WeakReference<T> ref = it.next();
-                    value = ref.get();
-                    if (value == null) {
-                        it.remove();
-                    } else {
-                        this.value = value;
-                        return true;
-                    }
+                synchronized (collection) {
+	                Iterator<WeakReference<T>> it = this.it;
+	                value = null;
+	
+	                while (it.hasNext()) {
+	                    WeakReference<T> ref = it.next();
+	                    value = ref.get();
+	                    if (value == null) {
+	                        it.remove();
+	                    } else {
+	                        this.value = value;
+	                        return true;
+	                    }
+	                }
+	                return false;
                 }
-                return false;
             }
 
             @Override
@@ -119,49 +131,57 @@ public final class WeakCollection<T> implements Collection<T> {
             return false;
         }
 
-        Iterator<T> it = this.iterator();
-        while (it.hasNext()) {
-            if (object.equals(it.next())) {
-                it.remove();
-                return true;
-            }
+        synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        while (it.hasNext()) {
+	            if (object.equals(it.next())) {
+	                it.remove();
+	                return true;
+	            }
+	        }
+	        return false;
         }
-        return false;
     }
 
     @Override
     public boolean removeAll(Collection<?> collection) {
-        Iterator<T> it = this.iterator();
-        boolean ret = false;
-        while (it.hasNext()) {
-            if (collection.contains(it.next())) {
-                ret = true;
-                it.remove();
-            }
-        }
-        return ret;
+    	synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        boolean ret = false;
+	        while (it.hasNext()) {
+	            if (collection.contains(it.next())) {
+	                ret = true;
+	                it.remove();
+	            }
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public boolean retainAll(Collection<?> collection) {
-        Iterator<T> it = this.iterator();
-        boolean ret = false;
-        while (it.hasNext()) {
-            if (!collection.contains(it.next())) {
-                ret = true;
-                it.remove();
-            }
-        }
-        return ret;
+    	synchronized (collection) {
+	        Iterator<T> it = this.iterator();
+	        boolean ret = false;
+	        while (it.hasNext()) {
+	            if (!collection.contains(it.next())) {
+	                ret = true;
+	                it.remove();
+	            }
+	        }
+	        return ret;
+    	}
     }
 
     @Override
     public int size() {
-        int s = 0;
-        for (T value : this) {
-            s++;
-        }
-        return s;
+    	synchronized (collection) {
+	        int s = 0;
+	        for (T value : this) {
+	            s++;
+	        }
+	        return s;
+    	}
     }
 
     @Override
@@ -175,10 +195,12 @@ public final class WeakCollection<T> implements Collection<T> {
     }
 
     private Collection<T> toCollection() {
-        ArrayList<T> collection = new ArrayList<T>();
-        for (T value : this) {
-            collection.add(value);
-        }
-        return collection;
+    	synchronized (collection) {
+	        ArrayList<T> collection = new ArrayList<T>();
+	        for (T value : this) {
+	            collection.add(value);
+	        }
+	        return collection;
+    	}
     }
 }
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 51e9c54cddf4b28ba3d3d892322c487774bdab70..0ca4a25a85ff2eb0f06669c7402cfba9b8f57353 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import net.minecraft.server.MinecraftServer;
+import de.tr7zw.yapfa.MainThreadHandler;
 
 public class AsyncCatcher
 {
@@ -10,7 +11,7 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread() ) // Tuinity
+        if ( ( enabled || com.tuinity.tuinity.util.TickThread.STRICT_THREAD_CHECKS ) && !org.bukkit.Bukkit.isPrimaryThread() && !MainThreadHandler.isMainThread(Thread.currentThread()) ) // Tuinity
         {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed thread check for reason: Asynchronous " + reason, new Throwable()); // Tuinity - not all exceptions are printed
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 3c7b9a6d24e064f9c1ec5fb6d52f42627944d7fa..d080434451d76072d8a511805aa2ba5acc52a33f 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -34,6 +34,8 @@ public class TicksPerSecondCommand extends Command
             tpsAvg[i] = format( tps[i] );
         }
         sender.sendMessage(ChatColor.GOLD + "TPS from last 5s, 1m, 5m, 15m: " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", ")); // Purpur
+        sender.sendMessage( ChatColor.GOLD + "Async world ticking: " + net.minecraft.server.MinecraftServer.asyncWorlds);
+        sender.sendMessage( ChatColor.GOLD + "The worlds where ticking for " + net.minecraft.server.MinecraftServer.worldTick + "ms");
         if (args.length > 0 && args[0].equals("mem") && sender.hasPermission("bukkit.command.tpsmemory")) {
             sender.sendMessage(ChatColor.GOLD + "Current Memory Usage: " + ChatColor.GREEN + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / (1024 * 1024)) + "/" + (Runtime.getRuntime().totalMemory() / (1024 * 1024)) + " mb (Max: " + (Runtime.getRuntime().maxMemory() / (1024 * 1024)) + " mb)");
             if (!hasShownMemoryWarning) {
